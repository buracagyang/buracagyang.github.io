{"posts":[{"title":"A&#x2F;B-test显著性检验","text":"同步于CSDN;音尘杂记； 1. A/B-test解读A/B-test是为同一个目标制定两个方案，在同一时间维度，分别让组成成分相同（相似）的用户群组随机的使用一个方案，收集各群组的用户体验数据和业务数据，最后根据显著性检验分析评估出最好版本正式采用。 使用A/B-test首先需要建立一个待测试的版本服务，这个版本服务可能在标题、字体、排版、背景颜色、措辞等方面与原有版本服务有所不同，然后将这两个版本服务以随机的方式同时推送给测试用户。接下来分别统计两个版本的用户转化率指标，然后根据样本数据进行显著性检验。 2. 测试目的页面（版本）的某一特定更新对转化率指标（如UV-线索转化率、UV-上架转化率、UV-成交转化率或者线索-上架转化率等）的影响效果。 3. A/B-test显著性检验随机将测试用户群分为2部分，用户群1使用A方案，用户群2使用B方案，经过一定测试时间后，根据收集到的两方案样本观测数据，根据显著性检验结果选取最好方案。 为了下文方便说明，我们不妨设A方案为参考方案（或旧方案），B方案为实验方案（或新方案）。以下我们以xx二手车的线索-车辆成交转化率为例（注：所有数据均属虚构，仅做示例说明之用），假设进行A/B-test的时间是一周。 3.1 选择观测指标使用A方案的人数$N_A$，使用B方案的人数$N_B$，通常情况下$N_A = N_B = N$；由样本计算出A方案的线索-车辆成交转化率为$\\hat{P}_a$，B方案的线索-车辆成交转化率 为$\\hat{P}_b$；总体A的分布：$A \\sim B(N, P_a)$，总体B的分布：$B \\sim B(N, P_b)$； 根据中心极限定理可知，$\\hat{P}_a$和$\\hat{P}_b$均可认为近似服从正态分布：$$\\begin{eqnarray}\\hat{P}_a \\sim N(P_a, \\hat{P}_a(1-\\hat{P}_a) / N) \\\\hat{P}_b \\sim N(P_b, \\hat{P}_b(1-\\hat{P}_b) / N)\\end{eqnarray} \\tag{1.1}$$ 所以根据正态分布的性质：$$X = \\hat{P}_b - \\hat{P}_a \\sim N(P_b-P_a, \\hat{P}_b(1-\\hat{P}_b) / N + \\hat{P}_a(1-\\hat{P}_a) / N) \\tag{1.2}$$ 3.2 建立原假设和备择假设由于我们的期望结果是B方案所带来的线索-车辆成交转化率高于A方案所带来的线索 -车辆成交转化率，所以原假设和备择假设如下：$$\\begin{eqnarray}H_0: X = P_b - P_a \\leq 0 \\H_1: X = P_b - P_a &gt; 0\\end{eqnarray} \\tag{1.3}$$ 3.3 构建检验统计量检验统计量：$$Z = \\frac{\\hat{P}_b - \\hat{P}_a}{\\sqrt{\\frac{\\hat{P}_b(1-\\hat{P}_b)}{N} + \\frac{\\hat{P}_a(1-\\hat{P}_a)}{N}}} \\tag{1.4}$$ 3.4 显著性检验结论给定显著性水平$\\alpha$为。当$Z &gt; Z_{\\alpha}$时，拒绝原假设，认为B方案所带来的线索-车辆成交转化率高于A方案所带来的线索-车辆成交转化率，建议可以进行推广；当$Z \\leq Z_{\\alpha}$时，不能拒绝原假设，即认为B方案所带来的线索-车辆成交转化率不高于A方案所带来的线索-车辆成交转化率，建议暂不建议进行推广。 4. A/B-test示例假设我们进行A/B-test一周，参考版本（通常默认是原始版本，简记为A）和实验版本（添加了特定改进的版本,简记为B），分别得到了1000个线索，A的线索-车辆成交转化率为7%，B的线索-车辆成交转化率为8%。如下表所示： 版本 总线索数 成交数(单位：辆) 转化率 参考版本(A) 1,000 70 7.00% 实验版本(B) 1,000 80 8.00% 在这儿，我们是肯定B比A版本所带来的转化率高呢，还是说这仅仅是由于一些随机的因素导致的这样的区别呢？我们严格按照A/B-test显著性检验过程进行如下计算。 选取测量指标： $N_A = N_B = N = 1000$；其中$\\hat{P}_a = 7%$，$\\hat{P}_b = 8%$ 构建原假设和备择假设：$$\\begin{eqnarray}H_0&amp;:&amp; B版本所带来的线索-车辆成交转化率不高于A版本，即X=P_b - P_a \\leq 0 \\H_1&amp;:&amp; B版本所带来的线索-车辆成交转化率高于A版本，即X=P_b - P_a &gt; 0\\end{eqnarray}$$ 构建检验统计量：$$Z = \\frac{\\hat{P}_b - \\hat{P}_a}{\\sqrt{\\frac{\\hat{P}_b(1-\\hat{P}_b)}{N} + \\frac{\\hat{P}_a(1-\\hat{P}_a)}{N}}}$$带入值，可以计算得到Z=0.849105726， 显著性检验结论： 如果取显著性水平$\\alpha = 0.5$，则$Z_{\\alpha} = 1.644854$，所以不能拒绝原假设，即认为B版本不一定比A版本所带来的线索-车辆成交转化率高。 如果我们将A/B-test的时间拉长，如两周时长的A/B-test分别得到5000条线索量；或者说同样做一周时间的A/B-test，但是测试的比例更大，分别得到5000条线索量。即 N=5000，且线索-车辆成交转化率保持不变。计算得出$Z_{\\alpha}=1.89865812$，在同样显著性水 平下，可以拒绝原假设，得出B比A版本所带来的线索-车辆成交转化率高的结论。 上述结论是符合我们的主观感受的。在小样本量时，新版所带来的线索-车辆成交转化率高于旧版本所带来的线索-车辆成交转化率，其原因也有可能是受到随机波动等因素影响，故不能肯定地说明新版要比旧版所带来的线索-车辆成交转化率高；但在大样本量时，或者说长期来看，新版本所带来的线索-车辆成交转化率都稳定地高于旧版本所带来的线索-车辆成交转化率，我们有理由相信，确实新版本所带来的线索-车辆成交转化率高于旧版本所带来的线索-车辆成交转化率。 5. A/B-test样本量的确定由上述示例可以看出，样本量的不同对于最终结果是有很大影响的。所以在进行抽样之 前的很重要一步是确定样本量；在实践中，样本量是应该在正式抽样进行A/B-test之前便确认的。放到这里讲的原因是为了通过上述示例加深我们对样本量重要性的认识。 实践中，我们对于样本量的确认，可以根据标准误（或者说我们需要检验的差异变化） 来求出，记标准误为$d$：$$d = Z_{\\alpha} \\times \\hat{\\sigma} \\tag{1.5}$$ 其中$Z_{\\alpha}$是在显著性水平$\\alpha$下的临界值；$\\hat{\\sigma}$是由样本估计出的总体标准差。 显然，在给定显著性水平$\\alpha$、需要检验的差异变化$d$和A版本（参考版本，旧版本）的线索-车辆成交转化率$\\hat{P}_a$历史值（或经验值，或小样本预实验后得出的值[8]）后，即可推导得出我们进行A/B-test所需的样本量。 $$N = \\frac{Z_{\\alpha}^2}{d^2}(\\hat{P}_a(1-\\hat{P}_a) + \\hat{P}_b(1-\\hat{P}_b)) \\tag{1.6}$$ 6. 指标推广上文说明的是根据A/B-test进行新、旧版线索-车辆成交转化率的显著性检验。同理，如果需要根据A/B-test进行新、旧版本的UV-线索转化率、UV-上架转化率或者线索-上架转化率等的显著性检验，只需相应修改显著性检验过程中的观测指标($\\hat{P}_a, \\hat{P}_b$)即可。","link":"/2019/05/28/ab-test/"},{"title":"AIC和BIC相关知识","text":"同步于CSDN;音尘杂记 前面在回顾sklearn时，在广义线性模型中看到选择模型时可以采用AIC和BIC准则，特地复习了下统计学基础，简记如下，以抛砖引玉。 1. 模型拟合优度检验最基础的一个模型拟合优度的检验量就是R square(方程的确定系数)。已知一组样本观测值 $(X_i, Y_i)$,其中 i=1,2,3,…,n 得到如下样本回归方程： \\hat{Y_i} = \\hat{\\beta_0} + \\hat{\\beta_1}X_i而Y的第i个观测值与样本均值的离差 $y_i = Y_i - \\bar{Y}$，其可以分解为两部分之和： y_i = Y_i - \\bar{Y} = (Y_i - \\hat{Y_i}) + (\\hat{Y_i} - \\bar{Y}) = e_i + \\hat{y_i}其中 $\\hat{y_i} = (\\hat{Y_i} - \\bar{Y})$是样本拟合值与观测值的平均值之差，可认为是由回归直线解释的部分，通常称之为”离差”； $e_i = (Y_i - \\hat{Y_i})$是实际观测值与回归拟合值之差，是回归直线不能解释的部分，通常称之为”残差”。 如果 $Y_i = \\hat{Y_i}$,即实际观测值落在样本回归”线”上，则拟合最好。 对于所有样本点，可以证明： \\sum{y_i}^2 = \\sum{\\hat{y_i}^2} + \\sum{e_i^2} + 2\\sum{\\hat{y_i}^2e_i} = \\sum{\\hat{y_i}^2} + \\sum{e_i^2}记:$TSS = \\sum{y_i^2} = \\sum{(Y_i - \\bar{Y})^2}$为总体平方和(Total Sum of Squares)$ESS = \\sum{\\hat{y_i}^2} = \\sum{(\\hat{Y_i} - \\bar{Y})^2}$为回归平方和(Explained Sum of Squares, 注意有的教材又称之为Regression Sum of Squares)$RSS = \\sum{e_i^2} = \\sum{(Y_i - \\hat{Y_i})^2}$为残差平方和(Residual Sum of Squares, 注意有的教材又称之为Error Sum of Squares) TSS = ESS + RSS所以Y的观测值围绕其均值的总离差(total variation)可分解为两部分：一部分来自回归线(ESS)，另一部分则来自与随机误差(RSS) 在给定样本中，TSS不变，如果实际观测点离样本回归线越近，则ESS在TSS中占的比重越大，因此定义拟合优度：回归平方和ESS与TSS的比值。 记 $R^2 = \\frac{ESS}{TSS} = 1 - \\frac{RSS}{TSS}$，称 $R^2$为(样本)可决系数/判定系数 对于回归方程来说，$R^2$有以下几个意义： R square可以作为选择不同模型的标准。在拟合数据之前，不能确定数据的确定模型关系，可以对变量的不同数学形式进行拟合，再看R square的大小。 在数据的关系存在非线性可能情况下：a) R squared越大不一定拟合越好；b) 如何一个模型的R square很小，不一定代表数据之间没有关系，而很有可能是选择的模型不对，或者存在有其他的函数关系。 当自变量个数增加时，尽管有的自变量与的线性关系不显著，其R square也会增大，对于这种情况需采用Adjusted R squared进行调整。 2. 调整R square由于在模型中增加变量时，$R^2$没有下降，所以存在一种过度拟合模型的内在趋势，即向模型中增加变量固然可以改善数据拟合程度，但这样也会导致预测的方差正大，这时就需要用到调整 $R^2$。 \\bar{R_2} = 1 - \\frac{n-1}{n-k}(1-R^2)调整$R^2$用作拟合优度的度量，它能够适当消除在模型中增加变量所导致的自由度损失。 调整 $R^2$对模型扩张时自由度的损失进行了弥补，但又存在一个问题，随着样本容量的增大，这种弥补是否足以保证该准则肯定能让分析者得到正确的模型，所以提出了另外两个拟合度量指标，一个是赤池信息准则(Akaike Information Criterion, AIC)，另一个是施瓦茨或贝叶斯信息准则(Bayesian Information Criterion,BIC)。 3. AIC和BIC AIC(K) = s_y^2(1-R^2)e^{2k/n} BIC(K) = s_y^2(1-R^2)n^{k/n}$s_y^2$中没有对自由度进行修正，虽然随着$R^2$的提高，这两个指标都有所改善(下降),但在其他条件不变的情况下，模型规模扩大又会使这两个指标恶化。与$\\bar{R^2}$一样，实现同样的拟合程度，这些指标在平均每次观测使用参数个数(K/n)较少时更有效。使用对数通常更方便，多数统计软件报告度量指标是： AIC(K) = ln(\\frac{e^{\\prime}e}{n}) + \\frac{2K}{n} BIC(K) = ln(\\frac{e^{\\prime}e}{n}) + \\frac{Kln{n}}{n}更一般地： AIC(K) = 2K - 2ln(L)其中k是模型参数个数，L为似然函数。从一组可供选择的模型中选择最佳模型时，通常选择AIC最小的模型。 当两个模型之间存在较大差异时，差异主要体现在似然函数项，当似然函数差异不显著时，上市第一项，即模型复杂度则起作用，从而参数个数少的模型是较好的选择。 一般而言，当模型复杂度提高(k增大)时，似然函数L也会增大，从而使AIC变小，但是k过大时，似然函数增速减缓，导致AIC增大，模型过于复杂容易造成过拟合现象。目标是选取AIC最小的模型，AIC不仅要提高模型拟合度(极大似然)，而且引入了惩罚项，使模型参数尽可能少，有助于降低过拟合的可能性。 BIC(K) = Kln{n} - 2ln(L)其中k是模型参数个数，n为样本数量，L为似然函数。与AIC类似地，引入了模型参数个数作为惩罚项，但是BIC的惩罚项比AIC的大，考虑了样本数量，样本数量过多时，可有效防止模型精度过高造成的模型复杂度过高；其中 $kln{n}$惩罚项在维度过大且训练样本数据相对较少的情况下，可以有效避免出现维度灾难现象。","link":"/2019/05/29/aic-and-bic/"},{"title":"微积分1-导数","text":"同步于CSDN;音尘杂记 微积分1，主要回顾关于微积分中关于导数的相关知识。纰漏之处，还望诸君不吝指教。 1. 导数基础导数（Derivative） 是微积分学中重要的基础概念。对于定义域和值域都是实数域的函数 $f : \\mathbb{R} \\to \\mathbb{R}$，若$f(x)$在点$x_0$的某个邻域$\\triangle x$内，极限定义如下 f'(x_0) = \\lim_{\\triangle x \\to 0} \\frac{f(x_0 + \\triangle x) − f(x_0)}{\\triangle x} \\tag{1.1}若极限存在，则称函数$f(x)$在点$x_0$处可导，$f′(x_0)$称为其导数，或导函数，也可以记为$\\frac{df(x_0)}{dx}$。在几何上，导数可以看做函数曲线上的切线斜率。 给定一个连续函数，计算其导数的过程称为微分（Differentiation）。微分的逆过程为积分（Integration）。函数$f(x)$的积分可以写为 F(x) = \\int f(x)dx \\tag{1.2}其中$F(x)$称为$f(x)$的原函数。 若函数$f(x)$在其定义域包含的某区间内每一个点都可导，那么也可以说函数$f(x)$在这个区间内可导。如果一个函数$f(x)$在定义域中的所有点都存在导数，则$f(x)$为可微函数（Differentiable Function）。可微函数一定连续，但连续函数不一定可微。例如函数$|x|$为连续函数，但在点x = 0处不可导。下表是几个常见函数的导数： 函数 函数形式 导数 常数函数 $f(x) = C$，其中C为常数 $f’(x) = 0$ 幂函数 $f(x) = x^r$， 其中r是非零实数 $f’(x) = rx^{r-1}$ 指数函数 $f(x) = exp(x)$ $f’(x) = exp(x)$ 对数函数 $f(x) = log_ax$ $f’(x) = \\frac{1}{xlna}$ 高阶导数 对一个函数的导数继续求导，可以得到高阶导数。函数$f(x)$的导数$f′(x)$称为一阶导数，$f′(x)$的导数称为二阶导数，记为$f′′(x)$或$\\frac{d^2f(x)}{dx^2}$。 偏导数 对于一个多元变量函数$f : \\mathbb{R}^d \\to \\mathbb{R}$，它的偏导数（Partial Derivative ）是关于其中一个变量$x_i$的导数，而保持其他变量固定，可以记为$f’_{x_i} (x)，\\bigtriangledown_{x_i}f(x)，\\frac{∂f(x)}{∂x_i}或\\frac{∂}{∂x_i}f(x)$。 2. 矩阵微积分为了书写简便，我们通常把单个函数对多个变量 或者 多元函数对单个变量的偏导数写成向量和矩阵的形式，使其可以被当成一个整体被处理。矩阵微积分（Matrix Calculus）是多元微积分的一种表达方式，即使用矩阵和向量来表示因变量每个成分关于自变量每个成分的偏导数。 矩阵微积分的表示通常有两种符号约定：分子布局（Numerator Layout）和分母布局（Denominator Layout）。两者的区别是一个标量关于一个向量的导数是写成列向量还是行向量。 2.1 标量关于向量的偏导数对于一个$d$维向量$x \\in \\mathbb{R}^p$，函数$y = f(x) = f(x_1, … , x_p) \\in \\mathbb{R}$，则$y$关于$x$的偏导数为 分母布局 : \\frac{\\partial y}{\\partial x} = [\\frac{\\partial y}{\\partial x_1}, ..., \\frac{\\partial y}{\\partial x_p}]^T \\qquad \\in \\mathbb{R}^{p \\times 1} \\tag{1.3}分子布局： \\frac{\\partial y}{\\partial x} = [\\frac{\\partial y}{\\partial x_1}, ..., \\frac{\\partial y}{\\partial x_p}] \\qquad \\in \\mathbb{R}^{1 \\times p} \\tag{1.4}在分母布局中，$\\frac{∂y}{∂x}$为列向量，而在分子布局中， $\\frac{∂y}{∂x}$为行向量。下文如无特殊说明，均采用分母布局。 2.2 向量关于标量的偏导数对于一个标量$x \\in \\mathbb{R}$，函数$y = f(x) \\in \\mathbb{R}^q，则$y$关于$x$的偏导数为 分母布局： \\frac{\\partial y}{\\partial x} = [\\frac{\\partial y_1}{\\partial x}, ..., \\frac{\\partial y_q}{\\partial x}] \\qquad \\in \\mathbb{R}^{1 \\times q} \\tag{1.5}分子布局： \\frac{\\partial y}{\\partial x} = [\\frac{\\partial y_1}{\\partial x}, ..., \\frac{\\partial y_q}{\\partial x}]^T \\qquad \\in \\mathbb{R}^{q \\times 1} \\tag{1.6}在分母布局中，$\\frac{∂y}{∂x}$为行向量，而在分子布局中， $\\frac{∂y}{∂x}$为列向量。 2.3 向量关于向量的偏导数对于一个$d$维向量$x \\in \\mathbb{R}^p$，函数$y = f(x) \\in \\mathbb{R}^q$ 的值也为一个向量，则$f(x)$关于$x$的偏导数（分母布局）为 \\frac{\\partial f(x)}{\\partial x} = \\begin {bmatrix} &\\frac{\\partial y_1}{\\partial x_1}& &...& &\\frac{\\partial y_q}{\\partial x_1}& \\\\ &\\vdots& &\\vdots& &\\vdots& \\\\ &\\frac{\\partial y_1}{\\partial x_p}& &...& &\\frac{\\partial y_q}{\\partial x_p}& \\\\ \\end {bmatrix} \\in \\mathbb{R}^{p \\times q} \\tag{1.7}称之为雅克比矩阵（Jacobian Matrix）。 3. 导数法则复合函数的导数的计算可以通过以下法则来简化。 3.1 加(减)法则若$x \\in \\mathbb{R}^p，y = f(x) \\in \\mathbb{R}^q，z = g(x) \\in \\mathbb{R}^q$，则 \\frac{\\partial(y+z)}{\\partial x} = \\frac{\\partial y}{\\partial x} + \\frac{\\partial z}{\\partial x} \\in \\mathbb{R}^{p×q} \\tag{1.8}3.2 乘法法则(1) 若$x \\in \\mathbb{R}^p，y = f(x) \\in \\mathbb{R}^q，z = g(x) \\in \\mathbb{R}^q$，则 \\frac{∂y^Tz}{∂x} = \\frac{∂y}{∂x}z + \\frac{∂z}{∂x}y \\in \\mathbb{R}^p \\tag{1.9}(2) 若$x \\in \\mathbb{R}^p，y = f(x) \\in \\mathbb{R}^s，z = g(x) \\in \\mathbb{R}^t，A \\in \\mathbb{R}^{s×t}$ 和 $x$ 无关，则 \\frac{∂y^TAz}{∂x} = \\frac{∂y}{∂x}Az + \\frac{∂z}{∂x}A^Ty \\in \\mathbb{R}^p \\tag{1.10}(3) 若$x \\in \\mathbb{R}^p，y = f(x) \\in \\mathbb{R}，z = g(x) \\in \\mathbb{R}^q$，则 \\frac{∂yz}{∂x} = y\\frac{∂z}{∂x} + \\frac{∂y}{∂x}z^T \\in \\mathbb{R}^{p×q} \\tag{1.11}3.3 链式法则链式法则（Chain Rule）是在微积分中求复合函数导数的一种常用方法。 (1) 若$x \\in \\mathbb{R}，u = u(x) \\in \\mathbb{R}^s，g = g(u) \\in \\mathbb{R}^t$，则 \\frac{∂g}{∂x} = \\frac{∂u}{∂x}\\frac{∂g}{∂u} \\in \\mathbb{R}^{1×t} \\tag{1.12}(2) 若$x \\in \\mathbb{R}^p，y = g(x) \\in \\mathbb{R}^s，z = f(y) \\in \\mathbb{R}^t$，则 \\frac{∂z}{∂x} = \\frac{∂y}{∂x}\\frac{∂z}{∂y} \\in \\mathbb{R}^{p×t} \\tag{1.13}(3) 若$X \\in \\mathbb{R}^{p×q}$为矩阵，$y = g(X) \\in \\mathbb{R}^s，z = f(y) \\in \\mathbb{R}$，则 \\frac{∂z}{∂X_{ij}} = \\frac{∂y}{∂X_{ij}}\\frac{∂z}{∂y} \\in \\mathbb{R} \\tag{1.14}主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/12/calculus-1/"},{"title":"深广度搜索手写实现与networkx对比","text":"同步于CSDN;音尘杂记 前面项目在做一个遍历搜索的时候，有用到深度/广度搜索的相关知识；原理很简单，不再拾人牙慧了；这篇文章主要是将我自己简单实现的深广度搜索分享出来并与Python networkx模块中的已有实现做一个简单对比。 1. 手写实现1.1 网络的定义这一步最主要的属性是node_neighbors， 理解成与一个节点(node)有连接边(edge)的所有nodes。 123456789101112131415161718192021222324252627282930313233class Graph(object): &quot;&quot;&quot; 实现一个最基础的网络结构 &quot;&quot;&quot; def __init__(self, *args, **kwargs): self.node_neighbors = {} # 邻居节点 self.visited = {} def add_node(self, node): if node not in self.nodes(): self.node_neighbors[node] = [] def add_nodes(self, nodelist): for node in nodelist: self.add_node(node) def add_edge(self, edge): u, v = edge if (v not in self.node_neighbors[u]) and (u not in self.node_neighbors[v]): self.node_neighbors[u].append(v) if u != v: self.node_neighbors[v].append(u) def add_node_neighbors(self, node_neighbors): for k, v in node_neighbors.items(): self.add_node(k) for l in v: self.add_node(l) self.add_edge((k, l)) def nodes(self): return self.node_neighbors.keys() 1.2 深度优先搜索12345678910111213141516def depth_first_search(self, root=None): order = [] def dfs(node_now): self.visited[node_now] = True order.append(node_now) for n in self.node_neighbors[node_now]: if n not in self.visited: dfs(n) if root: dfs(root) for node in self.nodes(): if node not in self.visited: dfs(node) return order 输出深度优先搜索的结果：[0, 1, 3, 4, 2, 5, 6] 1234567if __name__ == &quot;__main__&quot;: # 手写实现 node_edges = {0: [1, 2], 1: [3, 4], 2: [5, 6]} root = 0 g = Graph() g.add_node_neighbors(node_edges) print(g.depth_first_search(root)) 1.3 广度优先搜索1234567891011121314151617181920212223242526def breadth_first_search(self, root=None): queue = [] order = [] def bfs(): while len(queue) &gt; 0: node_now = queue.pop(0) self.visited[node_now] = True if node_now not in self.node_neighbors: continue # 遍历其所有邻居节点(包含父节点和子节点) for n in self.node_neighbors[node_now]: if (n not in self.visited) and (n not in queue): queue.append(n) order.append(n) if root: queue.append(root) order.append(root) bfs() for node in self.nodes(): if node not in self.visited: queue.append(node) order.append(node) bfs() return order 输出广度优先搜索的结果：[0, 1, 2, 3, 4, 5, 6] 1234567if __name__ == &quot;__main__&quot;: # 手写实现 node_edges = {0: [1, 2], 1: [3, 4], 2: [5, 6]} root = 0 g = Graph() g.add_node_neighbors(node_edges) print(g.breadth_first_search(root)) 2. networkx模块实现12345678910111213141516171819202122232425def bd_first_search(node_edges, mode, root): # 建立无向有序图 g = nx.OrderedGraph() for k, v in node_edges.items(): for l in v: g.add_edge(k, l) # BDFS edges_list = None if mode == 'breadth': edges_list = list(nx.traversal.bfs_edges(g, root)) elif mode == 'depth': edges_list = list(nx.traversal.dfs_edges(g, root)) else: raise Exception(&quot;please input mode correctly!&quot;) # 整理结果 nodes_list = None nodes_list = list(edges_list[0]) for k, v in edges_list[1:]: # 可以不判断k值，定在nodes_list中 if v not in nodes_list: nodes_list.append(v) return nodes_list 2.1 输出深广度搜索结果同手写结果是一样的。 12print(bd_first_search(node_edges, 'depth', root)) # [0, 1, 3, 4, 2, 5, 6]print(bd_first_search(node_edges, 'breadth', root)) # [0, 1, 2, 3, 4, 5, 6] 3. 搜索效率对比为了评估自己的手写实现和Python自带模块networkx的搜索效率，简单用Jupyter的Magic Commands %%timeit做评估。 首先，构建一个随机化一颗树： 123456789import randomimport numpy as nprandom.seed = 2019node_edges = dict(zip(np.random.randint(1, 1000, 100), [0] * 100))root = list(node_edges.keys())[0]for k in node_edges: node_edges[k] = np.random.randint(1, 1000, random.randint(1, 100)) 3.1 深度优先搜索对比结果12345%%timeit# 法一：手写实现g = Graph()g.add_node_neighbors(node_edges)result1 = g.depth_first_search(root) 手写实现的结果是：7.08 ms ± 11.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 123%%timeit# 法二：networkxresult2 = bd_first_search(node_edges, 'depth', root) 用networkx实现的结果是：15 ms ± 63 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 3.2 广度优先搜索对比结果12345%%timeit -n 100# 法一：手写实现g = Graph()g.add_node_neighbors(node_edges)result1 = g.breadth_first_search(root) 手写实现的结果是：24.2 ms ± 61.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 123%%timeit -n 100# 法二：networkxresult2 = bd_first_search(node_edges, 'depth', root) 用networkx实现的结果是：14 ms ± 129 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 从上面的对比结果可以看出几个问题： 手写实现的深/广度优先搜索，其耗时有较大差异，BFS的耗时是DFS的3倍以上； networkx模块的深/广度优先搜索的效率相差不大； 当采用DFS时：手写实现较networkx的要快，耗时大概是其1/2；当采用BFS时：手写实现较networkx的要慢，耗时大概是其2倍；","link":"/2019/07/14/breadth-depth-first-search/"},{"title":"微积分2-常见函数的导数","text":"同步于CSDN;音尘杂记 在微积分1中已经附上了一个常见函数形式的导数，下文主要是关于向量函数及其导数，以及在机器学习和神经网络中常见的 Logistic 函数、Softmax 函数的导数形式。 1. 向量函数及其导数 \\begin{eqnarray} \\frac{\\partial x}{\\partial x} &=& I \\tag{1.1} \\\\ \\frac{\\partial Ax}{\\partial x} &=& A^T \\tag{1.2} \\\\ \\frac{\\partial x^TA}{\\partial x} &=& A \\tag{1.3} \\end{eqnarray}2. 按位计算的向量函数及其导数假设一个函数$f(x)$的输入是标量$x$。对于一组$K$个标量 $x_1, … , x_K$，我们可以通过$f(x)$得到另外一组$K$个标量$z_1, … , z_K$， z_k = f(x_k), ∀k = 1, ... ,K \\tag{1.4}为了简便起见，我们定义$x = [x_1, … , x_K]^T，z = [z_1, … , z_K]^T$， z = f(x) \\tag{1.5}其中$f(x)$是按位运算的，即$[f(x)]_i = f(x_i)$。 当$x$为标量时，$f(x)$的导数记为$f′(x)$。当输入为$K$维向量$x = [x_1, … , x_K]^T$时，其导数为一个对角矩阵。 \\begin{eqnarray} \\frac{\\partial f(x)}{\\partial x} &=& [\\frac{\\partial f(x_j)}{\\partial x_i}]_{K \\times K} \\\\ &=& \\begin {bmatrix} &f'(x_1)& \\quad &0& \\quad &...& \\quad &0& \\\\ &0& \\quad &f'(x_2)& \\quad &...& \\quad &0& \\\\ &\\vdots& \\quad &\\vdots& \\quad &\\vdots& \\quad &\\vdots& \\quad \\\\ &0& \\quad &0& \\quad &...& \\quad &f'(x_K)& \\\\ \\end {bmatrix} \\\\ &=& diag(f'(x)) \\end{eqnarray} \\tag{1.6}3. Logistic函数的导数关于logistic函数其实在博文‘Logistic loss函数’中已经有所介绍，接下来要说是更广义的logistic函数的定义： logistic(x) = \\frac{L}{1 + exp(−k(x − x_0))} \\tag{1.7}其中，$x_0$是中心点，$L$是最大值，$k$是曲线的倾斜度。下图给出了几种不同参数的Logistic函数曲线。当$x$趋向于$−\\infty$时，logistic(x)接近于0；当$x$趋向于$+\\infty$时，logistic(x) 接近于$L$。 当参数为($k = 1, x_0 = 0, L = 1$) 时，Logistic 函数称为标准Logistic 函数，记为f(x)。 f(x) = \\frac{1}{1 + exp(−x)} \\tag{1.8}标准logistic函数有两个重要的性质如下： \\begin{eqnarray} f(x) &=& 1 - f(x) \\tag{1.9} \\\\ f'(x) &=& f(x)(1 - f(x)) \\tag{1.10} \\end{eqnarray}当输入为$K$维向量$x=[x_1, …, x_K]^T$时，其导数为： f'(x) = diag(f(x) \\odot (1 − f(x))) \\tag{1.11}4. Softmax函数的导数Softmax函数是将多个标量映射为一个概率分布。对于$K$个标量$x_1, … , x_K$，softmax 函数定义为 z_k = softmax(x_k) = \\frac{exp(x_k)}{\\sum_{i=1}^{K}exp(x_i)} \\tag{1.12}这样，我们可以将$K$个变量$x_1, … , x_K$转换为一个分布：$z_1, … , z_K$，满足 z_k \\in [0, 1], ∀k, \\quad \\sum_{k=1}^{K}z_k = 1 \\tag{1.13}当Softmax函数的输入为$K$维向量$x$时， \\begin{eqnarray} \\hat{z} &=& softmax(x) \\\\ &=& \\frac{1}{\\sum_{k=1}^{K}exp(x_k)}\\begin{bmatrix} exp(x_1) \\\\ \\vdots \\\\ exp(x_K) \\\\ \\end{bmatrix} \\\\ &=& \\frac{exp(x)}{\\sum_{k=1}^{K}exp(x)} \\\\ &=& \\frac{exp(x)}{1_K^Texp(x)} \\\\ \\end{eqnarray} \\tag{1.14}其中 $1_K = [1, … , 1]_{K×1}$是$K$维的全1向量。 Softmax函数的导数为 \\begin{eqnarray} \\frac{\\partial softmax(x)}{\\partial x} &=& \\frac{\\partial(\\frac{exp(x)}{1_K^Texp(x)})}{\\partial x} \\tag{1.15} \\\\ &=& \\frac{1}{1_K^Texp(x)}\\frac{\\partial exp(x)}{\\partial(x)} + \\frac{\\partial(\\frac{1}{1_K^Texp(x)})}{\\partial x}(exp(x))^T \\tag{1.16} \\\\ &=& \\frac{diag(exp(x))}{1_K^Texp(x)} - (\\frac{1}{(1_K^Texp(x))^2})\\frac{\\partial(1_K^Texp(x))}{\\partial x}(exp(x))^T \\tag{1.17} \\\\ &=& \\frac{diag(exp(x))}{1_K^Texp(x)} - (\\frac{1}{(1_K^Texp(x))^2})diag(exp(x))1_K(exp(x))^T \\tag{1.18} \\\\ &=& \\frac{diag(exp(x))}{1_K^Texp(x)} - (\\frac{1}{(1_K^Texp(x))^2})exp(x)(exp(x))^T \\tag{1.19} \\\\ &=& diag(\\frac{exp(x)}{1_K^Texp(x)}) - \\frac{exp(x)}{1_K^Texp(x)}.\\frac{(exp(x))^T}{1_K^Texp(x)} \\tag{1.20} \\\\ &=& diag(softmax(x)) - softmax(x).softmax(x)^T \\tag{1.21} \\end{eqnarray}其中式(1.16)请参考 ‘微积分1-导数’ 式(1.13)。 主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/12/calculus-2/"},{"title":"【Graph Embedding】DeepWalk","text":"关于Graph Embedding系列的论文翻译解读文章： 【Graph Embedding】DeepWalk 【Graph Embedding】line 【Graph Embedding】node2Vec 【Graph Embedding】SDNE 【Graph Embedding】struc2vec 参考资料 paper: http://www.perozzi.net/publications/14_kdd_deepwalk.pdf code: https://github.com/phanein/deepwalk 1. 介绍 DeepWalk将图作为输入，将生成的潜在表示(embedding 向量)作为输出。应用DeepWalk的结果深入研究空手道网络的方法如图1。该图的布局表示（1a）。图1b显示了用DeepWalk后在两个潜在维度的输出。可以看到(1b)的线性可分部分对应原图中发现的集群(以顶点颜色显示)。另外文章在多标签预测上评估了其性能。 在创造社交维度方面，DeepWalk的表现优于其他潜在的表现方法[39，41]，尤其是当标记的节点很少。 使用非常简单的线性分类器的表现非常出色（如LR）。文章中提到主要的贡献如下： 我们引入深度学习作为分析图形的工具，以构建适合于统计建模的健壮表示。DeepWalk学习短随机游走中出现的结构规律。 我们广泛地评估了我们在几个社交网络上的多标签分类任务的表现。我们发现，在标签稀疏性存在的情况下，分类性能显著提高，Micro-F1指标提高5%-10%，我们考虑的最稀疏的问题。在某些情况下，即使训练数据减少60%，DeepWalk的表现也能超越竞争对手。 我们通过构建web级图的表示来演示我们的算法的可伸缩性和并行实现。 2. 问题定义考虑将社交网络成员划分为一个或多个类别的分类问题。定义$G=(V,E)$，$V$是网络节点的集合，$E$是节点之间的边的集合。$E \\subseteq (V \\times V)$。给定一个有标签的社交网络$G_L=(V,E,X,Y)$,它有属性$X \\in \\Bbb R^{|V| \\times S}$，其中$S$是每个属性的特征空间大小，$Y \\in \\Bbb R^{|V| \\times \\cal Y}$是标签的集合。 在传统的机器学习分类任务中，需要学习一个假设$H$（根据特征训练一个分类器），使它可以把$X$映射到$Y$集合中。现在，可以利用图$G$结构的embedding获得有意义的信息，进而获得更好的表现(其实就是根据图结构对每个顶点得到一个embedding向量，后续以此作为特征训练一个分类器)。 在文献中，这被称为关系分类。传统的方法把这个问题看作无向马尔可夫网络的推理问题，并且在给定网络结构的情况下，运用迭代近似推理算法计算标签的后验分布。 DeepWalk提出一种不同的方法去获取网络的拓扑信息。而不是混合标签空间作为特征空间的一部分，我们提出一种无监督的方法可以得到具有捕捉网络结构能力的特征，并且它们与标签的分布是相关独立的。 目标是学习$X_E \\in \\Bbb R^{|V| \\times d}$，这里的$d$是潜在维数。使用这些结构化的属性，我们就可以扩充特征空间，帮助进行分类决策。这些特征是通用的，可以用作任何分类算法（包括迭代算法）。因此，这些特征的最大好处就是易与简单的机器学习算法整合起来。 3. 学习社交表示文章试图学习具有以下特征的社会表征: 适应性 — 真实的社交网络是不断进化的;新的社会关系不应该要求重新学习过程。 社区感知 — 潜在维度之间的距离应该代表一个度量标准，用于评估网络中相应成员之间的社会相似性。这使得具有同质性的网络可以泛化。 低维 — 当标记数据不足时，低维模型能更好地推广，并加速收敛和推理。 连续 — 我们需要潜在的表现来在连续空间中模拟部分社区成员。除了提供社区成员的细致视图外，一个连续的表示在社区之间有平滑的决策边界，这允许更健壮的分类。 根据短随机游走学习到顶点的表示，使用最初为语言建模设计的优化技术来满足这些要求。在这里，需要回顾下随机游走和语言建模的基础知识。 3.1 随机游走定义随机游走的根节点$v_i$为$\\cal W_{v_i}$。它是一个由$\\cal W^1_{v_i},\\cal W^2_{v_i},…,\\cal W^k_{v_i}$组成的随机过程，$\\cal W^{k+1}_{v_i}$是被随机选出的节点$v_k$的邻居。随机游走作为一种相似度度量的方式应用于内容推荐和社区发现。正是这种与本地结构的连接促使我们使用短随机游动流作为从网络中提取信息的基本工具。使用随机游走不仅可以获取社区信息，还有两个理想特性。首先，局部探索很容易并行化。可以同时探索同一图的不同部分。其次，依靠短随机游走获得的信息，可以适应图结构的微小变化，而不需要全局重新计算。我们可以用新的随机游走来迭代地更新所学习的模型，这对比更新整个图来说是次线性的。 3.2 连接：幂律 在选择在线随机游走作为我们主要捕捉图结构的方法之后，我们现在需要一个合适的方法去捕捉这些信息。如果一个连接图的度分布服从幂律定律，我们观测得到节点在短随机游走出现的频率也会服从幂律分布。过去用于自然语言建模的方法（符号频率服从幂律分布）也可以用于网络的社区结构建模。 3.3 语言建模语言建模的目标是估计一串特殊的词出现在全集的可能性。正式地说，给定一串词$W^n_1=(w_0,w_1,…,w_n)$，其中$w_i \\in \\cal V$($\\cal V$是词汇表)，我们要在所有训练的集合中求出$Pr(w_n|w_0,w_1,…,w_{n-1})$的最大值（条件概率）。 在DeepWalk中，通过短随机游走探索图，这展示了一种语言建模的一般化。这种直接的类比是在给定随机游走之前访问过的节点情况下，估计下一次要访问节点$v_i$的可能性。 Pr(v_i|(v_1,v_2,...,v_{i-1})) \\tag{1}目标是学习顶点的一种潜在表示，而不是一个节点再现的概率分布，引入一个映射函数$\\Phi:v \\in V \\to \\Bbb R^{|V| \\times d}$。这个映射函数$\\Phi$表示图中每个节点$V$之间的潜在表示。然后这个问题就变成估计以下可能性： Pr(v_i|(\\Phi(v_1),\\Phi(v_2),...,\\Phi(v_{i-1}))) \\tag{2}然而，随着游走的距离增大，计算这个目标函数变得不是那么容易。 最近的一些工作[27,28]提出，可以不用上下文去预测缺失的单词，而是用单词去预测它的上下文。其次，这里的上下文同时包括该单词的右边的词汇和左边的词汇。最后，它去除了这个问题的顺序约束。取而代之的是，这个模型需要最大化上下文出现的各个单词的概率，而无需知道其偏离给定单词的知识。在节点表示建模方面，这产生了如下优化问题： \\underset{\\Phi}{minimize} \\quad -logPr(\\lbrace v_{i-w},...,v_{i-1},v_{i+1},...,v_{i+w} \\rbrace | \\Phi(v_i)) \\tag{3}这在社交表示学习上尤其可取。首先，顺序独立假设很好地获取了随机游走所提供的“接近”。另外，可以在某个时间给出一个节点的情况下，通过构建更小的模型加速训练时间。 通过结合缩短的随机游走和神经语言模型。可以生成社交网络的低维表示，并且在向量空间连续。它表示了社区成员的潜在形式，并且由于这种方法输出有用的中间表示，它可以适应变化的网络拓扑。 4. 方法4.1 概况在其他所有语言建模算法中，需要的输入仅为一个全集和一个词汇表$\\cal V$。DeepWalk把随机游走作为自己的全集，图的节点作为自己的词汇表$(\\cal V$ = $V)$。最好在训练之前知道随机游走的$V$和节点的频率分布，不过这不是必须要的。 4.2 算法： DeepWalk算法主要包括两个主要成分；第一是随机游走生成器，第二是更新程序。随机游走生成器把图$G$作为输入，随机挑选一个节点$v_i$作为随机游走$\\cal W_{v_i}$的根节点。每一步需要从上一个节点的邻居节点中随机挑选一个作为当前节点，直到达到最大长度$t$。在实验中我们把这个长度固定，但是并没有规定$t$必须取某个相同的值。这些游走可能重新回到起点，但是我们之前的结果并没有显示重新开始的任何优势。在实践过程中，我们在每个节点进行了$\\gamma$次长度为$t$的随机游走。 算法1中的3-9行显示了我们方法的核心。外循环指定次数$\\gamma$，我们应该在哪个点开始随机游走。 我们认为每次迭代都是对数据进行一次“传递”，并在此传递过程中对每个节点进行一次抽样。在每次遍历的开始，我们都会生成一个随机的遍历顶点的顺序。这不是严格要求，但对随机梯度下降可以加快收敛。 在内部循环中，遍历图上的所有顶点。对于每个顶点$v_i$，我们生成一个随机游走$|\\cal W_{v_i}| = t$，然后用它来更新表示。我们根据目标函数，使用Skip-Gram算法进行表示的更新。 4.2.1 SkipGram SkipGram是一种语言模型，它使出现在窗口$w$中的单词在句子中的共现概率最大化。它使用如下独立假设近似方程3中的条件概率 Pr\\left(\\{v_{i-w}, ..., v_{i+w}\\}/v_i | \\Phi(v_i) \\right) = \\prod_{j=i-w \\& j\\neq i}^{i+w}Pr(v_j | \\Phi(v_i)) \\tag{4}算法2 遍历出现在窗口$w$中的所有可能的随机游走（第1-2行）。对于每一个顶点，将每个顶点$v_j$映射到其当前表示向量$\\Phi(v_j) \\in \\Bbb R^d$（见图3b）。给定$v_j$的表示，我们想要最大化它的邻居在这条线上的概率(第3行)。例如用分类器LR对问题进行建模，将产生大量的标签(即$|V|$)，其数量可能是数百万甚至数十亿。这些模型需要大量的计算资源，这些资源可以跨越整个计算机集群[4]。为了避免这种必要性，加快训练时间，我们使用层次结构来近似概率分布。 4.2.2 分层SoftMax给定$u_k \\in V$,计算$Pr(u_k|\\Phi(v_j))$不是可取的。计算归一化因子代价很高。如果把顶点分配给二叉树的叶节点，将预测问题转化为最大化层次结构中特定路径的概率(参见图3c)。如果到顶点$u_k$的路径由一系列树节点$(b_0, b_1, …, b_{[log|V|]})$，$(b_0=root, b_{[log|V|]}=u_k)$，那么： Pr(u_k | \\Phi(v_j)) = \\prod_{l=1}^{[log|V|]}Pr(b_l | \\Phi(v_j)) \\tag{5}现在，$Pr(b_l | \\Phi(v_j))$可由分配给节点$b_l$父节点的二进制分类器建模，如式6所示， Pr(b_l | \\Phi(v_j)) = 1 / (1+e^{-\\Phi(v_j).\\Psi(b_l)}) \\tag{6}其中$\\Psi(b_l) \\in \\Bbb R^d$是分配给树节点$b_l$的父节点的表示形式。这减少了计算$Pr(u_k | \\Phi(v_j)) $的复杂性，复杂度从$O(|V|)$降低到$O(log|V|)$。 通过为随机游走中频繁出现的顶点分配较短的路径，可以进一步加快训练过程。人工编码是为了减少树中频繁元素的访问时间。 4.2.3 最优化这个模型的参数集合是$\\theta = \\lbrace \\Phi,T \\rbrace$，其大小都为$O(d|V|)$。随机梯度下降被用来优化这些参数，利用反向传播算法对导数进行估计。学习率$\\alpha$初始化为2.5%，然后随着目前发现的节点的增加线性减小。 4.3 并行性如图2，社交网络中随机游走的顶点的频率分布和语言中的单词都遵循幂律分布。这就导致了一条罕见顶点的长尾，因此，影响$\\Phi$的更新在本质上是稀疏的。在有多个worker的情况下允许使用异步版本的随机梯度下降（ASGD）。由于更新是稀疏的，因此ASGD将实现最佳收敛速度[36]。当我们在一台使用多线程的机器上运行实验时，已证明该技术具有高度的可扩展性，并且可以用于超大规模的机器学习[9]。图4展示了并行化DeepWalk的效果。它表明，随着我们将worker数量增加到8个，处理BlogCatalog和Flickr网络的速度是一致的（图4a）。它还表明，相对于串行运行DeepWalk而言，不会降低预测性能（图4b）。 4.4 算法变体4.4.1 Streaming这种方法的一个有趣的变体是流式处理处理，哪些可以在不了解整个图的情况下实现。在这种变体中，图的小遍历被直接传递给表示学习代码，并直接更新模型。 对学习过程进行一些修改也是必要的。 首先，使用衰减的学习率可能不再是可取的，因为它假定了总语料库大小的知识。反而，我们可以将学习率$\\alpha$初始化为一个小的常数值。这将需要更长的学习时间，但在某些应用程序中值得。其次，我们不一定要建立任何参数树。 如果$V$的基数已知（或可以有界），我们可以为该最大值构建分层 Softmax树。 可以将顶点分配给其余叶子之一。当他们第一次见到。 如果我们有能力预先估计顶点频率，我们还可以使用人工编码(Huffman coding)来减少频繁的元素访问时间。 4.4.2 非随机游走有些图是并非是随机游走的(例如，用户在网站上的页面导航)。当这样一个非随机游走流创建一个图时，我们可以使用这个过程来直接支持建模阶段。以这种方式采样的图不仅可以捕获与网络结构相关的信息，还可以捕获路径遍历的频率。 在我们看来，这种变体还包括语言建模。句子可以被看作是经过适当设计的语言网络的有目的的游走，而像Skip-Gram这样的语言模型就是为了捕捉这种行为而设计的。","link":"/2019/12/26/graph-embedding-deepwalk/"},{"title":"线性代数1-向量和向量空间","text":"同步于CSDN;音尘杂记 后续几篇笔记主要想回顾整理一下需要用到的数学基础知识，主要包括了线性代数、微积分、概念论、数学优化和信息论等内容。相对比较基础，权当复习回顾完善整个知识体系结构。错误之处，还望诸君不吝指教。 1. 向量标量（Scalar）是一个实数，只有大小，没有方向。而向量（Vector）是由一组实数组成的有序数组，同时具有大小和方向。例，一个n维向量a 是由n个有序实数组成，表示为： a = [a_1, a_2, ..., a_n], \\tag{1.1}其中$a_i$称为向量a的第$i$个分量，或第$i$维。向量符号通常用黑体小写字母$a, b, c$或小写希腊字母$\\alpha,\\beta, \\gamma$ 等来表示。 2. 向量空间向量空间（Vector Space），也称线性空间（Linear Space），是指由向量组成的集合，并满足以下两个条件： 向量加法：向量空间$V$中的两个向量a和b，它们的和a + b也属于空间$V$； 标量乘法：向量空间$V$中的任一向量a和任一标量$c$，它们的乘积$c · a$也属于空间$V$。 欧氏空间 一个常用的线性空间是欧氏空间（Euclidean Space）。一个欧氏空间表示通常为$\\mathbb{R}^n$，其中n为空间维度（Dimension）。欧氏空间中向量的加法和标量乘法定义为： \\begin{eqnarray} [a_1, a_2, ... , a_n] + [b_1, b_2, ... , b_n] &=& [a_1 + b_1, a_2 + b_2, ... , a_n + b_n], \\tag{1.2} \\\\ c[a_1, a_2, ... , a_n] &=& [ca_1, ca_2, ... , ca_n] \\tag{1.3} \\end{eqnarray}其中$a, b, c \\in{\\mathbb{R}}$为一个标量。 线性子空间 向量空间$V$的线性子空间$U$是$V$的一个子集，并且满足向量空间的条件（向量加法和标量乘法）。 线性无关 线性空间$V$中的一组向量${v_1, v_2, … , v_n}$，如果对任意的一组标量$\\lambda_1, \\lambda_2, … , \\lambda_n$，满足$\\lambda_1v_1 + \\lambda_2v_2 + ·… + \\lambda_nv_n = 0$，则必然$\\lambda_1 = \\lambda_2 = … =\\lambda_n = 0$，那么${v_1, v_2, … , v_n}$是线性无关的，也称为线性独立的。 基向量 向量空间$V$的基（Base）$B = {e_1, e_2, … , e_n}$ 是$V$的有限子集，其元素之间线性无关。向量空间$V$所有的向量都可以按唯一的方式表达为$B$中向量的线性组合。对任意$v \\in V$，存在一组标量$(\\lambda_1, \\lambda_2, … , \\lambda_n)$ 使得: v = \\lambda_1e_1 + \\lambda_2e_2 + ... + \\lambda_ne_n \\tag{1.4}其中基$B$中的向量称为基向量（Base Vector）。如果基向量是有序的，则标量$(\\lambda_1, \\lambda_2, … , \\lambda_n)$ 称为向量$v$关于基$B$的坐标（Coordinates）。 n维空间$V$的一组标准基（Standard Basis）为: \\begin{eqnarray} e_1 &=& [1, 0, ..., 0], \\tag{1.5} \\\\ e_2 &=& [0, 1, ..., 0], \\tag{1.6} \\\\ &...&, \\tag{1.7} \\\\ e_n &=& [0, 0, ..., 1], \\tag{1.8} \\end{eqnarray}向量空间$V$中的任一向量$v = [v_1, v_2, … , v_n]$可以唯一的表示为: [v_1, v_2, ... , v_n] = v_1e_1 + v_2e_2 + ... + v_ne_n, \\tag{1.9}其中$v_1, v_2, … , v_n$也称为向量$v$的笛卡尔坐标（Cartesian Coordinate）。向量空间中的每个向量可以看作是一个线性空间中的笛卡儿坐标。 内积** 一个n维线性空间中的两个向量$a$和$b$，其内积为: ⟨a, b⟩ = \\sum_{i=1}^{n}a_ib_i, \\tag{1.10}正交 如果向量空间中两个向量的内积为0，则它们正交（Orthogonal）。如果向量空间中一个向量$v$与子空间$U$中的每个向量都正交，那么向量$v$和子空间$U$正交。 3. 常见的向量全0向量指所有元素都为0的向量，用0表示。全0向量为笛卡尔坐标系中的原点。 全1向量指所有值为1的向量，用1表示。 one-hot向量为有且只有一个元素为1，其余元素都为0 的向量。one-hot向量是在数字电路中的一种状态编码，指对任意给定的状态，状态寄存器中只有1位为1，其余位都为0。 4. 范数范数（Norm）是一个表示向量“长度”的函数，为向量空间内的所有向量赋予非零的正长度或大小。对于一个n维向量v，一个常见的范数函数为$\\ell_p$范数 \\ell_p(v) = \\parallel v \\parallel_p = {(\\sum_{i=1}^{n}|v_i|^p)}^{1/p}, \\tag{1.11}其中$p \\geq 0$为一个标量的参数。常见的$p$的取值有1，2，$\\infty$等。 $\\ell_1$范数 ， $p = 1$ \\ell_1(v) = \\sum_{i=1}^{n}|v_i|, \\tag{1.12}$\\ell_2$范数 ， $p = 2$ \\ell_2(v) = \\sqrt{\\sum_{i=1}^{n}|v_i|^2} = \\sqrt{v^Tv}, \\tag{1.13}$\\ell_2$范数又称为Euclidean范数或者Frobenius范数。从几何角度，向量也可以表示为从原点出发的一个有向线段，其$\\ell_2$范数为线段的长度，也常称为向量的模。 $\\ell_{\\infty}$范数 ， $p = \\infty$,表示为各个元素的最大绝对值 \\ell_{\\infty}(v) = ||v||_{\\infty} = max\\{v_1,v_2, ..., v_n\\}, \\tag{1.14}主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/11/linear-algebra-1/"},{"title":"信息论2-交叉熵和散度","text":"同步于CSDN;音尘杂记 主要总结了交叉熵、KL散度、JS散度和wasserstein距离(也称推土机距离，EMD)的相关知识，其中EMD的直观表示可以参见下图： 1. 交叉熵对应分布为$p(x)$的随机变量，熵$H(p)$表示其最优编码长度。交叉熵（Cross Entropy）是按照概率分布$q$的最优编码对真实分布为$p$的信息进行编码的长度， 交叉熵定义为 H(p, q) = \\Bbb{E}_p[−log q(x)] = −\\sum_{x}p(x)logq(x) \\tag{1}在给定$p$的情况下，如果$q$和$p$越接近，交叉熵越小；如果$q$和$p$越远，交叉熵就越大。 2. KL散度KL散度（Kullback-Leibler Divergence），也叫KL距离或相对熵(Relative Entropy)，是用概率分布q来近似p时所造成的信息损失量。KL散度是按照概率分布q的最优编码对真实分布为p的信息进行编码，其平均编码长度$H(p, q)$和$p$的最优平均编码长度$H(p)$之间的差异。对于离散概率分布$p$和$q$，从$q$到$p$的KL散度定义为 D_{KL}(p∥q) = H(p,q) − H(p) = \\sum_{x}p(x)log\\frac{p(x)}{q(x)} \\tag{2}其中为了保证连续性，定义$0 log \\frac{0}{0} = 0, 0 log \\frac{0}{q} = 0$。 KL散度可以是衡量两个概率分布之间的距离。KL散度总是非负的，$D_{KL}(p∥q) ≥0$。只有当$p = q$时，$D_{KL}(p∥q) = 0$。如果两个分布越接近，KL散度越小；如果两个分布越远，KL散度就越大。但KL散度并不是一个真正的度量或距离，一是KL散度不满足距离的对称性，二是KL散度不满足距离的三角不等式性质。 3. JS散度JS散度（Jensen–Shannon Divergence）是一种对称的衡量两个分布相似度的度量方式，定义为 D_{JS}(p∥q) = \\frac{1}{2}D_{KL}(p∥m) + \\frac{1}{2}D_{KL}(q∥m) \\tag{3}其中$m = \\frac{1}{2}(p + q)$。 JS 散度是KL散度一种改进。但两种散度都存在一个问题，即如果两个分布p, q 没有重叠或者重叠非常少时，KL散度和JS 散度都很难衡量两个分布的距离。 4. Wasserstein距离Wasserstein 距离（Wasserstein Distance）也用于衡量两个分布之间的距离。对于两个分布$q_1, q_2，p^{th}-Wasserstein$距离定义为 W_p(q_1, q_2) = \\left ( \\inf_{\\gamma(x, y) \\in \\Gamma(q_1, q_2)}\\Bbb{E}_{(x,y)\\sim \\gamma(x,y)}[d(x,y)^p] \\right )^{1/p} \\tag{4}其中$Gamma(q_1, q_2)$是边际分布为$q_1$和$q_2$的所有可能的联合分布集合，$d(x, y)$为$x$和$y$的距离，比如$\\ell_p$距离等。 如果将两个分布看作是两个土堆，联合分布$\\gamma(x, y)$看作是从土堆$q_1$的位置$x$到土堆$q_2$的位置$y$的搬运土的数量，并有 \\begin{eqnarray} \\sum_{x}\\gamma(x, y) = q_2(y) \\tag{5} \\\\ \\sum_{y}\\gamma(x, y) = q_1(x) \\tag{6} \\end{eqnarray}$q_1$和$q_2$为$\\gamma(x, y)$的两个边际分布。 $\\Bbb{E}_{(x,y) \\sim \\gamma(x,y)}[d(x, y)^p]$可以理解为在联合分布$\\gamma(x, y)$下把形状为$q_1$的土堆搬运到形状为$q_2$的土堆所需的工作量， \\Bbb{E}_{(x,y) \\sim \\gamma(x,y)}[d(x, y)^p] = \\sum_{(x,y)}\\gamma(x, y)d(x, y)^p \\tag{7}其中从土堆$q_1$中的点$x$到土堆$q_2$中的点$y$的移动土的数量和距离分别为$\\gamma(x, y)$和$d(x, y)^p$。因此，Wasserstein距离可以理解为搬运土堆的最小工作量，也称为推土机距离（Earth-Mover’s Distance，EMD）。 Wasserstein距离相比KL散度和JS 散度的优势在于：即使两个分布没有重叠或者重叠非常少，Wasserstein 距离仍然能反映两个分布的远近。 对于$\\Bbb{R}^n$空间中的两个高斯分布$p = \\cal{N}(\\mu1,Σ1)$和$q = \\cal{N}(\\mu2,Σ2)$，它们的$2^{nd}-Wasserstein$距离为 D_W(p∥q) = ||μ1 − μ2||_2^2 + tr \\left ( \\begin {matrix} \\sum_1 + \\sum_2 - 2(\\sum_2^{1/2}\\sum_1\\sum_2^{1/2})^{1/2} \\end {matrix} \\right ) \\tag{8}当两个分布的的方差为0时，$2^{nd}-Wasserstein$距离等价于欧氏距离($||μ1 − μ2||_2^2$)。 4.1 EMD示例求解两个分布的EMD可以通过一个Linear Programming（LP）问题来解决，可以将这个问题表达为一个规范的问题：寻找一个向量$x \\in \\Bbb{R}$，最小化损失$z = c^Tx, c\\in \\Bbb{R}^n$，使得$Ax = b, A \\in \\Bbb{R}^{m\\times n},b \\in \\Bbb{R}^m, x \\geq 0$，显然，在求解EMD时有： x = vec(\\Gamma) \\\\ c = vec(D)其中$\\Gamma$是$q_1$和$q_2$的联合概率分布，$D$是移动距离。 首先生成两个分布$q_1$和$q_2$： 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-import numpy as npimport matplotlib.colors as colorsfrom matplotlib import pyplot as pltfrom scipy.optimize import linprogfrom matplotlib import cmfrom scipy.optimize import linprogfrom matplotlib import cml = 10q1 = np.array([13, 8, 5, 1, 21, 15, 8, 7, 5, 15])q2 = np.array([1, 6, 12, 17, 12, 10, 8, 15, 4, 2])q1 = q1 / np.sum(q1)q2 = q2 / np.sum(q2)plt.bar(range(l), q1, 1, color='blue', alpha=1, edgecolor='black')plt.axis('off')plt.ylim(0, 0.5)plt.show()plt.bar(range(l), q1, 1, color='green', alpha=1, edgecolor='black')plt.axis('off')plt.ylim(0, 0.5)plt.show() 计算其联合概率分布和距离矩阵： 123456789101112131415161718192021222324252627282930D = np.ndarray(shape=(l, l))for i in range(l): for j in range(l): D[i, j] = abs(range(l)[i] - range(l)[j])A_1 = np.zeros((l, l, l))A_2 = np.zeros((l, l, l))for i in range(l): for j in range(l): A_1[i, i, j] = 1 A_2[i, j, i] = 1A = np.concatenate((A_1.reshape((l, l**2)), A_2.reshape((l, l**2))), axis=0) # 20x100b = np.concatenate((q1, q2), axis=0) # 20x1c = D.reshape((l**2)) # 100x1opt_res = linprog(c, A_eq=A, b_eq=b, bounds=[0, None])emd = opt_res.fungamma = opt_res.x.reshape((l, l))print(&quot;EMD: &quot;, emd)# Gammaplt.imshow(gamma, cmap=cm.gist_heat, interpolation='nearest')plt.axis('off')plt.show()# Dplt.imshow(D, cmap=cm.gist_heat, interpolation='nearest')plt.axis('off')plt.show() 最终得到EMD=0.8252404410039889 4.2 利用对偶问题求解EMD事实上，4.1节说的求解方式在很多情形下是不适用的，在示例中我们只用了10个状态去描述分布，但是在很多应用中，输入的状态数很容易的就到达了上万维，甚至近似求$\\gamma$都是不可能的。 但实际上我们并不需要关注$\\gamma$，我们仅需要知道具体的EMD数值，我们必须能够计算梯度$\\nabla_{P_1}EMD(P_1, P_2)$，因为$P_1$和$P_2$仅仅是我们的约束条件，这是不可能以任何直接的方式实现的。 但是，这里有另外一个更加方便的方法去求解EMD；任何LP问题都有两种表示问题的方法：原始问题(4.1所述)和对偶问题。所以刚才的问题转化成对偶问题如下： \\begin {eqnarray} maxmize \\qquad &\\tilde{z}=b^T.y \\\\ st. \\qquad &A^T.y \\leq c \\end {eqnarray} \\tag{9}12345678opt_res = linprog(-b, A.T, c, bounds=(None, None))emd = -opt_res.funf = opt_res.x[0:l]g = opt_res.x[l:]# print(dual_result)print(&quot;dual EMD: &quot;, emd) 得到其结果：EMD=0.8252404410039867 或者另一种方式： 12emd = np.sum(np.multiply(q1, f)) + np.sum(np.multiply(q2, g))print(&quot;emd: &quot;, emd) 得到其结果，EMD=0.8252404410039877 最后，再看一下两个分布的对应转换情况： 12345678910111213# q1r = range(l)current_bottom = np.zeros(l)cNorm = colors.Normalize(vmin=0, vmax=l)colorMap = cm.ScalarMappable(norm=cNorm, cmap=cm.terrain)for i in r: plt.bar(r, gamma[r, i], 1, color=colorMap.to_rgba(r), bottom=current_bottom, edgecolor='black') current_bottom = current_bottom + gamma[r, i]plt.axis('off')plt.ylim(0, 0.5)plt.show() 12345678910# q2r = range(l)current_bottom = np.zeros(l)for i in r: plt.bar(r, gamma[i, r], 1, color=colorMap.to_rgba(i), bottom=current_bottom, edgecolor='black') current_bottom = current_bottom + gamma[i, r]plt.axis('off')plt.ylim(0, 0.5)plt.show() 主要参考: https://github.com/nndl/nndl.github.io https://vincentherrmann.github.io/blog/wasserstein/","link":"/2019/06/21/information-theory-2/"},{"title":"信息论1-熵","text":"同步于CSDN;音尘杂记 信息论（Information Theory）是数学、物理、统计、计算机科学等多个学科的交叉领域。信息论是由Claude Shannon 最早提出的，主要研究信息的量化、存储和通信等方法。这里，“信息”是指一组消息的集合。假设在一个噪声通道上发送消息，我们需要考虑如何对每一个信息进行编码、传输以及解码，使得接收者可以尽可能准确地重构出消息。 在机器学习相关领域，信息论也有着大量的应用。比如特征抽取、统计推断、自然语言处理等。 1. 自信息和熵熵（Entropy）最早是物理学的概念，用于表示一个热力学系统的无序程度。在信息论中，熵用来衡量一个随机事件的不确定性。假设对一个随机变量$X$（取值集合为$\\cal{X}$，概率分布为$p(x), x \\in \\cal{X}$）进行编码，自信息（Self Information） $I(x)$是变量$X = x$时的信息量或编码长度，定义为 I(x) = −log(p(x)) \\tag{1}那么随机变量$X$的平均编码长度，即熵定义为 H(X) = \\Bbb{E}_X[I(x)] = \\Bbb{E}_X[−log(p(x))] = −\\sum_{x \\in \\cal{X}}p(x) log p(x) \\tag{2}其中当$p(x_i) = 0$时，我们定义$0 log 0 = 0$，与极限一致，$\\lim_{p\\to 0+} p log p = 0$。 熵是一个随机变量的平均编码长度，即自信息的数学期望。熵越高，则随机变量的信息越多，熵越低；则信息越少。如果变量$X$当且仅当在$x$时$p(x) = 1$，则熵为0。也就是说，对于一个确定的信息(不确定概率为0)，其熵为0，信息量也为0。如果其概率分布为一个均匀分布，则熵最大。假设一个随机变量X 有三种可能值$x_1, x_2, x_3$，不同概率分布对应的熵如下： p(x1) p(x2) p(x3) 熵 1 0 0 0 1/2 1/4 1/4 $\\frac{3}{2}(log2)$ 1/3 1/3 1/3 log3 2. 联合熵和条件熵对于两个离散随机变量$X$和$Y$ ，假设$X$取值集合为$cal{X}$；$Y$取值集合为$\\cal{Y}$，其联合概率分布满足为$p(x, y)$， 则$X$和$Y$的联合熵（Joint Entropy）为 H(X, Y) = −\\sum_{x \\in \\cal{X}} \\sum_{y \\in \\cal{Y}}p(x, y) log p(x, y) \\tag{3}$X$和$Y$的条件熵（Conditional Entropy）为 H(X|Y) = −\\sum_{x \\in \\cal{X}} \\sum_{y \\in \\cal{Y}}p(x, y) log p(x|y) = −\\sum_{x \\in \\cal{X}} \\sum_{y \\in \\cal{Y}}p(x, y) log \\frac{p(x,y)}{p(y)} \\tag{4}根据其定义，条件熵也可以写为 H(X|Y) = H(X, Y) − H(Y) \\tag{5}3. 互信息互信息（Mutual Information）是衡量已知一个变量时，另一个变量不确定性的减少程度。两个离散随机变量X 和Y 的互信息定义为 I(X; Y ) =\\sum_{x \\in \\cal{X}} \\sum_{y \\in \\cal{Y}}p(x, y) \\frac{log p(x, y)}{p(x)p(y)} \\tag{6}互信息的一个性质为 \\begin{eqnarray} I(X;Y) &=& H(X) − H(X|Y) \\tag{7} \\\\ &=& H(Y) − H(Y|X) \\tag{8} \\\\ &=& H(X) + H(Y) - H(X, Y) \\tag{9} \\end{eqnarray}如果X和Y相互独立，即X不对Y提供任何信息，反之亦然，因此它们的互信息最小， 即$I(X;Y)$为零。 主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/21/information-theory-1/"},{"title":"线性代数2-矩阵","text":"同步于CSDN;音尘杂记 线性代数2，主要回顾关于矩阵的相关知识。错误之处，还望诸君不吝指教。 1. 线性映射线性映射（Linear Mapping）是指从线性空间V 到线性空间W的一个映射函数$f : V \\to W$，并满足：对于$V$中任何两个向量$u$和$v$以及任何标量$c$，有 \\begin{eqnarray} f(u+v) &=& f(u) + f(v), \\tag{1.1} \\\\ f(cv) &=& cf(v). \\tag{1.2} \\end{eqnarray}两个有限维欧式空间的映射函数$f: \\mathbb{R}^n \\to \\mathbb{R}^m$可以表示为 y = Ax \\triangleq \\begin {bmatrix} a_{11}x_1 + a_{12}x_2 + ... + a_{1n}x_n \\\\ a_{21}x_1 + a_{22}x_2 + ... + a_{2n}x_n \\\\ \\vdots \\\\ a_{m1}x_1 + a_{m2}x_2 + ... + a_{mn}x_n \\\\ \\end {bmatrix}, \\tag{1.3}其中$A$定义为$m × n$的矩阵（Matrix），是一个由$m$行$n$列元素排列成的矩形阵列。一个矩阵A从左上角数起的第$i$行第$j$列上的元素称为第$i, j$项，通常记为$[A]_{ij}或 a _{ij}$。矩阵$A$定义了一个从$\\mathbb{R}^n$ 到 $\\mathbb{R}^m$ 的线性映射；向量 $x \\in \\mathbb{R}^n$ 和 $y \\in \\mathbb{R}^m$ 分别为两个空间中的列向量，即大小分别为$n \\times 1$和$m \\times 1$的矩阵。 x =\\begin {bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end {bmatrix}, y = \\begin {bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_m \\\\ \\end {bmatrix}, \\tag{1.4}一般为方便起见，书籍中约定逗号隔离的向量表示$[x_1, x_2, … , x_n]$为行向量，列向量通常用分号隔开的表示$x = [x_1; x_2; … ; x_n]$，或行向量的转置$[x_1, x_2, … , x_n]^T$。 2. 矩阵操作加 如果$A$和$B$都为$m×n$的矩阵，则$A$和$B$的加也是$m×n$的矩阵，其每个元素是$A$和$B$相应元素相加。 [A + B]_{ij} = a_{ij} + b_{ij} \\tag{1.5}乘积 假设有两个$A$和$B$分别表示两个线性映射$g : \\mathbb{R}^m \\to \\mathbb{R}^k$ 和 $f: \\mathbb{R}^n \\to \\mathbb{R}^m，则其复合线性映射为： (g \\circ f)(x) = g(f(x)) = g(Bx) = A(Bx) = (AB)x, \\tag{1.6}其中$AB$表示矩阵$A$和$B$的乘积，定义为 [AB]_{ij} = \\sum_{k=1}^na_{ik}b_{kj} \\tag{1.7}两个矩阵的乘积仅当第一个矩阵的列数和第二个矩阵的行数相等时才能定义。如$A$是$k × m$矩阵和$B$是$m × n$矩阵，则乘积$AB$是一个$k × n$的矩阵。矩阵的乘法也满足结合律和分配律： 结合律： $(AB)C = A(BC)$, 分配律： $(A + B)C = AC + BC，C(A + B) = CA + CB$. Hadamard 积 $A$和$B$的Hadamard积，也称为逐点乘积，为$A$和$B$中对应的元素相乘。 [A \\odot B]_{ij} = a_{ij}b_{ij} \\tag{1.8}一个标量$c$与矩阵$A$乘积为$A$的每个元素是$A$的相应元素与$c$的乘积 [cA]_{ij} = ca_{ij} \\tag{1.9}转置 $m×n$矩阵$A$的转置（Transposition）是一个$n×m$的矩阵，记为$A^T$，$A^T$的第$i$行第$j$列的元素是原矩阵A的第$j$行第$i$列的元素 [A^T]_{ij} = [A]_{ji} \\tag{1.10}向量化 矩阵的向量化是将矩阵表示为一个列向量。这里，vec是向量化算子。设$A = [a_{ij}]_{m×n}$，则 vec(A) = [a_{11}, a_{21}, ... , a_{m1}, a_{12}, a_{22}, ... , a_{m2}, ... , a_{1n}, a_{2n}, ... , a_{mn}]^T \\tag{1.11}迹 $n$ x $n$矩阵$A$的对角线元素之和称为它的迹（Trace），记为tr(A)。尽管矩阵的乘法不满足交换律，但它们的迹相同，即tr(AB) = tr(BA)。 行列式 $n$ x $n$矩阵$A$的行列式是一个将其映射到标量的函数，通常记作$det(A)$或$|A|$。行列式可以看做是有向面积或体积的概念在欧氏空间中的推广。在$n$维欧氏空间中，行列式描述的是一个线性变换对“体积”所造成的影响。一个$n × n$的矩阵$A$的行列式定义为： det(A) = \\sum_{\\sigma \\in S_n}(-1)^k\\prod a_i,\\sigma(i) \\tag{1.12}解释一下，$S_n$是$\\{1,2,…,n\\}$的所有排列的集合，$\\sigma$是其中一个排列，$\\sigma(i)$是元素i在排列$\\sigma$中的位置，k表示$\\sigma$中的逆序对的数量。 其中逆序对的定义为：在排列$\\sigma$中，如果有序数对$(i, j)$满足$1 \\leq i &lt; j \\leq n$但$\\sigma(i) &gt; \\sigma(j)$，则其为$\\sigma$的一个逆序对。举个例子(左侧为排列， 右侧为逆序对数量)： eg：[4, 3, 1, 2, 5] \\to 5秩 一个矩阵$A$的列秩是$A$的线性无关的列向量数量，行秩是$A$的线性无关的行向量数量。一个矩阵的列秩和行秩总是相等的，简称为秩（Rank）。 一个$m × n$的矩阵$A$的秩最大为$min(m, n)$。若$rank(A) = min(m, n)$，则称矩阵为满秩的。如果一个矩阵不满秩，说明其包含线性相关的列向量或行向量，其行列式为0。两个矩阵的乘积$AB$的秩$rank(AB) \\leq min(rank(A), rank(B))$。 范数 在“线性代数1-向量和向量空间”中已经提及 \\ell_p(v) = \\parallel v \\parallel_p = {(\\sum_{i=1}^{n}|v_i|^p)}^{1/p}, \\tag{1.13}3. 矩阵类型对称矩阵 对称矩阵（Symmetric Matrix）指其转置等于自己的矩阵，即满足$A = A^T$。 对角矩阵 对角矩阵（Diagonal Matrix）是一个主对角线之外的元素皆为0 的矩阵。对角线上的元素可以为0 或其他值。一个$n × n$的对角矩阵$A$满足 [A]_{ij} = 0 \\qquad if \\quad i\\neq j \\quad \\forall i,j \\in \\{1, ..., n\\} \\tag{1.14}对角矩阵A也可以记为diag(a)，a 为一个n维向量，并满足 [A]_{ii} = a_i \\tag{1.15}其中$n × n$的对角矩阵$A = diag(a)$和$n$维向量b的乘积为一个$n$维向量 Ab = diag(a)b = a \\odot b \\tag{1.16}其中$\\odot$表示点乘，即$(a \\odot b)_i = a_ib_i$。 单位矩阵 单位矩阵（Identity Matrix）是一种特殊的的对角矩阵，其主对角线元素为1，其余元素为0。$n$阶单位矩阵$I_n$，是一个$n × n$的方块矩阵。可以记为$I_n = diag(1, 1, …, 1)$。一个m × n的矩阵A和单位矩阵的乘积等于其本身。 AI_n = I_mA = A \\tag{1.17}逆矩阵 对于一个$n × n$的方块矩阵$A$，如果存在另一个方块矩阵$B$使得 AB = BA = I_n \\tag{1.18}其中$I_n$为单位阵，则称$A$是可逆的。矩阵$B$称为矩阵A的逆矩阵（Inverse Matrix），记为$A^{−1}$。 一个方阵的行列式等于0当且仅当该方阵不可逆时。 正定矩阵 对于一个$n×n$的对称矩阵$A$，如果对于所有的非零向量$x \\in \\mathbb{R}^n$都满足 x^TAx > 0 \\tag{1.19}则$A$为正定矩阵（Positive-Definite Matrix）。如果$x^TAx \\geq 0$，则$A$是半正定矩阵（Positive-Semidefinite Matrix）。 正交矩阵 正交矩阵（Orthogonal Matrix）$A$为一个方块矩阵，其逆矩阵等于其转置矩阵。 A^T = A^{-1} \\tag{1.20}等价于$A^TA = AA^T = I_n$。 Gram矩阵 向量空间中一组向量$v_1, v_2 , … , v_n$的Gram 矩阵（Gram Matrix）;G是内积的对称矩阵，其元素$G_{ij}$为${v_i}^T v_j$。 4. 特征值与特征矢量如果一个标量$\\lambda$和一个非零向量v满足 Av = \\lambda v \\tag{1.21}则$\\lambda$和$v$分别称为矩阵$A$的特征值（Eigenvalue）和特征向量（Eigenvector）。 5. 矩阵分解一个矩阵通常可以用一些比较“简单”的矩阵来表示，称为矩阵分解（Matrix Decomposition, Matrix Factorization）。 奇异值分解 一个$m×n$的矩阵$A$的奇异值分解（Singular Value Decomposition，SVD）定义为 A = U\\sum V^T \\tag{1.22}其中$U$和$V$分别为$m × m$和$n × n$的正交矩阵，$\\sum$为$m × n$的对角矩阵，其对角线上的元素称为奇异值（Singular Value）。 特征分解 一个$n × n$的方块矩阵$A$的特征分解（Eigendecomposition）定义为 A = Q\\Lambda Q^{-1} \\tag{1.23}其中$Q$为$n×n$的方块矩阵，其每一列都为$A$的特征向量，Λ为对角阵，其每一个对角元素为$A$的特征值。如果$A$为对称矩阵，则A可以被分解为 A = Q\\Lambda Q^T \\tag{1.24}其中Q为正交阵。 主要参考 https://github.com/nndl/nndl.github.io","link":"/2019/06/12/linear-algebra-2/"},{"title":"Logistic loss函数","text":"同步于CSDN;音尘杂记 前面在浏览sklearn中关于Logistic Regression部分，看到关于带正则项的LR目标损失函数的定义形式的时候，对具体表达式有点困惑，后查阅资料，将思路整理如下。 1. sklearn文档中的LR损失函数先看sklearn对于LR目标损失函数(带L2)的定义： \\min_{w, c} \\frac{1}{2}w^T w + C \\sum_{i=1}^n \\log(\\exp(- y_i (X_i^T w + c)) + 1)看到这个表达形式，其实是有两个疑问： logistic loss的表达形式 正则项的惩罚系数 对于第二个问题，其实比较容易解释。通常我们在最小化结构风险时，会给我们的惩罚项乘上一个惩罚系数λ(通常1 &lt; λ &lt; 0)， \\min_{w, λ} \\sum_{i=1}^nloss(y, y_i) + λw^T w一般，为方便处理，做一个技巧性地处理，对多项式乘上一个正数 1/2λ, 得到： \\min_{w, λ} \\frac{1}{2λ}\\sum_{i=1}^nloss(y, y_i) + \\frac{1}{2}w^T w令C = 1/2λ即可。 但是对于第一个形式，当时比较困惑；特意翻看了一下我以前记录的关于LR以及LR损失函数的一些笔记。 2. LR损失函数为了方便说明笔者当时的疑惑所在，便将当时脑海里存在的logistic loss函数形式 和 sklearn中LR损失函数的推导方法分别记为旧思路和新思路吧。 2.1 logistic基础知识如指数分布、高斯分布等分布一样，logistic是一种变量的分布，它也有自己的概率分布函数和概率密度函数，其中概率分布函数如下： F(x) = P(X \\leq x) = \\frac{1}{1+e^{-(x-\\mu)/\\gamma}}对概率分布函数求导，记得到对应的概率密度函数： f(x) = \\frac{e^{-(x- \\mu)/ \\gamma}}{\\gamma(1+e^{-(x-\\mu)/\\gamma})^2}其中，$\\mu$就是分布对应的均值，$\\gamma$是对应的形状参数。 下文，为简介方便起见，将$-(x-\\mu)/\\gamma$ 替换为 $-x$,故记为： F(x) = \\frac{1}{1+exp(-x)}对应示例图如下： logistic有一个很重要的性质是： F(-x) = \\frac{1}{1+exp(x)} = \\frac{1}{1+\\frac{1}{exp(-x)}} = \\frac{exp(-x)}{1+exp(-x)}=1-\\frac{1}{1+exp(-x)}=1-F(x)通常，应用到LR中，有如下形式： (1) P(Y=1|\\beta,x) = \\frac{1}{1+exp(-\\beta x)} = \\frac{e^{\\beta x}}{1+e^{\\beta x}} P(Y=0|\\beta,x) = 1 - \\frac{1}{1+exp(-\\beta x)} = \\frac{1}{1+e^{\\beta x}}一个事件的几率(odds)，定义为该事件发生与不发生的概率比值，若事件发生概率为p： odds = \\frac{p}{1-p}那么该事件的对数几率（log odds或者logit）如下： logit(p)=log\\frac{p}{1−p}那么，对于上述二项，Y=1的对数几率就是： log \\frac{P(Y=1|\\beta,x)}{1−P(Y=1|\\beta,x)}=log \\frac{P(Y=1|\\beta,x)}{P(Y=0|\\beta,x)}=\\beta x也就是说，输出Y=1的对数几率是由输入x的线性函数表示的模型，这就是逻辑回归模型。易知，当 $\\beta x$的值越大，$P(Y=1|\\beta,x)$越接近1；$\\beta x$越小,$P(Y=1|\\beta,x)$ 越接近0。 其实，LR就是一个线性分类的模型。与线性回归不同的是：LR将线性方程输出的很大范围的数压缩到了[0,1]区间上；更优雅地说：LR就是一个被logistic方程归一化后的线性回归。 2.2 旧思路旧思路要从LR的参数求解过程说起。 我们知道统计学中一种很常用的方法是根据最大化似然函数的值来估计总体参数。在机器学习领域，我们听到的更多是损失函数的概念，常通过构建损失函数，然后最小化损失函数估计目标参数。在这里，最大化对数似然函数与最小化对数似然损失函数其实是等价的，下面我们可以看到。 假设我们有n个独立的训练样本$\\{(x_1,y_1),(x_2,y_2),(x_3,y_3),…,(x_n,y_n)\\},y={0,1}$,那么每一个观察到的样本$(x_i,y_i)$出现的概率是： P(y_i,x_i) = P(y_i=1 | x_i)^{y_i}(1-P(y_i=1 | x_i))^{1-y_i}显然，$y_i$为1时，保留前半部分；$y_i$为0时，保留后半部分。 构建似然函数： L(\\beta) = \\prod P(y_i=1|x_i)^{y_i}(1-P(y_i=1|x_i))^{1-y_i} OK,对似然函数取对数，得到对数似然函数： LL(\\beta) = log(L(\\beta))= log(\\prod P(y_i=1|x_i)^{y_i}(1-P(y_i=1|x_i))^{1-y_i}) $= \\sum_{i=1}^{n}(y_i log P(y_i=1|x_i) + (1-y_i)log(1-P(y_i=1|x_i)))$ $= \\sum_{i=1}^{n}y_i log \\frac{P(y_i=1|x_i)}{1-P(y_i=1|x_i)} + \\sum_{i=1}^{n}log(1-P(y_i=1|x_i))$ $= \\sum_{i=1}^{n}y_i(\\beta x) + \\sum_{i=1}^{n}logP(y_i=0|x_i)$ $= \\sum_{i=1}^{n}y_i(\\beta x) - \\sum_{i=1}^{n}log(1+e^{\\beta x})$ 用 $LL(\\beta)$ 对 $\\beta$ 求偏导，得：$\\frac{\\partial LL(\\beta)}{\\partial \\beta}= \\sum_{i=1}^{n}y_ix_i - \\sum_{i=1}^{n} \\frac{e^{\\beta x_i}}{1+e^{\\beta x_i}}.x_i$ $= \\sum_{i=1}^{n}(y_i - P(y_i=1|x_i))x_i$该式是无法解析求解，故会用到一些优化算法进行求解(梯度下降、牛顿法等)，这不是本文重点，便不再赘述。 咋一看的确与sklearn中的形式差别有点大，所以请看新思路。 2.3 新思路在式(1)中， $x$表示特征向量，$\\beta$表示相应的超参数，此时$y\\in({0, 1})$表示样本对应的标签(label)。 这里，特别要讲的是另一种表达形式，将标签与预测函数在形式上统一了： (2) P(g=\\pm1 |\\beta, x) = \\frac{1}{1+exp(-g\\beta x)} 此时的样本标签$g\\in({1, -1})$。 虽然式(1)与式(2)看起来似乎不同，但是我们可以有如下证明： P(Y=1|\\beta,x) = \\frac{e^{\\beta x}}{1+e^{\\beta x}} = \\frac{1}{1+exp(-\\beta x)} = P(g=1 |\\beta, x)同理，我们可以证明$P(Y=0|\\beta,x)$ 和 $P(g=-1|\\beta,x)$是等价的。 既然两种形式是等价的，为了适应更加广泛的分类loss最小化的框架，故采用第二种形式来表示LR.毕竟Simple is better than complex. 首先定义$x_i$为特征向量，$y_i$为样本标签,则目标损失函数可以表示为： arg\\min_{\\beta}\\sum_{i=1}L(y_i, f(x_i))其中，f是我们的回归方程，L是目标损失函数。 对应到LR中，我们有 f(x) = \\beta x L(y, f(x)) = log(1 + exp(-yf(x)))如果将LR的第二种表达形式带入到损失函数L中，可得： L(y, f(x)) = log(1 + exp(-yf(x))) = log(\\frac{1}{P(y|\\beta,x)})再进一步： arg\\min_{\\beta}\\sum_{i=1}L(y_i, f(x_i)) = arg\\min_{\\beta}\\sum_{i=1}log(\\frac{1}{P(y_i|\\beta,x_i)}) = arg\\max_{\\beta}\\sum_{i=1}log(P(y_i|\\beta,x_i))= arg\\max_{\\beta}\\prod_{i=1}P(y_i|\\beta,x_i)等式最后即为极大似然估计的表达形式。 3. 思考其实到这儿，我们不难发现在旧思路中，推导极大化对数似然函数中的第二步：$= \\sum_{i=1}^{n}(y_i log P(y_i=1|x_i) + (1-y_i)log(1-P(y_i=1|x_i)))$ 与新思路中的： =arg\\max_{\\beta}\\sum_{i=1}log(P(y_i|\\beta,x_i))本质是统一的。 最后 “Simple is better than complex.” — The Zen of Python, by Tim Peters","link":"/2019/05/29/logistic-loss-function/"},{"title":"数学优化1-数学优化的类型","text":"同步于CSDN;音尘杂记 数学优化（Mathematical Optimization）问题，也叫最优化问题，是指在一定约束条件下，求解一个目标函数的最大值（或最小值）问题。 数学优化问题的定义为：给定一个目标函数（也叫代价函数）$f : \\cal{A} → \\Bbb{R}$，寻找一个变量（也叫参数）$x^* \\in \\cal{D}$，使得对于所有$\\cal{D}$中的$x，f(x^∗) ≤ f(x)$（最小化）；或者$f(x^∗) \\geq f(x)$（最大化），其中$\\cal{D}$为变量$x$的约束集，也叫可行域；$\\cal{D}$中的变量被称为是可行解。 1. 离散优化和连续优化根据输入变量$x$的值域是否为实数域，数学优化问题可以分为离散优化问题和连续优化问题。 1.1 离散优化问题离散优化（Discrete Optimization）问题是目标函数的输入变量为离散变量，比如为整数或有限集合中的元素。离散优化问题主要有两个分支： 组合优化（Combinatorial Optimization）：其目标是从一个有限集合中找出使得目标函数最优的元素。在一般的组合优化问题中，集合中的元素之间存在一定的关联，可以表示为图结构。典型的组合优化问题有旅行商问题、最小生成树问题、图着色问题等。很多机器学习问题都是组合优化问题，比如特征选择、聚类问题、超参数优化问题以及结构化学习（Structured Learning）中标签预测问题等。 整数规划（Integer Programming）：输入变量$x \\in \\Bbb{Z}^d$为整数。一般常见的整数规划问题为整数线性规划（Integer Linear Programming，ILP）。整数线性规划的一种最直接的求解方法是：（1）去掉输入必须为整数的限制，将原问题转换为一般的线性规划问题，这个线性规划问题为原问题的松弛问题；（2）求得相应松弛问题的解；（3）把松弛问题的解四舍五入到最接近的整数。但是这种方法得到的解一般都不是最优的，因此原问题的最优解不一定在松弛问题最优解的附近。另外，这种方法得到的解也不一定满足约束条件。 离散优化问题的求解一般都比较困难，优化算法的复杂度都比较高。 1.2 连续优化问题连续优化（Continuous Optimization）问题是目标函数的输入变量为连续变量$x \\in \\Bbb{R}^d$，即目标函数为实函数。下文的内容主要以连续优化为主。 2. 无约束优化和约束优化在连续优化问题中，根据是否有变量的约束条件，可以将优化问题分为无约束优化问题和约束优化问题。 无约束优化问题（Unconstrained Optimization）的可行域为整个实数域$\\cal{D} = \\Bbb{R}^d$，可以写为 \\min_{x} f(x) \\tag{1}其中$x \\in \\Bbb{R}^d$为输入变量，$f : \\Bbb{R}^d \\to \\Bbb{R}$为目标函数。 约束优化问题（Constrained Optimization）中变量x需要满足一些等式或不等式的约束。约束优化问题通常使用拉格朗日乘数法来进行求解。 3. 线性优化和非线性优化如果在公式(1) 中，目标函数和所有的约束函数都为线性函数，则该问题为线性规划问题（Linear Programming）。相反，如果目标函数或任何一个约束函数为非线性函数，则该问题为非线性规划问题（Nonlinear Programming）。 在非线性优化问题中，有一类比较特殊的问题是凸优化问题（Convex Programming）。在凸优化问题中，变量x 的可行域为凸集，即对于集合中任意两点，它们的连线全部位于在集合内部。目标函数f也必须为凸函数，即满足 f(\\alpha x + (1 − \\alpha)y) \\leq \\alpha f(x) + (1 − \\alpha)f(y), ∀\\alpha \\in [0, 1] \\tag{2}凸优化问题是一种特殊的约束优化问题，需满足目标函数为凸函数，并且等式约束函数为线性函数，不等式约束函数为凹函数。 主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/17/mathematical-optimization-1/"},{"title":"利用numpy.vectorize提升计算速度","text":"同步于CSDN;音尘杂记 在实际项目中，对超大矩阵进行计算或者对超大的DataFrame进行计算是一个经常会出现的场景。这里先不考虑开发机本身内存等客观硬件因素，仅从设计上讨论一下不同实现方式带来的性能差异，抛砖引玉。 项目中有这样一个需求，需要根据历史销量数据计算SKU(Stock Keeping Unit)之间的相似度，或者更通俗一点说是根据历史销量数据求不同SKU之间出现的订单交集以及并集大小(注:SKU数量大概15k左右，订单数大概1000k左右)。 这里给几条示例数据，可以更直观形象地理解这个需求： 然后需要根据这些历史的orderno-sku(订单-商品)数据求解出sku的相似度矩阵。其中SKU1和SKU2之间的相似度定义为: 可以很快速地想到几种解决方案： 直接for loops； for loops稍微改进采用列表生成器； 采用多进程并行计算； 采用numpy.vectorize 1.for loops计算相似度矩阵1234567891011121314151617181920212223@timerdef gen_corr_matrix_for_loops(order_df): &quot;&quot;&quot; for loops计算相似度矩阵 &quot;&quot;&quot; df = order_df.groupby(['sku']).agg({'orderno': lambda x: set(x)}).reset_index() del order_df gc.collect() l = len(df) sku_series = df.sku.astype(str) corr_matrix_arr = np.ones((l, l)) tbar = trange(l) tbar.set_description(&quot;compute corr matrix&quot;) for i in tbar: for j in range(i + 1, l): corr_matrix_arr[j, i] = corr_matrix_arr[i, j] = len(df.iloc[i, 1] &amp; df.iloc[j, 1]) / len( df.iloc[i, 1] | df.iloc[j, 1]) corr_matrix_df = pd.DataFrame(columns=sku_series, index=sku_series, data=corr_matrix_arr) return corr_matrix_df 计算耗时：2000s+ 2.list generator计算相似度矩阵12345678910111213141516171819202122232425@timerdef gen_corr_matrix_generator(order_df): &quot;&quot;&quot; 列表生成器计算相似度矩阵 &quot;&quot;&quot; df = order_df.groupby(['sku']).agg({'orderno': lambda x: set(x)}).reset_index() del order_df gc.collect() l= len(df) sku_series = df.sku.astype(str) corr_matrix_arr = np.ones((l, l)) l1 = df.orderno l2 = np.array(df['orderno'].apply(len), dtype=np.int8) result_list = [[i, j, len(l1[i] &amp; l1[j])] for i in range(l) for j in range(i+1, l) if len(l1[i] &amp; l1[j]) &gt; 0] for i, j, k in result_list: corr_matrix_arr[j, i] = corr_matrix_arr[i, j] = k * 1.0 / (l2[i] + l2[j] - k) corr_matrix_df = pd.DataFrame(columns=sku_series, index=sku_series, data=corr_matrix_arr) return corr_matrix_df 计算耗时：1296s 3.多进程计算相似度矩阵12345678910111213141516171819202122232425262728293031323334353637383940414243@timerdef gen_corr_matrix_multiprocessing(order_df): &quot;&quot;&quot; 多进程计算相似度矩阵 &quot;&quot;&quot; df = order_df.groupby(['sku']).agg({'orderno': lambda x: set(x)}).reset_index() del order_df gc.collect() l = len(df) sku_series = df.sku.astype(str) l1 = df.orderno l2 = np.array(df['orderno'].apply(len), dtype=np.int8) del df gc.collect() arr2 = np.zeros((l, l), dtype=np.float32) pairs = [[i, j] for i in range(l - 1) for j in range(i + 1, l)] loops = int(math.ceil((l ** 2 - l) / 10 ** 6 / 2)) tbar = trange(loops) tbar.set_description(&quot;compute corr matrix&quot;) pool = Pool(4) for loop in tbar: temp_lists = [[i, j, l1[i], l1[j]] for i, j in pairs[(10 ** 6 * loop): (10 ** 6 * (loop + 1))]] temp_results = pool.map(cal, temp_lists) for i, j, k in temp_results: arr2[i, j] = k pool.close() pool.join() arr1 = l2 + l2.reshape((l, 1)) arr2 = arr2 + arr2.T # 变对称阵 arr3 = arr2 / (arr1 - arr2) + np.eye(l) del arr1 del arr2 gc.collect() corr_matrix_df = pd.DataFrame(columns=sku_series, index=sku_series, data=arr3) return corr_matrix_df 计算耗时：1563s 4.numpy.vectorize计算相似度矩阵1234567891011121314151617181920212223@timerdef gen_corr_matrix_vectorize(order_df): &quot;&quot;&quot; numpy.vectorice计算相似度矩阵 &quot;&quot;&quot; df = order_df.groupby(['sku']).agg({'orderno': lambda x: set(x)}).reset_index() l = len(df) sku_series = df.sku.astype(str) arr = df.orderno.values corr_matrix_arr = np.zeros((l, l)) f_vec = np.vectorize(len) arr1 = f_vec(arr) tbar = trange(l - 1) tbar.set_description(&quot;compute corr matrix&quot;) for i in tbar(l - 1): corr_matrix_arr[i, (i + 1): l] = f_vec(arr[(i + 1): l] &amp; arr[i]) corr_matrix_arr1 = np.add.outer(arr1, arr1) temp = corr_matrix_arr / (corr_matrix_arr1 - corr_matrix_arr) temp = temp + temp.T + np.eye(l) return pd.DataFrame(columns=sku_series, index=sku_series, data=temp) 计算耗时：72s 可以看到，使用numpy.vectorize提升了20倍左右！ 思考：结合到实际业务中，其实有很多可以改进的地方：1. 并不需要计算所有SKU之间的相似度（提速）; 2. 可以只保存上三角阵或保存有效的相似SKU数据(降低内存)。这块儿就不展开赘述了。","link":"/2019/06/12/numpy-vectorize/"},{"title":"数学优化2-优化算法","text":"同步于CSDN;音尘杂记 优化问题一般都是通过迭代的方式来求解：通过猜测一个初始的估计$x_0$，然后不断迭代产生新的估计$x_1, x_2, … x_t$，希望$x_t$最终收敛到期望的最优解$x^∗$。 一个好的优化算法应该是在一定的时间或空间复杂度下能够快速准确地找到最优解。同时，好的优化算法受初始猜测点的影响较小，通过迭代能稳定地找到最优解$x^∗$的邻域，然后迅速收敛于$x^∗$。 优化算法中常用的迭代方法有线性搜索和置信域方法等。线性搜索的策略是寻找方向和步长，具体算法有梯度下降法、牛顿法、共轭梯度法等。在文章中也简要介绍过梯度下降的概念，这里为使得整个体系完整故重新记录一下。 1. 全局最优和局部最优对于很多非线性优化问题，会存在若干个局部的极小值。局部最小值，或局部最优解$x^∗$定义为：存在一个$\\delta &gt; 0$，对于所有的满足$∥x−x^*∥ \\leq \\delta$的x，公式$f(x^∗) \\leq f(x)$成立。也就是说，在$x^∗$的附近区域内，所有的函数值都大于或者等于$f(x^∗)$。 对于所有的$x \\in A$，都有$f(x^∗) \\leq f(x)$成立，则$x^∗$为全局最小值，或全局最优解。一般的，求局部最优解是容易的，但很难保证其为全局最优解。对于线性规划或凸优化问题，局部最优解就是全局最优解。 要确认一个点$x^∗$是否为局部最优解，通过比较它的邻域内有没有更小的函数值是不现实的。如果函数$f(x)$是二次连续可微的，我们可以通过检查目标函数在点$x^∗$的梯度$∇f(x^∗)$和Hessian矩阵$\\nabla^2f(x^∗)$来判断。 定理1 局部最小值的一阶必要条件： 如果$x^∗$为局部最优解并且函数$f$在$x^∗$的邻域内一阶可微，则在$∇f(x^∗) = 0$。 证明. 如果函数$f(x)$是连续可微的，根据泰勒展开公式（Taylor’s Formula），函数$f(x)$的一阶展开可以近似为 f(x^∗ + \\Delta x) = f(x^∗) + \\Delta x^T \\nabla f(x^∗) \\tag{1}假设$∇f(x^∗) \\neq 0$，则可以找到一个$\\Delta x$（比如$\\Delta x = −\\alpha ∇f(x^∗)$，$\\alpha$为很小的正数），使得 f(x^∗ + \\Delta x) − f(x^∗) = \\Delta x^T \\nabla f(x^∗) \\leq 0 \\tag{2}这和局部最优的定义矛盾。 定理2 局部最优解的二阶必要条件： 如果$x^∗$为局部最优解并且函数$f$在$x^∗$的领域内二阶可微，则$\\nabla f(x^∗)=0, \\nabla^2 f(x^*)$为半正定矩阵。 证明. 如果函数$f(x)$是二次连续可微的，函数$f(x)$的二阶展开可以近似为 f(x^∗ + \\Delta x) = f(x^∗) + \\Delta x^T \\nabla f(x^∗) + \\frac{1}{2}\\Delta x^T (\\nabla^2f(x^∗))\\Delta x \\tag{3}由一阶必要性定理可知$\\nabla f(x^∗) = 0$，则 f(x^∗ + \\Delta x) − f(x^∗) = \\frac{1}{2}\\Delta x^T (\\nabla^2 f(x^∗))\\Delta x \\geq 0 \\tag{4}即Hessian矩阵$\\nabla^2f(x^∗)$为半正定矩阵。 2. 梯度下降法梯度下降法（Gradient Descent Method），也叫最速下降法（Steepest Descend Method），经常用来求解无约束优化的极小值问题。 对于函数$f(x)$，如果$f(x)$在点$x_t$附近是连续可微的，那么$f(x)$下降最快的方向是$f(x)$在$x_t$点的梯度方法的反方向。根据泰勒一阶展开公式， f(x_{t+1}) = f(x_t + \\Delta x) \\approx f(x_t) + \\Delta x^T \\nabla f(x_t) \\tag{5}要使得$f(x_{t+1}) &lt; f(x_t)$，就得使$\\Delta x^T\\nabla f(x_t) &lt; 0$。我们取$\\Delta x = −\\alpha \\nabla f(x_t)$。如果$\\alpha &gt; 0$为一个够小数值时，那么$f(x_{t+1}) &lt; f(x_t)$ 成立。 这样我们就可以从一个初始值$x_0$出发，通过迭代公式 x_{t+1} = x_t − \\alpha_t\\nabla f(x_t), t \\geq 0 \\tag{6}生成序列$x_0, x_1, x_2, …$ 使得 f(x_0) \\geq f(x_1) \\geq f(x_2) \\geq ... \\tag{7}如果顺利的话，序列($x_n$) 收敛到局部最优解$x^∗$。注意每次迭代步长$\\alpha$可以改变，但其取值必须合适，如果过大就不会收敛，如果过小则收敛速度太慢。 梯度下降法的示例过程可以参见下图： 梯度下降法为一阶收敛算法，当靠近极小值时梯度变小，收敛速度会变慢，并且可能以“之字形”的方式下降。如果目标函数为二阶连续可微，我们可以采用牛顿法。牛顿法为二阶收敛算法，收敛速度更快，但是每次迭代需要计算Hessian矩阵的逆矩阵，复杂度较高。相反，如果我们要求解一个最大值问题，就需要向梯度正方向迭代进行搜索，逐渐接近函数的局部极大值点，这个过程则被称为梯度上升法（GradientAscent）。 后面准备专门整理一份梯度下降中关于批量梯度下降(BGD)、随机梯度下降(SGD)、小批量梯度下降(MBGD)、Momentum、Adagrad等资料。 主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/18/mathematical-optimization-2/"},{"title":"概率论1-随机事件和概率","text":"同步于CSDN;音尘杂记 主要回顾概率论中关于样本空间、随机事件和常见概率分布的基础知识。 1. 样本空间样本空间 是一个随机试验所有可能结果的集合。例如，如果抛掷一枚硬币，那么样本空间就是集合{正面，反面}。如果投掷一个骰子，那么样本空间就是{1, 2, 3, 4, 5, 6}。随机试验中的每个可能结果称为样本点。 有些试验有两个或多个可能的样本空间。例如，从52 张扑克牌中随机抽出一张，样本空间可以是数字（A到K），也可以是花色（黑桃，红桃，梅花，方块）。如果要完整地描述一张牌，就需要同时给出数字和花色，这时样本空间可以通过构建上述两个样本空间的笛卡儿乘积来得到。 2. 随机事件随机事件（或简称事件） 指的是一个被赋予概率的事物集合，也就是样本空间中的一个子集。概率(Probability)表示一个随机事件发生的可能性大小，为0 到1 之间的一个非负实数。比如，一个0.5 的概率表示一个事件有50%的可能性发生。 对于一个机会均等的抛硬币动作来说，其样本空间为“正面”或“反面”。我们可以定义各个随机事件，并计算其概率。比如， {正面}，其概率为0.5； {反面}，其概率为0.5； 空集∅，不是正面也不是反面，其概率为0； {正面| 反面}，不是正面就是反面，其概率为1 3. 随机变量在随机试验中，试验的结果可以用一个数$X$来表示，这个数$X$是随着试验结果的不同而变化的，是样本点的一个函数。我们把这种数称为随机变量（Random Variable）。例如，随机掷一个骰子，得到的点数就可以看成一个随机变量$X$，$X$的取值为{1, 2, 3, 4, 5, 6}。 如果随机掷两个骰子，整个事件空间Ω可以由36 个元素组成： Ω = \\{(i, j)|i = 1, ... , 6; j = 1, ... , 6\\} \\tag{1}一个随机事件也可以定义多个随机变量。比如在掷两个骰子的随机事件中，可以定义随机变量$X$为获得的两个骰子的点数和，也可以定义随机变量$Y$为获得的两个骰子的点数差。随机变量$X$可以有11个整数值，而随机变量Y 只有6个。 \\begin{eqnarray} X(i, j) &:=& i + j, x = 2, 3, ... , 12 \\tag{2} \\\\ Y (i, j) &:=& | i − j |, y = 0, 1, 2, 3, 4, 5 \\tag{3} \\end{eqnarray}其中$i, j$分别为两个骰子的点数。 3.1 离散随机变量如果随机变量$X$所有可能取的值为有限可列举的，有$n$个有限取值${x_1, … , x_n}$,则称$X$为离散随机变量 要了解$X$的统计规律，就必须知道它取每种可能值$x_i$的概率，即 P(X = x_i) = p(x_i), \\qquad ∀i \\in [1, n] \\tag{4}$p(x_1), … , p(x_n)$称为离散型随机变量$X$的概率分布（Probability Distribution）或分布，并且满足 \\begin{eqnarray} \\sum_{i=1}^{n}p(x_i) &=& 1 \\\\ p(x_i) &\\geq& 0, \\qquad \\forall i \\in [1, n] \\end{eqnarray}\\tag{5}常见的离散随机变量的概率分布有： 伯努利分布 在一次试验中，事件A出现的概率为$\\mu$，不出现的概率为$1−\\mu$。若用变量$X$表示事件A出现的次数，则$X$的取值为0和1，其相应的分布为: p(x) = μ^x(1 − μ)^{(1−x)} \\tag{6}这个分布称为伯努利分布（Bernoulli Distribution）,又名两点分布或者0-1分布。 二项分布 在n次伯努利分布中，若以变量$X$表示事件A出现的次数，则$X$的取值为{0, · · · , n}，其相应的分布为二项分布（Binomial Distribution）。 P(X = k) = \\tbinom{n}{k}μ^k(1 − μ)^{n−k}, \\quad k = 1, ... , n \\tag{7}其中$\\tbinom{n}{k}$为二项式系数（这就是二项分布的名称的由来），表示从$n$个元素中取出$k$个元素而不考虑其顺序的组合的总数。 3.2 连续随机变量与离散随机变量不同，一些随机变量$X$的取值是不可列举的，由全部实数或者由一部分区间组成，比如 X = \\{x|a ≤ x ≤ b\\}, -\\infty < a < b < \\infty \\tag{8}则称$X$为连续随机变量。连续随机变量的值是不可数及无穷尽的。 对于连续随机变量$X$，它取一个具体值$x_i$的概率为0，这个离散随机变量截然不同。因此用列举连续随机变量取某个值的概率来描述这种随机变量不但做不到，也毫无意义。 连续随机变量$X$的概率分布一般用概率密度函数（Probability Density Function，PDF） p(x)来描述。p(x)为可积函数，并满足 \\begin{eqnarray} \\int_{-\\infty}^{\\infty} p(x)dx &=& 1 \\\\ p(x) &≥& 0 \\end{eqnarray} \\tag{9}给定概率密度函数p(x)，便可以计算出随机变量落入某一个区间的概率，而p(x)本身反映了随机变量取落入x的非常小的邻近区间中的概率大小。常见的连续随机变量的概率分布有： 均匀分布 若a, b为有限数，[a, b]上的均匀分布（Uniform Distribution）的概率密度函数定义为 p(x) = \\begin{cases} \\frac{1}{b-a} & a\\leq x \\leq b \\\\ 0 & x>b或x","link":"/2019/06/14/probability-theory-1/"},{"title":"数学优化3-拉格朗日乘数法与KKT条件","text":"同步于CSDN;音尘杂记 主要介绍一下数学优化中的拉格朗日乘数法和KKT条件，其实在 拙文 中已经有关于KKT条件的简要介绍和自己的个人总结，这里再一起回顾一下。 拉格朗日乘数法（Lagrange Multiplier）是约束优化问题的一种有效求解方法。约束优化问题可以表示为 \\begin{eqnarray} \\min_{x} \\qquad &f(x) \\\\ subject \\quad to \\qquad &h_i(x) = 0, i = 1, ... ,m \\\\ \\qquad &g_j(x) ≤ 0, j = 1, . . . , n \\end{eqnarray} \\tag{1}其中$h_i(x)$为等式约束函数，$g_j(x)$为不等式约束函数。x的可行域为 \\cal{D} = domf\\cap \\bigcap_{i=1}^{m} domh_i \\cap \\bigcap_{j=1}^{n} domg_j \\subseteq \\Bbb{R}^d \\tag{2}其中$domf$是函数f的定义域。 1. 等式约束优化问题如果公式(1) 中只有等式约束，我们可以构造一个拉格朗日函数Λ(x, λ): \\Lambda(x, \\lambda) = f(x) + \\sum_{i=1}^{m}\\lambda_i h_i(x) \\tag{3}其中$\\lambda$为拉格朗日乘数。如果$f(x^∗)$是原始约束优化问题的局部最优值，那么存在一个$λ^∗$使得$(x^∗, λ^∗)$为拉格朗日函数$Λ(x, λ)$的平稳点（stationary point）。因此，只需要令$\\frac{\\partialΛ(x,λ)}{\\partial x} = 0$和$\\frac{\\partialΛ(x,λ)}{\\partial \\lambda} = 0$，得到 \\nabla f(x) + \\sum_{i=1}^{m}\\lambda_i \\nabla h_i(x) = 0 \\tag{4} h_i(x) = 0, \\qquad i=0, ..., m \\tag{5}上面方程组的解即为原始问题的可能解。在实际应用中，需根据问题来验证是否为极值点。 拉格朗日乘数法是将一个有$d$个变量和$m$个等式约束条件的最优化问题转换为一个有$d + m$个变量的函数求平稳点的问题。拉格朗日乘数法所得的平稳点会包含原问题的所有极值点，但并不保证每个平稳点都是原问题的极值点。 2. 不等式约束优化问题对于公式(1) 中定义的一般约束优化问题，其拉格朗日函数为 \\Lambda(x, a, b) = f(x) + \\sum_{i=1}^{m}a_i h_i(x) + \\sum_{j=1}^{n}b_j g_j(x) \\tag{6}其中$a = [a_1, … , a_m]^T$为等式约束的拉格朗日乘数，$b = [b_1, … , b_n]^T$为不等式约束的拉格朗日乘数。 当约束条件不满足时，有$\\max_{a,b} \\Lambda(x, a, b) = \\infty$；当约束条件满足时并且$b ≥ 0$时，$\\max_{a,b} \\Lambda(x, a, b) = f(x)$。因此原始约束优化问题等价于 \\min_x \\max_{a,b} \\Lambda(x, a, b) \\tag{7} subject \\quad to \\qquad b ≥ 0 \\tag{8}这个min-max优化问题称为主问题（Primal Problem）。 对偶问题 主问题的优化一般比较困难，我们可以通过交换min-max 的顺序来简化。定义拉格朗日对偶函数为 \\Gamma(a, b) = \\inf_{x \\in D}\\Lambda (x, a, b) \\tag{9}$\\Gamma(a, b)$是一个凹函数，即使$f(x)$是非凸的。 当$b \\geq 0$时，对于任意的$\\tilde{x} \\in \\cal{D}$，有 \\Gamma(a, b) = \\inf_{x\\in D}\\Lambda(x, a, b) \\leq \\Lambda(\\tilde{x}, a, b) ≤ f(\\tilde{x}) \\tag{10}令$p^∗$是原问题的最优值，则有 \\Gamma(a, b) \\leq p^∗ \\tag{11}即拉格朗日对偶函数$Γ(a, b)$为原问题最优值的下界。 优化拉格朗日对偶函数$Γ(a, b)$并得到原问题的最优下界，称为拉格朗日对偶问题（Lagrange Dual Problem）。 \\begin{eqnarray} \\max_{a,b} \\qquad &\\Gamma(a, b) \\tag{12} \\\\ subject \\quad to \\qquad &b ≥ 0 \\tag{13} \\end{eqnarray}拉格朗日对偶函数为凹函数，因此拉格朗日对偶问题为凸优化问题。 令$d^∗$表示拉格朗日对偶问题的最优值，则有$d^∗ \\leq p^∗$，这个性质称为弱对偶性（Weak Duality）。如果$d^∗ = p^∗$，这个性质称为强对偶性（Strong Duality）。 当强对偶性成立时，令$x^∗$和$a^∗, b^∗$分别是原问题和对偶问题的最优解，那么它们满足以下条件： \\begin{eqnarray} & \\nabla f(x^∗) + \\sum_{i=1}^ma_i^∗ \\nabla h_i(x^∗) + \\sum_{j=1}^{n}b_j^∗\\nabla g_j(x^∗) = 0 \\tag{14} \\\\ & h_i(x^∗) = 0, \\quad i = 0, ... ,m \\tag{15} \\\\ & g_j(x^∗) \\leq 0, \\quad j = 0, ... , n \\tag{16} \\\\ & b_j^∗ g_j(x^∗) = 0, \\quad j = 0, ... , n \\tag{17} \\\\ & b_j^∗ \\geq 0, \\quad j = 0, ... , n \\tag{18} \\end{eqnarray}称为不等式约束优化问题的KKT条件（Karush-Kuhn-Tucker Conditions）。KKT条件是拉格朗日乘数法在不等式约束优化问题上的泛化。当原问题是凸优化问题时，满足KKT条件的解也是原问题和对偶问题的最优解。 KKT条件中需要关注的是公式(17)，称为互补松弛条件（Complementary Slackness）。如果最优解$x^∗$出现在不等式约束的边界上$g_j(x) = 0$，则$b_j^∗ &gt; 0$；如果$x^∗$出现在不等式约束的内部$g_j(x) &lt; 0$，则$b_j^∗$= 0$。互补松弛条件说明当最优解出现在不等式约束的内部，则约束失效。 主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/19/mathematical-optimization-3/"},{"title":"概率论2-随机过程","text":"同步于CSDN;音尘杂记 随机过程（Stochastic Process） 是一组随机变量$X_t$的集合，其中$t$属于一个索引（index）集合$\\cal{T}$。索引集合$\\cal{T}$可以定义在时间域或者空间域，但一般为时间域，以实数或正数表示。当t为实数时，随机过程为连续随机过程；当t为整数时，为离散随机过程。 日常生活中的很多例子包括股票的波动、语音信号、身高的变化等都可以看作是随机过程。常见的和时间相关的随机过程模型包括伯努利过程、随机游走（Random Walk）、马尔可夫过程等。和空间相关的随机过程通常称为随机场（Random Field）。比如一张二维的图片，每个像素点（变量）通过空间的位置进行索引，这些像素就组成了一个随机过程。 1. 马尔可夫过程马尔可夫性质 在随机过程中，马尔可夫性质（Markov Property）是指一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。以离散随机过程为例，假设随机变量$X_0,X_1, … ,X_T$构成一个随机过程。这些随机变量的所有可能取值的集合被称为状态空间（State Space）。如果$X_{t+1}$对于过去状态的条件概率分布仅是$X_t$的一个函数，则 P(X_{t+1} = x_{t+1}|X_{0:t} = x_{0:t}) = P(X_{t+1} = x_{t+1}|X_t = x_t) \\tag{1}其中$X{0:t}$表示变量集合$X_0,X_1, … ,X_t，x_{0:t}$表示为在状态空间中的状态序列。 马尔可夫性质也可以描述为给定当前状态时，将来的状态与过去状态是条件独立的。 1.1 马尔可夫链离散时间的马尔可夫过程也称为马尔可夫链（Markov Chain）。如果一个马尔可夫链的条件概率 P(X_{t+1} = s_i|X_t = s_j) = T(s_i, s_j) \\tag{2}在不同时间都是不变的，即和时间$t$无关，则称为时间同质的马尔可夫链（Time-Homogeneous Markov Chains）。如果状态空间是有限的，$T(s_i, s_j)$也可以用一个矩阵$T$表示，称为状态转移矩阵（Transition Matrix），其中元素$t_{ij}$表示状态$s_i$转移到状态$s_j$的概率。 平稳分布 假设状态空间大小为$M$，向量$\\pi = [\\pi_1, … , 、\\pi_M]^T$ 为状态空间中的一个分布，满足$0 ≤ \\pi_i ≤ 1$ 和$\\sum_{i=1}^{M}\\pi_i =1$。 对于状态转移矩阵为$T$的时间同质的马尔可夫链，如果存在一个分布$\\pi$满足 \\pi = T \\pi \\tag{3}即分布$\\pi$就称为该马尔可夫链的平稳分布（Stationary Distribution）。根据特征向量的定义可知，$\\pi$为矩阵$T$的（归一化）的对应特征值为1的特征向量。 如果一个马尔可夫链的状态转移矩阵T满足所有状态可遍历性以及非周期性，那么对于任意一个初始状态分布$\\pi^{(0)}$，将经过一定时间的状态转移之后，都会收敛到平稳分布，即 \\pi = \\lim_{N \\to \\infty}T^Nπ^{(0)} \\tag{4} 定理1 - 细致平稳条件（Detailed Balance Condition）： 如果一个马尔科夫链满足 \\pi_it_{ij} = \\pi_jt_{ji} \\tag{5}则一定会收敛到平稳分布$\\pi$。 细致平稳条件保证了从状态$i$转移到状态$j$的数量和从状态$j$转移到状态$i$的数量相一致，相互抵消，所以数量不发生改变。 细致平稳条件只是马尔科夫链收敛的充分条件，不是必要条件。 2. 高斯过程高斯过程（Gaussian Process）也是一种应用广泛的随机过程模型。假设有一组连续随机变量$X_0,X_1, … ,X_T$ ，如果由这组随机变量构成的任一有限集合$X_{t_1,… ,t_k} = [X_{t_1} , … ,X_{t_n}]^T$都服从一个多元正态分布，那么这组随机变量为一个随机过程。高斯过程也可以定义为：如果$X_{t_1, … ,t_n}$ 的任一线性组合都服从一元正态分布，那么这组随机变量为一个随机过程。 高斯过程回归 高斯过程回归（Gaussian Process Regression）是利用高斯过程来对一个函数分布进行建模。和机器学习中参数化建模（比如贝叶斯线性回归）相比，高斯过程是一种非参数模型，可以拟合一个黑盒函数，并给出拟合结果的置信度[Rasmussen, 2004]。 假设一个未知函数$f(x)$服从高斯过程，且为平滑函数。如果两个样本$x_1, x_2$比较接近，那么对应的$f(x_1), f(x_2)$也比较接近。假设从函数$f(x)$中采样有限个样本$X = [x_1, x_2, … , x_N]$，这$N$个点服从一个多元正态分布， [f(x_1), f(x_2), ... , f(x_N)]^T \\sim N(\\mu(X),K(X,X)) \\tag{6}其中$\\mu(X) = [\\mu(x_1), \\mu(x_2), … , \\mu(x_N)]^T$是均值向量，$K(X,X) = [k(x_i, x_j )]_{N×N}$是协方差矩阵，$k(x_i, x_j)$为核函数，可以衡量两个样本的相似度。 在高斯过程回归，一个常用的核函数是平方指数（Squared Exponential）函数 k(x_i, x_j) = exp(\\frac{−∥x_i − x_j∥^2}{2l^2}) \\tag{7}其中$l$为超参数。当$x_i$和$x_j$越接近，其核函数的值越大，表明$f(x_i)$和$f(x_j)$越相关。 假设$f(x)$的一组带噪声的观测值为${(x_n, y_n)}_{n=1}^N$，其中$y_n \\sim N(f(x_n), \\sigma^2)$为正态分布，$\\sigma$为噪声方差。 对于一个新的样本点$x^∗$，我们希望预测函数$y^∗ = f(x^∗)$。令$y = [y_1, y_2, … , y_n]$为已有的观测值，根据高斯过程的假设，$[y; y^∗]$ 满足 其中$K(x^*,X) = [k(x^∗, x_1), … , k(x^∗, x^n)]$。 根据上面的联合分布，$y^∗$的后验分布为 p(y^∗|X, y) = N(\\hat{\\mu}, \\hat{\\sigma}^2) \\tag{9}其中均值$\\hat{\\mu}$和方差$\\hat{\\sigma}$为 从公式(10) 可以看出，均值函数$\\mu(x)$可以近似地互相抵消。在实际应用中，一般假设$\\mu(x) = 0$，均值$\\hat{\\mu}$可以将简化为 \\hat{\\mu} = K(x^∗,X)(K(X,X) + \\sigma^2 I)^{−1}y \\tag{12}高斯过程回归可以认为是一种有效的贝叶斯优化方法，广泛地应用于机器学习中。 主要参考https://github.com/nndl/nndl.github.io","link":"/2019/06/14/probability-theory-2/"},{"title":"Python中定义类的相关知识","text":"同步于CSDN;音尘杂记 主要介绍了在python中，抽象类的定义、多态的概念、类中属性的封装以及类中常见的修饰器。 1. 抽象类与Java一样，Python也有抽象类的概念，抽象类是一个特殊的类。其特殊之处在于 只能被继承，不能被实例化； 子类必须完全覆写(实现)其“抽象方法”和“抽象属性”后才能被实例化。 可以有两种实现方式: 利用NotImplementedError实现和利用abctractmethod实现 1.1 NotImplementedError1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-# @Time : 2018/11/20 10:11# @File : test_interface.py# @Software : PyCharm# @Desc :########################################## 利用NotImplementedError#########################################class Payment(object): def pay(self): raise NotImplementedErrorclass ChildPay(Payment): # 必须实现pay方法,否则报错NotImplementedError def pay(self): print(&quot;TestPay pay&quot;) def payed(self, money): print(&quot;Payed: {}&quot;.format(money)) if __name__ == '__main__': child_pay = ChildPay() child_pay.payed(20) 1.2 abctractmethod1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*-# @Time : 2018/11/20 10:11# @File : test_interface.py# @Software : PyCharm# @Desc :from abc import ABCMeta, abstractmethod# ########################################## abstractmethod# 子类必须全部重写父类的abstractmethod方法# 非abstractmethod方法可以不实现重写# 带abstractmethod方法的类不能实例化# #########################################class Payment(metaclass=ABCMeta): def __init__(self, name) self.name = name @abstractmethod def pay(self, money): pass @abstractmethod def get(self, money): print(&quot;Payment get {}&quot;.format(money)) def total(self, money): print(&quot;Payment total {}&quot;.format(money))class ChildPay(Payment): def pay(self, money): print(&quot;ChildPay pay {}&quot;.format(money)) def get(self, money): print(&quot;ChildPay get {}&quot;.format(money))if __name__ == '__main__': child_pay = ChildPay(&quot;safly&quot;) child_pay.pay(100) child_pay.get(200) child_pay.total(400) # 不能实例化 # TypeError: Can't instantiate abstract class Payment # with abstract methods get, pay # a = Payment(&quot;safly&quot;) 2. 多态概念向不同的对象发送同一条消息(obj.func(): 是调用了obj的方法func, 又称向obj发送了一条消息func)，不同的对象在接受时会产生不同的行为（即不同的处理方法）。 也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的对象可以执行不同的函数。 例： 男生.放松了()， 女生.放松了()，男生是打篮球，女生是看综艺，虽然二者消息一样，但是处理方法不同。 123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-# @Time : 2018/11/20 10:11# @File : test_interface.py# @Software : PyCharm# @Desc :from abc import ABCMeta, abstractmethodclass Base(metaclass=ABCMeta): @abstractmethod def relax(self): passclass Boy(Base): def relax(self): print(&quot;playing basketball&quot;)class Girl(Base): def relax(self): print(&quot;watching TV&quot;)if __name__ == '__main__': boy = Boy() girl = Girl() boy.talk() # playing basketball girl.talk() # watching TV 3. __属性封装3.1 私有静态属性、私有方法123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-# @Time : 2018/11/20 10:11# @File : test_interface.py# @Software : PyCharm# @Desc :# ########################################## __属性封装# 私有静态属性、私有方法# #########################################class Dog(object): # 私有静态属性 __kind = &quot;private kind&quot; # 调用私有静态属性 def get_kind(self): return Dog.__kind # 私有方法 def __func(self): print(&quot;__func&quot;) # 调用私有方法 def func(self): self.__func() if __name__ == '__main__': # 如下调用错误,因为需要在类内调用 # print(Dog.__kind) # 提倡如下调用方式 d = Dog() print(d.get_kind()) print(d.func()) # 不提倡如下调用方式 # d._Dog__func() # print(Dog.__dict__) # print(Dog._Dog__kind) # print(Dog._Dog__func) 3.2 私有对象属性12345678910111213141516171819202122232425# -*- coding: utf-8 -*-# @Time : 2018/11/20 10:11# @File : test_interface.py# @Software : PyCharm# @Desc :# ########################################## 私有对象属性# #########################################class Dog(object): def __init__(self, name, weight): self.name = name self.__weight = weight def get_weight(self): return self.__weightif __name__ == '__main__': room = Dog(&quot;doggy&quot;, 5) print(room.name) # doggy print(room.get_weight()) # 5 # 不能如下方法调用私有对象属性 # print(room.__weight) 3.3 私有属性不被继承12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-# @Time : 2018/11/20 10:11# @File : test_interface.py# @Software : PyCharm# @Desc :# ########################################## 私有属性不能被继承# #########################################class DogParent(object): __private = 'PRIVATE' def __init__(self, name): self.__name = name def __func(self): print(&quot;__DogParent func&quot;)class DogChild(DogParent): # 如下的方法是错误的 def get_private(self): return DogParent.__privateif __name__ == '__main__': dog_parent = DogParent(&quot;Tom&quot;) print(dir(dog_parent)) print(&quot;-------------&quot;) dog_child = DogChild(&quot;Tommy&quot;) print(dir(dog_child)) # 调用报错AttributeError: type object 'DogChild' has no attribute '_DogChild__private' # print(dog_child.get_private()) 4. 类中的常见修饰器主要介绍最常见的装饰器，classmethod, staticmethod和property 4.1 classmethod@classmethod不需要self参数，但是classmethod方法的第一个参数是需要表示自身类的cls 参数；不管是从类本身调用还是从实例化后的对象调用，都用第一个参数把类传进来。1234567891011121314151617181920212223242526272829303132class DogParent(object): __private = 'PRIVATE' def __init__(self, name): self.__name = name def __func(self): print(&quot;__DogParent func&quot;) # 类方法 @classmethod def change_name(cls, new_name): cls.__name = new_name @classmethod def get_name(cls): return cls.__name # 普通方法 def change_name2(self, new_name): self.__name = new_name def get_name2(self): return self.__name if __name__ == '__main__': DogParent.change_name(DogParent, &quot;Tom2&quot;) print(DogParent.get_name(DogParent)) DogParent.change_name2(&quot;Tom3&quot;) print(DogParent.get_name2()) 4.2 staticmethodstaticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用普通的函数一样;这样有一个好处： 有利于我们代码的优雅，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁 1234567891011121314151617181920212223242526272829303132class DogParent(object): __private = 'PRIVATE' def __init__(self, name): self.__name = name def __func(self): print(&quot;__DogParent func&quot;) # 类方法 @classmethod def change_name(cls, new_name): cls.__name = new_name @classmethod def get_name(cls): return cls.__name # 普通方法 def change_name2(self, new_name): self.__name = new_name def get_name2(self): return self.__name # 静态方法 @staticmethod def set_nickname(nickname): print(&quot;nickname: {}&quot;.format(nickname)) if __name__ == '__main__': DogParent.set_nickname(&quot;tom's nickname~&quot;) 4.3 property@property 把一个方法伪装成一个属性,这个属性的值，是这个方法的返回值；这个方法不能有参数，类不能调用，只能对象调用。12345678910111213class Person(object): def __init__(self, name, height, weight): self.name = name self.height = height self.weight = weight @property def bmi(self): return self.weight / (self.height ** 2) @property def method(self): print(&quot;method&quot;) 其实，property的作用不仅于此。简单点讲，@property的本质其实就是实现了get，set，delete三种方法。12345678910111213141516171819202122232425262728293031323334353637class Person(object): def __init__(self, name, nickname): self.name = name self.nickname = nickname @property def nickname(self): # 相当于实现了get方法 print(&quot;nickname: {}&quot;.self.nickname) @property.setter def nickname(self, new_nickname): # 相当于实现了set方法 self.nickname = new_nickname print(&quot;new nickname: {}&quot;.format(new_nickname)) @property.deleter def nickname(self): # 相当于实现了delete方法 del Person.nickname print(&quot;deleted nickname&quot;)if __name__ == '__main__': person = Person(&quot;Tom&quot;, 'tommmy') # get person.nickname() # setter person.nickname = 'new_tommmy' # deleter del person.nickname #删除完毕后,再次调用报如下错误 # AttributeError: type object 'person' has no attribute 'nickname' # person.nickname","link":"/2019/05/29/python-basic-about-class/"},{"title":"单层感知器为什么不能解决异或(XOR)问题","text":"同步于CSDN;音尘杂记 单层感知器为什么不能解决异或问题(XOR)问题？给出两个思路去考虑这个小问题~ 最近翻到了自己在印象笔记中学习记录的一些知识点，后续准备系统地整理放在自己的博客上，还请各位不吝指教。 1. 感知器模型 感知器模型是美国学者罗森勃拉特（Frank Rosenblatt）为研究大脑的存储、学习和认知过程而提出的一类具有自学习能力的神经网络模型，它把神经网络的研究从纯理论探讨引向了从工程上的实现。 Rosenblatt提出的感知器模型是一个只有单层计算单元的前向神经网络，称为单层感知器。 2. 单层感知器模型算法概述在学习基础的NN知识的时候，单个神经元的结构必定是最先提出来的，单层感知器模型算法与神经元结构类似； 大概思想是：首先把连接权和阈值初始化为较小的非零随机数，然后把有n个连接权值的输入送入网络，经加权运算处理，得到的输出如果与所期望的输出有较大的差别(对比神经元模型中的激活函数)，就对连接权值参数进行自动调整，经过多次反复，直到所得到的输出与所期望的输出间的差别满足要求为止。 如下为简单起见，仅考虑只有一个输出的简单情况。设$x_i(t)$是时刻$t$感知器的输入（i=1,2,……,n），$ω_i(t)$是相应的连接权值，$y(t)$是实际的输出，$d(t)$是所期望的输出，且感知器的输出或者为1，或者为0。 3. 线性不可分问题 单层感知器不能表达的问题被称为线性不可分问题。 1969年，明斯基证明了“异或”问题是线性不可分问题。 4. “与”、”或”、”非”问题的证明 由于单层感知器的输出为： y(x1,x2) = f(ω1 * x1 + ω2 * x2 - θ)所以，用感知器实现简单逻辑运算的情况如下： “与”运算（And, x1∧x2）令 ω1 = ω2 = 1，θ = 1.5，则: y = f(1 x1 + 1 x2 - 1.5)显然，当x1和x2均为1时，y的值1；而当x1和x2有一个为0时，y的值就为0. “或”运算（Or, x1∨x2）令ω1 = ω2=1, θ = 0.5，则: y=f(1 x1 + 1 x2 - 0.5)显然，只要x1和x2中有一个为1，则y的值就为1；只有当x1和x2都为0时，y的值才为0。 “非”运算（Not, ～X1）令ω1 = -1， ω2 = O， θ = -0.5，则: y = f((-1) x1 + 1 x2 + 0.5)显然，无论x2为何值，x1为1时，y的值都为0；x1为0时，y的值为1。即y总等于～x1。 “异或”运算（x1 XOR x2） 5. “异或”问题的证明5.1 单层感知机不能解决”异或”问题证明方法一如果“异或”（XOR）问题能用单层感知器解决，则由XOR的真值映射关系如下： (x1, x2) y (0, 0) 0 (0, 1) 1 (1, 0) 1 (1, 1) 0 则ω1、 ω2 和θ 必须满足如下方程组：1). ω1 + ω2 - θ ＜ 0 —&gt; θ &gt; ω1 + ω22). ω1 + 0 - θ ≥ 0 —&gt; 0 ≥ θ - ω13). 0 + 0 - θ ＜ 0 —&gt; θ &gt; 04). 0 + ω2 - θ ≥ 0 —&gt; 0 ≥ θ - ω2显然，该方程组是矛盾的，无解！这就说明单层感知器是无法解决异或问题的。 5.2 单层感知机不能解决”异或”问题证明方法二首先需要证明以下定理： 样本集线性可分的充分必要条件是正实例点集所构成的凸壳与负实例点集所构成的凸壳互不相交 必要性：假设样本集T线性可分，则存在一个超平面W将数据集正实例点和负实例点完全正确地划分到超平面两侧。显然两侧的点分别构成的凸壳互不相交； 充分性：假设存在两个凸壳A、B相交，且存在超平面W将A和B线性分割，令A在B的凸壳内部的点为a，因为线性可交，则A中不存在两点之间的连线与超平面W相交，而凸壳B中任意一点与A中的点的连线均与超平面W相交，则B内部的点a也与A中任一点之间的连线不与W相交，与B壳中任一点与A中的点的连线均与超平面W相交矛盾。 故：只有正负实例点所构成的两个凸壳不相交时样本集才线性可分。 显然，对于此例，负实例样本集[(0, 0), (1, 1)] 和 正实例样本集[(0, 1), (1, 0)]是二维中是不能被线性分割的。","link":"/2019/05/29/single-layer-perceptron/"},{"title":"分位数回归简介","text":"同步于CSDN;音尘杂记 最近在做一个比较有意思(难搞…)的项目。大致介绍一下相关背景：根据历史的一个工作情况(历史表现，也就是多少人做了多少工作量)，以及未来的一个预估工作量(预测值)，我们需要预估一个合理的人员投入;一言概之，根据历史表现和预测件量预估人员投入。 时序问题？咋一看，这不就是一个时序问题嘛！人力投入如下： Y_t = f(T_t, S_t, C_t, I_t)其中$T_t$代表长期趋势特征，$S_t$代表季节性或者季节变动，$C_t$代表周期性或循环波动，$I_t$代表随机性或不规则波动。接下来获取特征和历史人员投入，这不就可以预估得到了未来人力投入嘛。 但是，我们再仔细考虑一下。事情还不仅仅是如此简单。原因有两点： 与常见的销量、件量等的预测不同，人力的投入不仅仅是一个时序数据，内生的跟工作量强相关； 预估人员投入的一个很重要的目标是，求得一个合理的人员投入(范围)。 常规机器学习问题？或者，再稍微拓展一下，由于人员投入是跟工作量是强相关的，我们可不可以用机器学习的思路来解决这个问题。也即： Y_t = f(workload, other\\_features)其实也是存在问题的，在上述的有监督学习中，对于每一个instance我们是需要有一个监督值的。对于该场景下，貌似每个instance都存在一个人力投入值；但是我们的目标是需要预估一个合理的人力投入，如果单纯地去拟合当前的人力投入，岂不是认为目前的投入即是最优的了，既然如此就没有做这个任务的必要了。 经济学模型和其他尝试我们也曾尝试从经典的柯布-道格拉斯生产函数形式、部分随机人力规划系统以及基于强化学习等的的一些思路进行过分析过，均因效果不甚理想或者业务场景不相符而被pass掉。 最后，考虑到我们的主要目标是预估一个合理的人力投入，我们引入了衡量工作质量的一个变量。通过综合考虑质量和效能的关系，以保证预估出的人员数量，在保证工作量的情况或者说在降低人力投入量后工作质量不至于太差，反之亦然。最后，我们用了一个比较简单的方法来解决这个事情 — 分位数回归（Quantile Regression, QR）。 在介绍分为数回归的知识点之前，需要简要说一下推导过程不然显得太过突兀：定义工作量为$W$,业务指标准时完成量为$W1$,员工数量为$P$，显然， \\frac{W1}{W} = \\frac{W1}{P}\\frac{P}{W}这里的$\\frac{W1}{W}$用来衡量质量情况，$\\frac{P}{W}$的倒数$\\frac{W}{P}$用来衡量效能情况。我们可以认为，在同一个类型下(工作场景、工作时间)，实际工作效能$\\frac{W1}{P}$是一个相对客观的不变的值，令其为$k$。接下来我们便可以用分位数回归的方法求得系数也即$k$值，然后根据需要的质量情况，得到最终的效能范围，再结合预测件量情况，即可得到一个较为合理的人员投入范围。 首先，我们知道随机变量X的分布函数为： F(x) = P(X\\leq x)则随机变量X的$\\tau$分位数的定义为： Q_\\tau(X) = arginf\\{x\\in R ; F(x)\\geq\\tau\\}(0","link":"/2019/06/03/quantile-regression/"},{"title":"【Spark】聚类分析","text":"本节主要讲Spark ML中关于聚类算法的实现。示例的算法Demo包含：K-means、LDA、高斯混合模型(GMM)等。 1. K-meansKMeans作为Estimator实现，并生成KMeansModel作为基本模型。 1.1 输入 Param name Type(s) Default Description featuresCol Vector “features” Feature vector 1.2 输出 Param name Type(s) Default Description predictionCol Int “prediction” Predicted cluster center 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-# @Time : 2019/8/8 15:52# @Author : buracagyang# @File : kmeans_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.clustering import KMeansfrom pyspark.ml.evaluation import ClusteringEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;KMeansExample&quot;).getOrCreate() dataset = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_kmeans_data.txt&quot;) kmeans = KMeans().setK(2).setSeed(1) model = kmeans.fit(dataset) predictions = model.transform(dataset) # 通过计算Silhouette得分来评估聚类 evaluator = ClusteringEvaluator() silhouette = evaluator.evaluate(predictions) print(&quot;Silhouette with squared euclidean distance = &quot; + str(silhouette)) centers = model.clusterCenters() print(&quot;Cluster Centers: &quot;) for center in centers: print(center) spark.stop() 结果如下： 1234Silhouette with squared euclidean distance = 0.999753030538Cluster Centers: [0.1 0.1 0.1][9.1 9.1 9.1] 2. 隐狄利克雷分布(Latent Dirichlet Allocation, LDA)LDA实现支持EMLDAOptimizer和OnlineLDAOptimizer的Estimator，并生成LDAModel作为基本模型。 如果需要，用户可以将EMLDAOptimizer生成的LDAModel转换为DistributedLDAModel。 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# @Time : 2019/8/8 15:57# @Author : buracagyang# @File : lda_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.clustering import LDAfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;LDAExample&quot;).getOrCreate() dataset = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_lda_libsvm_data.txt&quot;) lda = LDA(k=10, maxIter=10) model = lda.fit(dataset) ll = model.logLikelihood(dataset) lp = model.logPerplexity(dataset) print(&quot;The lower bound on the log likelihood of the entire corpus: &quot; + str(ll)) print(&quot;The upper bound on perplexity: &quot; + str(lp)) topics = model.describeTopics(3) print(&quot;The topics described by their top-weighted terms:&quot;) topics.show(truncate=False) transformed = model.transform(dataset) transformed.show(truncate=False) spark.stop() 结果如下： 1234567891011121314151617The lower bound on the log likelihood of the entire corpus: -819.009950373The upper bound on perplexity: 3.15003826823The topics described by their top-weighted terms:+-----+-----------+---------------------------------------------------------------+|topic|termIndices|termWeights |+-----+-----------+---------------------------------------------------------------+|0 |[5, 0, 4] |[0.15844458913187548, 0.14007374754187465, 0.13600455491609725]||1 |[4, 10, 1] |[0.10928579282605518, 0.10301239992895456, 0.10233720065679922]||2 |[7, 2, 8] |[0.09993621815412573, 0.0995604576055824, 0.09839140083978774] ||3 |[10, 6, 9] |[0.22028286673724704, 0.14180332771724063, 0.10480970083316132]||4 |[3, 1, 7] |[0.1069290730844232, 0.09913915882531774, 0.09829708091766262] ||5 |[8, 4, 3] |[0.10062018802985315, 0.10039557022704547, 0.09964881942009583]||6 |[7, 6, 8] |[0.10241014766676104, 0.10114682616315203, 0.09877798196420218]||7 |[3, 10, 4] |[0.23627099191080478, 0.11550793060134483, 0.09113132802908004]||8 |[2, 4, 10] |[0.11417002337049241, 0.09981723889288864, 0.09638496973844993]||9 |[1, 5, 3] |[0.11538963974318006, 0.10464760125021952, 0.09761099598591011]|+-----+-----------+---------------------------------------------------------------+ 3. 二分K-means(Bisecting K-means)二分k-means是一种使用分裂（或“自上而下”）方法的层次聚类：首先将所有点作为一个簇， 然后将该簇一分为二，递归地执行拆分。二分K-means通常比常规K-means快得多，但它通常会产生不同的聚类。 BisectingKMeans作为Estimator实现，并生成BisectingKMeansModel作为基本模型。 示例代码如下： 123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-# @Time : 2019/8/8 16:12# @Author : buracagyang# @File : bisecting_k_means_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.clustering import BisectingKMeansfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;BisectingKMeansExample&quot;).getOrCreate() dataset = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_kmeans_data.txt&quot;) bkm = BisectingKMeans().setK(2).setSeed(1) model = bkm.fit(dataset) cost = model.computeCost(dataset) print(&quot;Within Set Sum of Squared Errors = &quot; + str(cost)) print(&quot;Cluster Centers: &quot;) centers = model.clusterCenters() for center in centers: print(center) spark.stop() 结果如下： 1234Within Set Sum of Squared Errors = 0.12Cluster Centers: [0.1 0.1 0.1][9.1 9.1 9.1] 4. 混合高斯模型(Gaussian Mixture Model, GMM)高斯混合模型表示复合分布，其中从k个高斯子分布中的一个绘制点，每个子分布具有其自己的概率。 spark.ml实现使用期望最大化算法求解最大似然模型。 4.1 输入 Param name Type(s) Default Description featuresCol Vector “features” Feature vector 4.2 输出 Param name Type(s) Default Description predictionCol Int “prediction” Predicted cluster center probabilityCol Vector “probability” Probability of each cluster 示例代码如下： 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-# @Time : 2019/8/8 16:21# @Author : buracagyang# @File : gaussian_mixture_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.clustering import GaussianMixturefrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;GaussianMixtureExample&quot;).getOrCreate() dataset = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_kmeans_data.txt&quot;) gmm = GaussianMixture().setK(2).setSeed(1) model = gmm.fit(dataset) print(&quot;Gaussians shown as a DataFrame: &quot;) model.gaussiansDF.show(truncate=False) spark.stop() 结果如下： 123456789101112Gaussians shown as a DataFrame: +-------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|mean |cov |+-------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|[0.10000000000001552,0.10000000000001552,0.10000000000001552]|0.006666666666806454 0.006666666666806454 0.006666666666806454 0.006666666666806454 0.006666666666806454 0.006666666666806454 0.006666666666806454 0.006666666666806454 0.006666666666806454 ||[9.099999999999984,9.099999999999984,9.099999999999984] |0.006666666666812185 0.006666666666812185 0.006666666666812185 0.006666666666812185 0.006666666666812185 0.006666666666812185 0.006666666666812185 0.006666666666812185 0.006666666666812185 |+-------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+","link":"/2019/08/08/spark-clustering/"},{"title":"【Spark】协同过滤","text":"协同过滤通常用于推荐系统。这些技术旨在根据user-item关联矩阵的缺失条目。 spark.ml目前支持基于模型的协同过滤，其中users和items由一小组可用于预测缺失条目的潜在因子（latent factors）描述。 spark.ml使用交替最小二乘（ALS）算法来学习这些潜在因素。 spark.ml中的实现具有以下参数： numBlocks，是users和items将被分区为多个块的数量，以便并行化计算（默认为10）。 rank，是模型中潜在因子（latent factors）的数量（默认为10）。 maxIter，是要运行的最大迭代次数（默认为10）。 regParam，指定ALS中的正则化参数（默认为1.0）。 implicitPrefs，指定是使用显式反馈ALS变体还是使用适用于隐式反馈数据的（默认为false，这意味着使用显式反馈）。 alpha，是适用于ALS的隐式反馈变量的参数，其控制偏好观察中的基线置信度（默认为1.0）。 nonnegative，指定是否对最小二乘使用非负约束（默认为false）。 注意：基于DataFrame的ALS API目前仅支持整数类型的user和item ID。 1. 显式和隐式反馈基于矩阵分解的协同过滤的标准方法将user-item矩阵中的数据视为user对item给出的显式偏好，例如，给予电影评级的用户。 在许多现实世界的用例中，通常只能访问隐式反馈（例如，观看，点击，购买，喜欢，分享等）。 spark.ml中用于处理此类数据的方法取自Collaborative Filtering for Implicit Feedback Datasets。 本质上，这种方法不是试图直接对评级矩阵进行建模，而是将数据视为表示用户操作观察强度的数字（例如点击次数或某人花在观看电影上的累积持续时间）。 然后，这些数字与观察到的用户偏好的置信水平相关，而不是与item的明确评级相关。 然后，该模型试图找到可用于预测user对item的预期偏好的潜在因素。 2. 正则化参数的缩放我们通过用户在更新用户因素（user factors）时产生的评级数或在更新产品因素（product factors）时收到的产品评级数来缩小正则化参数regParam以解决每个最小二乘问题。 这种方法被命名为“ALS-WR”，并在“Large-Scale Parallel Collaborative Filtering for the Netflix Prize”一文中进行了讨论。 它使regParam较少依赖于数据集的规模，因此我们可以将从采样子集中学习的最佳参数应用于完整数据集，并期望获得类似的性能。 3. 冷启动的策略在使用ALSModel进行预测时，通常会遇到测试数据集中的user或者item在训练模型期间不存在。这通常发生在两种情况中： 在生产中，对于没有评级历史且未对模型进行过训练的新user或item（这是“冷启动问题”）。 在交叉验证期间，数据在训练和评估集之间分配。当使用Spark的CrossValidator或TrainValidationSplit中的简单随机拆分时，实际上很常见的是在评估集中遇到不在训练集中的user 或 item。 默认情况下，当模型中不存在user or item factors时，Spark会在ALSModel.transform期间分配NaN预测。这在生产系统中很有用，因为它表示新用户或项目，因此系统可以决定使用某些后备作为预测。 但是，这在交叉验证期间是不合需要的，因为任何NaN预测值都将导致评估指标的NaN结果（例如，使用RegressionEvaluator时）。这使得模型选择不可能。 Spark允许用户将coldStartStrategy参数设置为“drop”，以便删除包含NaN值的预测的DataFrame中的任何行。然后将根据非NaN数据计算评估度量并且该评估度量将是有效的。以下示例说明了此参数的用法。 注意：目前支持的冷启动策略是“nan”（上面提到的默认行为）和“drop”。将来可能会支持更多的策略。 在以下示例中，我们从MovieLens数据集加载评级数据，每行包含用户，电影，评级和时间戳。 然后我们训练一个ALS模型，默认情况下假设评级是显式的（implicitPrefs是False）。 我们通过测量评级预测的均方根误差来评估推荐模型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-# @Time : 2019/8/8 19:40# @Author : buracagyang# @File : als_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.sql import SparkSessionfrom pyspark.ml.evaluation import RegressionEvaluatorfrom pyspark.ml.recommendation import ALSfrom pyspark.sql import Rowif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;ALSExample&quot;).getOrCreate() lines = spark.read.text(&quot;../data/mllib/als/sample_movielens_ratings.txt&quot;).rdd parts = lines.map(lambda row: row.value.split(&quot;::&quot;)) ratingsRDD = parts.map(lambda p: Row(userId=int(p[0]), movieId=int(p[1]), rating=float(p[2]), timestamp=long(p[3]))) ratings = spark.createDataFrame(ratingsRDD) (training, test) = ratings.randomSplit([0.8, 0.2]) # 冷启动策略使用&quot;drop&quot;，不对NaN进行评估 als = ALS(maxIter=5, regParam=0.01, userCol=&quot;userId&quot;, itemCol=&quot;movieId&quot;, ratingCol=&quot;rating&quot;, coldStartStrategy=&quot;drop&quot;) model = als.fit(training) predictions = model.transform(test) evaluator = RegressionEvaluator(metricName=&quot;rmse&quot;, labelCol=&quot;rating&quot;, predictionCol=&quot;prediction&quot;) rmse = evaluator.evaluate(predictions) print(&quot;Root-mean-square error = &quot; + str(rmse)) # 对每个用户推荐top 10的movie userRecs = model.recommendForAllUsers(10) # 对每部电影推荐top 10的user movieRecs = model.recommendForAllItems(10) # 为指定的用户组推荐top 10的电影 users = ratings.select(als.getUserCol()).distinct().limit(3) userSubsetRecs = model.recommendForUserSubset(users, 10) # 为指定的电影组推荐top 10的用户 movies = ratings.select(als.getItemCol()).distinct().limit(3) movieSubSetRecs = model.recommendForItemSubset(movies, 10) userRecs.show(10) movieRecs.show(10) userSubsetRecs.show() movieSubSetRecs.show() spark.stop() 结果如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Root-mean-square error = 1.65962683297+------+--------------------+|userId| recommendations|+------+--------------------+| 28|[[92, 4.7627287],...|| 26|[[22, 5.353035], ...|| 27|[[75, 4.7605653],...|| 12|[[12, 5.364489], ...|| 22|[[51, 5.1232195],...|| 1|[[34, 6.5673475],...|| 13|[[93, 3.92995], [...|| 6|[[25, 5.123874], ...|| 16|[[85, 5.03955], [...|| 3|[[51, 4.974762], ...|+------+--------------------+only showing top 10 rows+-------+--------------------+|movieId| recommendations|+-------+--------------------+| 31|[[28, 3.4169104],...|| 85|[[16, 5.03955], [...|| 65|[[23, 4.9267926],...|| 53|[[23, 6.9966245],...|| 78|[[24, 1.1653752],...|| 34|[[1, 6.5673475], ...|| 81|[[11, 4.0272694],...|| 28|[[18, 4.8363395],...|| 76|[[14, 4.6251163],...|| 26|[[12, 4.3116484],...|+-------+--------------------+only showing top 10 rows+------+--------------------+|userId| recommendations|+------+--------------------+| 26|[[22, 5.353035], ...|| 19|[[98, 3.8704958],...|| 29|[[30, 4.1840963],...|+------+--------------------++-------+--------------------+|movieId| recommendations|+-------+--------------------+| 65|[[23, 4.9267926],...|| 26|[[12, 4.3116484],...|| 29|[[8, 4.954544], [...|+-------+--------------------+ 如果评级矩阵是从另一个信息源派生的（即从其他信号推断出来），您可以将implicitPrefs设置为True以获得更好的结果： 1als = ALS(maxIter=5, regParam=0.01, implicitPrefs=True, userCol=&quot;userId&quot;, itemCol=&quot;movieId&quot;, ratingCol=&quot;rating&quot;)","link":"/2019/08/08/spark-collaborative-filtering/"},{"title":"【Spark】特征工程1-Extractors","text":"Spark MLlib中关于特征处理的相关算法，大致分为以下几组： 提取(Extraction)：从“原始”数据中提取特征 转换(Transformation)：缩放，转换或修改特征 选择(Selection)：从较大的一组特征中选择一个子集 局部敏感哈希(Locality Sensitive Hashing，LSH)：这类算法将特征变换的各个方面与其他算法相结合。 本文介绍第一组： 特征提取器(Extractors) 1. 特诊提取器1.1 TF-IDF词频-逆文本频率(Term frequency-inverse document frequency, (TF-IDF)是在文本挖掘中广泛使用的特征向量化方法，以反映术语对语料库中的文档的重要性。 用t表示一个术语，用d表示一个文件，用D表示语料库。词频TF(t，d)是术语t出现在文件d中的次数，而文档频率DF(t，D)是包含术语t的文件数量。 如果我们仅使用词频来衡量重要性，那么过分强调经常出现但很少提供有关文档的信息的术语非常容易，例如： “a”，“the”和“of”。 如果词语在语料库中经常出现，则表示它不包含有关特定文档的特殊信息。 逆向文档频率是词语提供的信息量的数字度量： IDF(t,D) = log\\frac{|D| + 1}{DF(t,D) + 1}其中|D|是语料库中的文档总数。 由于使用了对数log，如果一个术语出现在所有文档中，其IDF值将变为0。请注意，应用平滑词语以避免语料库外的术语除以零。 TF-IDF指标只是TF和IDF的产物： TF-IDF = TF(t,d) \\times IDF(t,D)词频和文档频率的定义有几种变体。 在MLlib中，我们将TF和IDF分开以使其灵活。 TF：HashingTF和CountVectorizer都可用于生成术语频率向量。 HashingTF是一个Transformer，它接受一组词语并将这些集合转换为固定长度的特征向量。在文本处理中，“一组词语”可能是一个单词集合。 HashingTF利用散列技巧。通过应用散列函数将原始特征映射到索引。这里使用的哈希函数是MurmurHash 3.然后，基于映射的索引计算术语频率。这种方法避免了计算全局词语到索引映射的需要，这对于大型语料库来说可能是昂贵的，但它遭受潜在的哈希冲突，其中不同的原始特征可能在散列之后变成相同的词语。为了减少冲突的可能性，我们可以增加目标特征维度，即哈希表的桶的数量。由于散列值的简单模数用于确定向量索引，因此建议使用2的幂作为要素维度，否则要素将不会均匀映射到向量索引。默认要素尺寸为$2^{18} = 262,144$。可选的二进制切换参数控制术语频率计数。设置为true时，所有非零频率计数都设置为1.这对于模拟二进制而非整数计数的离散概率模型特别有用。 CountVectorizer将文本文档转换为词语计数向量。 IDF：IDF是一个Estimator，它训练数据集并生成IDFModel。 IDFModel采用特征向量（通常从HashingTF或CountVectorizer创建）并缩放每个特征。 直观地，它降低了在语料库中频繁出现的特征。 举例 在下面的代码中(基于Python)，Scala和Java的示例还请参照这里；我们从一组句子开始。 我们使用Tokenizer将每个句子分成单词。 对于每个句子，我们使用HashingTF将句子散列为特征向量。 我们使用IDF重新缩放特征向量; 这通常会在使用文本作为功能时提高性能。 然后我们的特征向量可以传递给学习算法。 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-# @Time : 2019/7/31 14:03# @Author : buracagyang# @File : tf_idf_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import HashingTF, IDF, Tokenizerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;TfIdfExample&quot;)\\ .getOrCreate() sentenceData = spark.createDataFrame([ (0.0, &quot;Hi I heard about Spark&quot;), (0.0, &quot;I wish Java could use case classes&quot;), (1.0, &quot;Logistic regression models are neat&quot;) ], [&quot;label&quot;, &quot;sentence&quot;]) tokenizer = Tokenizer(inputCol=&quot;sentence&quot;, outputCol=&quot;words&quot;) wordsData = tokenizer.transform(sentenceData) hashingTF = HashingTF(inputCol=&quot;words&quot;, outputCol=&quot;rawFeatures&quot;, numFeatures=20) featurizedData = hashingTF.transform(wordsData) # 也可以选择CountVectorizer得到一个词频向量 idf = IDF(inputCol=&quot;rawFeatures&quot;, outputCol=&quot;features&quot;) idfModel = idf.fit(featurizedData) rescaledData = idfModel.transform(featurizedData) rescaledData.select(&quot;label&quot;, &quot;features&quot;).show() spark.stop() 结果如下： 1234567+-----+--------------------+|label| features|+-----+--------------------+| 0.0|(20,[0,5,9,17],[0...|| 0.0|(20,[2,7,9,13,15]...|| 1.0|(20,[4,6,13,15,18...|+-----+--------------------+ 1.2 Word2VecWord2Vec是一个Estimator，它采用代表文档的单词序列并训练Word2VecModel。 该模型将每个单词映射到一个唯一的固定大小的向量。 Word2VecModel使用文档中所有单词的平均值将每个文档转换为向量; 然后，此向量可用作预测，文档相似度计算等功能。 举例 我们从一组文档开始，每个文档都表示为一系列单词。 对于每个文档，我们将其转换为特征向量。 然后可以将该特征向量传递给学习算法： 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-# @Time : 2019/7/31 14:09# @Author : buracagyang# @File : word2vec_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import Word2Vecfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;Word2VecExample&quot;)\\ .getOrCreate() # 输入数据: 每行是一个句子或文档中的单词集合。 documentDF = spark.createDataFrame([ (&quot;Hi I heard about Spark&quot;.split(&quot; &quot;), ), (&quot;I wish Java could use case classes&quot;.split(&quot; &quot;), ), (&quot;Logistic regression models are neat&quot;.split(&quot; &quot;), ) ], [&quot;text&quot;]) # 从单词到向量的映射。 word2Vec = Word2Vec(vectorSize=3, minCount=0, inputCol=&quot;text&quot;, outputCol=&quot;result&quot;) model = word2Vec.fit(documentDF) result = model.transform(documentDF) for row in result.collect(): text, vector = row print(&quot;Text: [%s] =&gt; \\nVector: %s\\n&quot; % (&quot;, &quot;.join(text), str(vector))) spark.stop() 结果如下： 12345678Text: [Hi, I, heard, about, Spark] =&gt; Vector: [0.010823638737201692,-0.005407899245619774,-0.02091031074523926]Text: [I, wish, Java, could, use, case, classes] =&gt; Vector: [0.04387364802615983,0.028466253940548213,-0.02133789997813957]Text: [Logistic, regression, models, are, neat] =&gt; Vector: [0.054717136174440385,0.009467959217727185,0.034012694098055365] 1.3 CountVectorizerCountVectorizer和CountVectorizerModel旨在帮助将文本文档集合转换为计数向量(vectors of token counts)。当a-priori字典不可用时，CountVectorizer可用作Estimator来提取词汇表，并生成CountVectorizerModel。该模型为词汇表上的文档生成稀疏表示，然后可以将其传递给其他算法，如LDA。 在拟合过程中，CountVectorizer将选择按语料库中的术语频率排序的顶级词汇量词。可选参数minDF还通过指定词语必须出现在文档中的最小数量（或&lt;1.0）来影响拟合过程。另一个可选的二进制切换参数控制输出向量。如果设置为true，则所有非零计数都设置为1.这对于模拟二进制而非整数计数的离散概率模型尤其有用。 举例 假设我们有以下DataFrame，其中包含列id和文本： 1234 id | texts----|---------- 0 | Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) 1 | Array(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;) 文本中的每一行都是Array [String]类型的文档。 调用CountVectorizer的拟合会生成带有词汇表（a，b，c）的CountVectorizerModel。 然后转换后的输出列“vector”包含： 1234 id | texts | vector----|---------------------------------|--------------- 0 | Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) | (3,[0,1,2],[1.0,1.0,1.0]) 1 | Array(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;) | (3,[0,1,2],[2.0,2.0,1.0]) 每个向量表示文档在词汇表中的词语计数(id 0: ‘a’, ‘b’, ‘c’各出现一次；id1: ‘a’, ‘b’, ‘c’各出现2， 2， 1次)。 1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-# @Time : 2019/7/31 14:24# @Author : buracagyang# @File : count_vectorizer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.sql import SparkSessionfrom pyspark.ml.feature import CountVectorizerif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;CountVectorizerExample&quot;)\\ .getOrCreate() df = spark.createDataFrame([ (0, &quot;a b c&quot;.split(&quot; &quot;)), (1, &quot;a b b c a&quot;.split(&quot; &quot;)) ], [&quot;id&quot;, &quot;words&quot;]) # 用语料库拟合一个CountVectorizerModel cv = CountVectorizer(inputCol=&quot;words&quot;, outputCol=&quot;features&quot;, vocabSize=3, minDF=2.0) model = cv.fit(df) result = model.transform(df) result.show(truncate=False) spark.stop() 结果如下： 123456+---+---------------+-------------------------+|id |words |features |+---+---------------+-------------------------+|0 |[a, b, c] |(3,[0,1,2],[1.0,1.0,1.0])||1 |[a, b, b, c, a]|(3,[0,1,2],[2.0,2.0,1.0])|+---+---------------+-------------------------+ 1.4 FeatureHasher特征散列(Feature Hashing)将一组分类或数字特征映射到指定尺寸的特征向量中（通常远小于原始特征空间的特征向量）。这是使用散列技巧将要素映射到特征向量中的索引来完成的。 FeatureHasher转换器在多个特征上运行。每个特征可能是数值特征或分类特征。不同数据类型的处理方法如下： 数值特征：对于数值特征，特征名称的哈希值用于将值映射到向量中的索引。默认情况下，数值元素不被视为分类属性（即使它们是整数）。要将它们视为分类属性，请使用categoricalCols参数指定相关列。 字符串(属性)特征：对于属性特征，字符串“column_name = value”的哈希值用于映射到矢量索引，指示符值为1.0。因此，属性特征是“one-hot”编码的（类似于使用具有dropLast = false的OneHotEncoder）。 布尔特征：布尔值的处理方式与字符串特征相同。也就是说，布尔特征表示为“column_name = true”或“column_name = false”，指标值为1.0。 忽略空（缺失）值（在结果特征向量中隐式为零）。 这里使用的哈希函数也是HashingTF中使用的MurmurHash 3。由于散列值的简单模数用于确定向量索引，因此建议使用2的幂作为numFeatures参数;否则，特征将不会均匀地映射到矢量索引。 举例 假设我们有一个DataFrame，其中包含4个输入列real，bool，stringNum和string。这些不同的数据类型作为输入将说明变换的行为以产生一列特征向量。 123456real| bool|stringNum|string----|-----|---------|------ 2.2| true| 1| foo 3.3|false| 2| bar 4.4|false| 3| baz 5.5|false| 4| foo 训练过程示例： 123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-# @Time : 2019/7/31 14:34# @Author : buracagyang# @File : feature_hasher_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.sql import SparkSessionfrom pyspark.ml.feature import FeatureHasherif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;FeatureHasherExample&quot;)\\ .getOrCreate() dataset = spark.createDataFrame([ (2.2, True, &quot;1&quot;, &quot;foo&quot;), (3.3, False, &quot;2&quot;, &quot;bar&quot;), (4.4, False, &quot;3&quot;, &quot;baz&quot;), (5.5, False, &quot;4&quot;, &quot;foo&quot;) ], [&quot;real&quot;, &quot;bool&quot;, &quot;stringNum&quot;, &quot;string&quot;]) hasher = FeatureHasher(inputCols=[&quot;real&quot;, &quot;bool&quot;, &quot;stringNum&quot;, &quot;string&quot;], outputCol=&quot;features&quot;) featurized = hasher.transform(dataset) featurized.show(truncate=False) spark.stop() 结果如下： 12345678+----+-----+---------+------+--------------------------------------------------------+|real|bool |stringNum|string|features |+----+-----+---------+------+--------------------------------------------------------+|2.2 |true |1 |foo |(262144,[174475,247670,257907,262126],[2.2,1.0,1.0,1.0])||3.3 |false|2 |bar |(262144,[70644,89673,173866,174475],[1.0,1.0,1.0,3.3]) ||4.4 |false|3 |baz |(262144,[22406,70644,174475,187923],[1.0,1.0,4.4,1.0]) ||5.5 |false|4 |foo |(262144,[70644,101499,174475,257907],[1.0,1.0,5.5,1.0]) |+----+-----+---------+------+--------------------------------------------------------+ 然后可以将得到的特征向量传递给学习算法。","link":"/2019/07/30/spark-features-project-1/"},{"title":"【Spark】频繁项集挖掘","text":"挖掘频繁项目，项目集，子序列或其他子结构通常是分析大规模数据集的第一步，这是数据挖掘多年来一直活跃的研究课题。 可以参考一下维基百科中关于关联规则学习的基础知识。 1. FP-GrowthFP-growth算法在Han等人的文章中描述，挖掘频繁模式而没有候选生成，其中“FP”代表频繁模式。 给定数据集，FP-growth的第一步是计算项目频率并识别频繁项目。 与为同一目的而设计的类似Apriori的算法不同，FP-growth的第二步使用后缀树（FP-tree）结构来编码事务而不显式生成候选集，这通常很难生成。 在第二步之后，可以从FP-tree中提取频繁项集。 在spark.mllib中，我们实现了称为PFP的FP-growth的分布式版本，如Li等人，在PFP：Parallel FP-growth for query recommendation中所述。 PFP基于事务的后缀分配增长FP-tree的工作，因此比单机实现更具可扩展性。 spark.ml的FP-growth实现采用以下（超）参数： minSupport：对项目集进行频繁识别的最低支持。例如，如果一个项目出现在5个交易中的3个中，则它具有3/5 = 0.6的支持。 minConfidence：生成关联规则的最小置信度。置信度表明关联规则经常被发现的频率。例如，如果在交易项目集X中出现4次，X和Y仅出现2次，则规则X =&gt; Y的置信度则为2/4 = 0.5。该参数不会影响频繁项集的挖掘，但会指定从频繁项集生成关联规则的最小置信度。 numPartitions：用于并行工作的分区数。默认情况下，不设置参数，并使用输入数据集的分区数。 FPGrowthModel提供： freqItemsets：DataFrame格式的频繁项集（“items”[Array]，“freq”[Long]） associationRules：以高于minConfidence的置信度生成的关联规则，格式为DataFrame（“antecedent”[Array]，“consequent”[Array]，“confidence”[Double]）。 transform：对于itemsCol中的每个事务，transform方法将其项目与每个关联规则的前提进行比较。如果记录包含特定关联规则的所有前提，则该规则将被视为适用，并且其结果将被添加到预测结果中。变换方法将所有适用规则的结果总结为预测。预测列与itemsCol具有相同的数据类型，并且不包含itemsCol中的现有项。 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# @Time : 2019/8/9 10:40# @Author : buracagyang# @File : fpgrowth_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from pyspark.ml.fpm import FPGrowthfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;FPGrowthExample&quot;).getOrCreate() df = spark.createDataFrame([ (0, [1, 2, 5]), (1, [1, 2, 3, 5]), (2, [1, 2]) ], [&quot;id&quot;, &quot;items&quot;]) fpGrowth = FPGrowth(itemsCol=&quot;items&quot;, minSupport=0.5, minConfidence=0.6) model = fpGrowth.fit(df) # 频繁项集 model.freqItemsets.show() # 生成的关联规则 model.associationRules.show() # transform根据所有关联规则检查输入项，并将结果作为预测 model.transform(df).show() spark.stop() 结果如下： 123456789101112131415161718192021222324252627282930313233+---------+----+| items|freq|+---------+----+| [1]| 3|| [2]| 3|| [2, 1]| 3|| [5]| 2|| [5, 2]| 2||[5, 2, 1]| 2|| [5, 1]| 2|+---------+----++----------+----------+------------------+|antecedent|consequent| confidence|+----------+----------+------------------+| [5, 2]| [1]| 1.0|| [2, 1]| [5]|0.6666666666666666|| [5, 1]| [2]| 1.0|| [5]| [2]| 1.0|| [5]| [1]| 1.0|| [1]| [2]| 1.0|| [1]| [5]|0.6666666666666666|| [2]| [1]| 1.0|| [2]| [5]|0.6666666666666666|+----------+----------+------------------++---+------------+----------+| id| items|prediction|+---+------------+----------+| 0| [1, 2, 5]| []|| 1|[1, 2, 3, 5]| []|| 2| [1, 2]| [5]|+---+------------+----------+","link":"/2019/08/09/spark-frequent-pattern-mining/"},{"title":"【Spark】Pipelines","text":"在本节中，我们将介绍ML Pipelines的概念。 ML Pipelines提供了一组基于DataFrame构建的统一的高级API，可帮助用户创建和调整实用的机器学习流程。 1. 管道中的主要概念MLlib标准化用于机器学习算法的API，以便更轻松地将多个算法组合到单个管道或工作流程中。本节介绍Pipelines API引入的关键概念，其中管道概念主要受到scikit-learn项目的启发。 DataFrame：此ML API使用Spark SQL中的DataFrame作为ML数据集，它可以包含各种数据类型。例如，DataFrame可以具有存储文本，特征向量，标签(true labels)和预测的不同列。 Transformer：Transformer是一种可以将一个DataFrame转换为另一个DataFrame的算法。例如，ML模型是变换器，其将具有特征的DataFrame转换为具有预测的DataFrame。 Estimator：Estimator是一种算法，可以适应DataFrame以生成Transformer。例如，学习算法是Estimator，其在DataFrame上训练并产生模型。 Pipeline：管道将多个Transformers和Estimators链接在一起以指定ML工作流程。 参数：所有Transformers和Estimators现在共享一个用于指定参数的通用API。 1.1 DataFrame机器学习可以应用于各种数据类型，例如矢量，文本，图像和结构化数据。 此API采用Spark SQL的DataFrame以支持各种数据类型。 DataFrame支持许多基本和结构化类型; 有关支持的类型列表，请参阅Spark SQL数据类型参考。 除了Spark SQL指南中列出的类型之外，DataFrame还可以使用ML Vector类型。 可以从常规RDD隐式或显式创建DataFrame。 有关示例，请参阅下面的代码示例和Spark SQL编程指南。 DataFrame中的列已命名。 下面的代码示例使用诸如“text”，“features”和“label”之类的名称。 1.2 Pipeline 组件1.2.1 TransformersTransformer是一种抽象，包括特征变换器和学习模型。 从技术上讲，Transformer实现了一个方法transform（），它通常通过附加一个或多个列将一个DataFrame转换为另一个DataFrame。 例如： 特征变换器可以采用DataFrame，读取列（例如，文本），将其映射到新列（例如，特征向量），并输出附加了映射列的新DataFrame。 学习模型可以采用DataFrame，读取包含特征向量的列，预测每个要素向量的标签，并输出新的DataFrame，其中预测标签作为列附加。 1.2.2 Estimators估计器抽象学习算法或适合或训练数据的任何算法的概念。 从技术上讲，Estimator实现了一个方法fit()，它接受一个DataFrame并生成一个Model，它是一个Transformer。 例如，诸如LogisticRegression之类的学习算法是Estimator，并且调用fit()训练LogisticRegressionModel，LogisticRegressionModel是Model并因此是Transformer。 1.2.3 Pipeline组件的属性Transformer.transform（）和Estimator.fit（）都是无状态的。 将来，可以通过替代概念支持有状态算法。 Transformer或Estimator的每个实例都有一个唯一的ID，可用于指定参数（如下所述）。 1.3 Pipeline在机器学习中，通常运行一系列算法来处理和学习数据。 例如，简单的文本文档处理工作流程可能包括几个阶段： 将每个文档的文本拆分为单词。 将每个文档的单词转换为数字特征向量。 使用特征向量和标签学习预测模型。 MLlib将此类工作流表示为管道，其由一系列以特定顺序运行的PipelineStages（变换器和估算器）组成。我们将在本节中将此简单工作流用作运行示例。 1.3.1 运行原理管道被指定为不同阶段的序列，并且每个阶段是变换器或估计器。 这些阶段按顺序运行，输入DataFrame在通过每个阶段时进行转换。 对于Transformer阶段，在DataFrame上调用transform()方法。 对于Estimator阶段，调用fit()方法以生成Transformer（它成为PipelineModel或拟合管道的一部分），并在DataFrame上调用Transformer的transform()方法。 我们为简单的文本文档工作流说明了这一点。 下图是管道的训练时间使用情况。 上图中，顶行表示具有三个阶段的管道。前两个（Tokenizer和HashingTF）是TransformerS（蓝色），第三个（LogisticRegression）是Estimator（红色）。底行表示流经管道的数据，其中柱面表示DataFrame。在原始DataFrame上调用Pipeline.fit()方法，该原始DataFrame具有原始文本文档和标签。 Tokenizer.transform()方法将原始文本文档拆分为单词，向DataFrame添加一个带有单词的新列。 HashingTF.transform()方法将单词列转换为要素向量，将包含这些向量的新列添加到DataFrame。现在，由于LogisticRegression是一个Estimator，因此Pipeline首先调用LogisticRegression.fit()来生成LogisticRegressionModel。如果Pipeline有更多的Estimators，它会在将DataFrame传递给下一个阶段之前在DataFrame上调用LogisticRegressionModel的transform()方法。 一个Pipeline是Estimator。因此，在Pipeline的fit()方法运行之后，它会生成一个PipelineModel，它是一个Transformer。这个PipelineModel在测试时使用;下图说明了这种用法。 在上图中，PipelineModel具有与原始Pipeline相同的阶段数，但原始Pipeline中的所有Estimators都变为Transformers。 当在测试数据集上调用PipelineModel的transform()方法时，数据将按顺序通过拟合的管道传递。 每个阶段的transform()方法都会更新数据集并将其传递给下一个阶段。 Pipelines和PipelineModel有助于确保训练和测试数据经过相同的功能处理步骤。 1.3.2 详细过程DAG PipelineS：管道的阶段被指定为有序数组。这里给出的例子都是线性管道(linear PipelineS)，即其中每个阶段的管道使用前一阶段产生的数据。只要数据流图形成有向无环图（DAG），就可以创建非线性管道。目前，此图基于每个阶段的输入和输出列名称（通常指定为参数）隐式指定。如果管道形成DAG，则必须按拓扑顺序指定阶段。 运行时检查：由于Pipelines可以在具有不同类型的DataFrame上运行，因此它们不能使用编译时类型检查。 Pipelines和PipelineModels代替在实际运行Pipeline之前进行运行时检查。此类型检查是使用DataFrame模式完成的，DataFrame模式是DataFrame中列的数据类型的描述。 独特的管道阶段：管道的阶段应该是唯一的实例。例如，由于Pipeline阶段必须具有唯一ID，因此不应将相同的实例myHashingTF插入到Pipeline中两次。但是，不同的实例myHashingTF1和myHashingTF2（都是HashingTF类型）可以放在同一个管道中，因为将使用不同的ID创建不同的实例。 1.4 参数MLlib Estimators和Transformers使用统一的API来指定参数。 Param是一个带有自包含文档的命名参数。 ParamMap是一组（参数，值）对。 将参数传递给算法有两种主要方法： 设置实例的参数。 例如，如果lr是LogisticRegression的实例，则可以调用lr.setMaxIter(10)以使lr.fit()最多使用10次迭代。 此API类似于spark.mllib包中使用的API。 将ParamMap传递给fit()或transform()。 ParamMap中的任何参数都将覆盖先前通过setter方法指定的参数。 参数属于Estimators和Transformers的特定实例。 例如，如果我们有两个LogisticRegression实例lr1和lr2，那么我们可以构建一个指定了两个maxIter参数的ParamMap：ParamMap（lr1.maxIter - &gt; 10，lr2.maxIter - &gt; 20）。 如果管道中有两个带有maxIter参数的算法，这将非常有用。 1.5 ML持久性:保存和加载管道通常，将模型或管道保存到磁盘以供以后使用是值得的。 在Spark 1.6中，模型导入/导出功能已添加到Pipeline API中。 从Spark 2.3开始，spark.ml和pyspark.ml中基于DataFrame的API具有完整的覆盖范围。 ML持久性适用于Scala，Java和Python。 但是，R当前使用的是修改后的格式，因此保存在R中的模型只能加载回R; 这应该在将来修复，并在SPARK-15572中进行跟踪。 1.5.1 ML持久性的向后兼容性通常，MLlib保持ML持久性的向后兼容性。即，如果您在一个版本的Spark中保存ML模型或Pipeline，那么您应该能够将其加载回来并在将来的Spark版本中使用它。但是，极少数例外情况如下所述。 模型持久性：Spark版本Y可以加载Spark版本X中使用Apache Spark ML持久性保存模型或管道吗？ 主要版本：没有保证，但是尽力而为。 次要和补丁版本：是的;这些是向后兼容的。 关于格式的注意事项：不保证稳定的持久性格式，但模型加载本身设计为向后兼容。 模型行为：Spark版本X中的模型或管道在Spark版本Y中的行为是否相同？ 主要版本：没有保证，但是尽力而为。 次要和补丁版本：相同的行为，除了错误修复。 对于模型持久性和模型行为，在Spark版本发行说明中报告了次要版本或修补程序版本的任何重大更改。如果发行说明中未报告破损，则应将其视为要修复的错误。 2. 代码示例本节给出了说明上述功能的代码示例(仅仅附上基于Python的示例代码)。 有关详细信息，请参阅这里。 2.1 示例：Estimator，Transformer和Param此示例涵盖Estimator，Transformer和Param的概念。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding: utf-8 -*-# @Time : 2019/7/30 17:01# @Author : buracagyang# @File : estimator_transformer_param_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.linalg import Vectorsfrom pyspark.ml.classification import LogisticRegressionfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;EstimatorTransformerParamExample&quot;)\\ .getOrCreate() # 从（标签，功能）元组列表中准备训练数据。 training = spark.createDataFrame([ (1.0, Vectors.dense([0.0, 1.1, 0.1])), (0.0, Vectors.dense([2.0, 1.0, -1.0])), (0.0, Vectors.dense([2.0, 1.3, 1.0])), (1.0, Vectors.dense([0.0, 1.2, -0.5]))], [&quot;label&quot;, &quot;features&quot;]) # 创建LogisticRegression实例。 这个实例是一个Estimator。 lr = LogisticRegression(maxIter=10, regParam=0.01) print(&quot;LogisticRegression parameters:\\n&quot; + lr.explainParams() + &quot;\\n&quot;) # ########################################### # 使用默认参数训练 LogisticRegression。 model1 = lr.fit(training) # ########################################### # 由于model1是模型（即由Estimator生成的transformer），我们可以查看fit()期间使用的参数。 # 这将打印参数（name: value）对，其中names是LogisticRegression实例的唯一ID print(&quot;Model 1 was fit using parameters: &quot;) print(model1.extractParamMap()) # ########################################### # 我们也可以使用字典作为paramMap指定参数 paramMap = {lr.maxIter: 20} paramMap[lr.maxIter] = 30 # overwriting paramMap.update({lr.regParam: 0.1, lr.threshold: 0.55}) # Specify multiple Params. # 你可以组合paramMaps，它们是dict paramMap2 = {lr.probabilityCol: &quot;myProbability&quot;} # 改变输出的列名 paramMapCombined = paramMap.copy() paramMapCombined.update(paramMap2) # 现在使用paramMapCombined参数学习一个新模型。 # paramMapCombined通过lr.set *方法覆盖之前设置的所有参数。 model2 = lr.fit(training, paramMapCombined) print(&quot;Model 2 was fit using parameters: &quot;) print(model2.extractParamMap()) # ########################################### test = spark.createDataFrame([ (1.0, Vectors.dense([-1.0, 1.5, 1.3])), (0.0, Vectors.dense([3.0, 2.0, -0.1])), (1.0, Vectors.dense([0.0, 2.2, -1.5]))], [&quot;label&quot;, &quot;features&quot;]) # 使用Transformer.transform()方法对测试数据进行预测。LogisticRegression.transform只会使用“features”列。 # 请注意，model2.transform（）输出“myProbability”列而不是通常的'probability'列，因为我们先前重命名了lr.probabilityCol参数。 prediction = model2.transform(test) result = prediction.select(&quot;features&quot;, &quot;label&quot;, &quot;myProbability&quot;, &quot;prediction&quot;).collect() for row in result: print(&quot;features=%s, label=%s -&gt; prob=%s, prediction=%s&quot; % (row.features, row.label, row.myProbability, row.prediction)) spark.stop() 如上代码在windows 10 | Pycharm | Spark 2.3.2中测试通过。中间日志很多，只附上最后的预测结果： 123features=[-1.0,1.5,1.3], label=1.0 -&gt; prob=[0.057073041710340174,0.9429269582896599], prediction=1.0features=[3.0,2.0,-0.1], label=0.0 -&gt; prob=[0.9238522311704104,0.07614776882958973], prediction=0.0features=[0.0,2.2,-1.5], label=1.0 -&gt; prob=[0.10972776114779419,0.8902722388522057], prediction=1.0 2.2 示例： Pipeline此示例遵循上图中所示的简单文本文档Pipeline。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-# @Time : 2019/7/30 17:16# @Author : buracagyang# @File : pipeline_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from pyspark.ml import Pipelinefrom pyspark.ml.classification import LogisticRegressionfrom pyspark.ml.feature import HashingTF, Tokenizerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;PipelineExample&quot;)\\ .getOrCreate() # 从（id,text,label）元组列表中准备训练数据。 training = spark.createDataFrame([ (0, &quot;a b c d e spark&quot;, 1.0), (1, &quot;b d&quot;, 0.0), (2, &quot;spark f g h&quot;, 1.0), (3, &quot;hadoop mapreduce&quot;, 0.0)], [&quot;id&quot;, &quot;text&quot;, &quot;label&quot;]) # 配置ML管道，包括三个阶段：tokenizer，hashingTF和lr。 tokenizer = Tokenizer(inputCol=&quot;text&quot;, outputCol=&quot;words&quot;) hashingTF = HashingTF(inputCol=tokenizer.getOutputCol(), outputCol=&quot;features&quot;) lr = LogisticRegression(maxIter=10, regParam=0.001) pipeline = Pipeline(stages=[tokenizer, hashingTF, lr]) # pipeline # Fit 训练文档 model = pipeline.fit(training) # 测试 test = spark.createDataFrame([ (4, &quot;spark i j k&quot;), (5, &quot;l m n&quot;), (6, &quot;spark hadoop spark&quot;), (7, &quot;apache hadoop&quot;)], [&quot;id&quot;, &quot;text&quot;]) prediction = model.transform(test) selected = prediction.select(&quot;id&quot;, &quot;text&quot;, &quot;probability&quot;, &quot;prediction&quot;) for row in selected.collect(): rid, text, prob, prediction = row print(&quot;(%d, %s) --&gt; prob=%s, prediction=%f&quot; % (rid, text, str(prob), prediction)) spark.stop() 测试结果如下： 1234(4, spark i j k) --&gt; prob=[0.1596407738787475,0.8403592261212525], prediction=1.000000(5, l m n) --&gt; prob=[0.8378325685476744,0.16216743145232562], prediction=0.000000(6, spark hadoop spark) --&gt; prob=[0.06926633132976037,0.9307336686702395], prediction=1.000000(7, apache hadoop) --&gt; prob=[0.9821575333444218,0.01784246665557808], prediction=0.000000 2.3 模型选择（超参数调整）使用ML Pipelines的一大好处是超参数优化。 有关自动模型选择的更多信息，请参阅这里。 同步于CSDN;音尘杂记；","link":"/2019/07/30/spark-ml-pipelines/"},{"title":"【Spark】模型选择和调优","text":"翻译自：http://spark.apache.org/docs/2.3.2/ml-tuning.html 介绍如何使用MLlib的工具来调整ML算法和Pipelines。 内置的交叉验证和其他工具允许用户优化算法和pipelines中的超参数。 1. 模型选择(亦称 超参数调优)ML中的一项重要任务是模型选择，或使用数据来查找给定任务的最佳模型或参数。这也称为调整。可以针对单个estimator（例如LogisticRegression）或针对包括多个算法，特征化和其他步骤的整个pipeline进行调整。用户可以一次调整整个pipeline，而不是分别调整管道中的每个元素。 MLlib支持使用CrossValidator和TrainValidationSplit等工具进行模型选择。这些工具需要以下项目： Estimator：算法或pipeline调整 一组ParamMaps：可供选择的参数，有时也称为“参数网格”(“parameter grid”)来搜索 评估器：衡量拟合模型对保持测试数据的效果的度量标准 从较高的层面来看，这些模型选择工具的工作原理如下： 他们将输入数据分成单独的训练和测试数据集。 对于每个（训练，测试）对，他们遍历ParamMaps集合： 对于每个ParamMap，它们使用这些参数拟合Estimator，获得拟合的模型，并使用Evaluator评估模型的性能。 他们选择由性能最佳的参数组生成的模型。 Evaluator可以是回归问题的RegressionEvaluator，二进制数据的BinaryClassificationEvaluator，或多类问题的MulticlassClassificationEvaluator。 用于选择最佳ParamMap的默认度量标准可以由每个评估程序中的setMetricName方法覆盖。 为了帮助构造参数网格，用户可以使用ParamGridBuilder。 默认情况下，参数网格中的参数集将按顺序进行评估。 在使用CrossValidator或TrainValidationSplit运行模型选择之前，可以通过设置值为2或更大的并行度（值为1是船型的）来并行完成参数评估。 应谨慎选择并行度的值，以在不超出群集资源的情况下最大化并行性，并且较大的值可能并不总是导致性能提高。 一般来说，对于大多数集群而言，高达10的值应该足够了。 2. 交叉验证CrossValidator首先将数据集拆分为一组folds，这些folds用作单独的训练和测试数据集。例如，当k = 3倍时，CrossValidator将生成3个（训练，测试）数据集对，每个数据集对使用2/3的数据进行训练，1/3进行测试。为了评估特定的ParamMap，CrossValidator通过在3个不同（训练，测试）数据集对上拟合Estimator来计算3个模型的平均评估度量。 在确定最佳ParamMap之后，CrossValidator最终使用最佳ParamMap和整个数据集重新拟合Estimator。 示例：通过交叉验证选择模型 以下示例演示如何使用CrossValidator从参数网格中进行选择。 请注意，通过参数网格进行交叉验证非常昂贵。例如，在下面的示例中，参数网格具有3个hashingTF.numFeatures值和2个lr.regParam值，CrossValidator使用2个折叠。这乘以（3×2）×2 = 12个正在训练的不同模型。在实际设置中，通常可以尝试更多参数并使用更多折叠（k = 3和k = 10是常见的）。换句话说，使用CrossValidator可能非常昂贵。然而，它也是一种成熟的方法，用于选择比启发式手动调整更具统计学意义的参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-# @Time : 2019/8/9 11:50# @Author : buracagyang# @File : cross_validator.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml import Pipelinefrom pyspark.ml.classification import LogisticRegressionfrom pyspark.ml.evaluation import BinaryClassificationEvaluatorfrom pyspark.ml.feature import HashingTF, Tokenizerfrom pyspark.ml.tuning import CrossValidator, ParamGridBuilderfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;CrossValidatorExample&quot;).getOrCreate() training = spark.createDataFrame([ (0, &quot;a b c d e spark&quot;, 1.0), (1, &quot;b d&quot;, 0.0), (2, &quot;spark f g h&quot;, 1.0), (3, &quot;hadoop mapreduce&quot;, 0.0), (4, &quot;b spark who&quot;, 1.0), (5, &quot;g d a y&quot;, 0.0), (6, &quot;spark fly&quot;, 1.0), (7, &quot;was mapreduce&quot;, 0.0), (8, &quot;e spark program&quot;, 1.0), (9, &quot;a e c l&quot;, 0.0), (10, &quot;spark compile&quot;, 1.0), (11, &quot;hadoop software&quot;, 0.0) ], [&quot;id&quot;, &quot;text&quot;, &quot;label&quot;]) # 配置一个ML pipeline tokenizer = Tokenizer(inputCol=&quot;text&quot;, outputCol=&quot;words&quot;) hashingTF = HashingTF(inputCol=tokenizer.getOutputCol(), outputCol=&quot;features&quot;) lr = LogisticRegression(maxIter=10) pipeline = Pipeline(stages=[tokenizer, hashingTF, lr]) &quot;&quot;&quot; CrossValidator需要Estimator，ParamMaps和一个Evaluator。 Estimator: 将Pipeline视为Estimator，将其包装在CrossValidator实例中。允许我们选择所有Pipeline阶段的参数。 ParamMaps: 使用ParamGridBuilder构建一个要搜索的参数网格。hasingTF.numFeatures有3个值，lr.regParam有2个值，总计6个参数。 Evaluator: BinaryClassificationEvaluator &quot;&quot;&quot; paramGrid = ParamGridBuilder().\\ addGrid(hashingTF.numFeatures, [2, 5, 10]).\\ addGrid(lr.regParam, [0.1, 0.01]).\\ build() crossval = CrossValidator(estimator=pipeline, estimatorParamMaps=paramGrid, evaluator=BinaryClassificationEvaluator(), numFolds=2) # 通常都使用3+折交叉验证 cvModel = crossval.fit(training) # 准备一个test set test = spark.createDataFrame([ (4, &quot;spark i j k&quot;), (5, &quot;l m n&quot;), (6, &quot;mapreduce spark&quot;), (7, &quot;test hadoop&quot;) ], [&quot;id&quot;, &quot;text&quot;]) # 用cvModel 寻找到的最优模型 prediction = cvModel.transform(test) selected = prediction.select(&quot;id&quot;, &quot;text&quot;, &quot;probability&quot;, &quot;prediction&quot;) for row in selected.collect(): print(row) spark.stop() 结果如下： 1234Row(id=4, text=u'spark i j k', probability=DenseVector([0.1702, 0.8298]), prediction=1.0)Row(id=5, text=u'l m n', probability=DenseVector([0.6476, 0.3524]), prediction=0.0)Row(id=6, text=u'mapreduce spark', probability=DenseVector([0.425, 0.575]), prediction=1.0)Row(id=7, text=u'test hadoop', probability=DenseVector([0.6753, 0.3247]), prediction=0.0) 3. 训练集-验证集划分除了CrossValidator之外，Spark还提供TrainValidationSplit用于超参数调整。 与CrossValidator一样，TrainValidationSplit最终使用最佳ParamMap和整个数据集来拟合Estimator。 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-# @Time : 2019/8/9 12:56# @Author : buracagyang# @File : train_validation_split.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from pyspark.ml.evaluation import RegressionEvaluatorfrom pyspark.ml.classification import LogisticRegressionfrom pyspark.ml.tuning import ParamGridBuilder, TrainValidationSplitfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;TrainValidationSplit&quot;).getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) train, test = data.randomSplit([0.9, 0.1], seed=2019) lr = LogisticRegression(maxIter=10) # 同样构建参数网络 paramGrid = ParamGridBuilder()\\ .addGrid(lr.regParam, [0.1, 0.01]) \\ .addGrid(lr.fitIntercept, [False, True])\\ .addGrid(lr.elasticNetParam, [0.0, 0.5, 1.0])\\ .build() # 80%的数据运来进行训练， 20%的数据用于验证 tvs = TrainValidationSplit(estimator=lr, estimatorParamMaps=paramGrid, evaluator=RegressionEvaluator(), trainRatio=0.8) model = tvs.fit(train) # 对测试数据进行测试 model.transform(test).select(&quot;features&quot;, &quot;label&quot;, &quot;prediction&quot;).show(10) spark.stop() 结果如下： 123456789101112131415+--------------------+-----+----------+| features|label|prediction|+--------------------+-----+----------+|(692,[121,122,123...| 0.0| 0.0||(692,[124,125,126...| 0.0| 0.0||(692,[124,125,126...| 0.0| 0.0||(692,[124,125,126...| 0.0| 0.0||(692,[150,151,152...| 0.0| 0.0||(692,[153,154,155...| 0.0| 0.0||(692,[154,155,156...| 0.0| 0.0||(692,[154,155,156...| 0.0| 0.0||(692,[123,124,125...| 1.0| 1.0||(692,[124,125,126...| 1.0| 1.0|+--------------------+-----+----------+only showing top 10 rows","link":"/2019/08/09/spark-ml-tuning/"},{"title":"【Graph Embedding】line","text":"关于Graph Embedding系列的论文翻译解读文章： 【Graph Embedding】DeepWalk 【Graph Embedding】line 【Graph Embedding】node2Vec 【Graph Embedding】SDNE 【Graph Embedding】struc2vec 参考资料 paper: https://arxiv.org/pdf/1503.03578.pdf code: https://github.com/tangjianpku/LINE 摘要文章同样是研究如何将网络如何嵌入到低维向量空间的问题，应用于可视化，节点分类，和链路预测上。这种新型网络表征方法称为LINE，适用于任意类型的信息网络(有向的，无向的，以及无权的有权的)。该方法优化了一个精心设计的目标函数，保留了局部以及全局的网络结构。提出了一种边采样算法，该算法解决了经典随机梯度下降的局限性，并提高了推理的有效性和效率。经过实验验证了LINE在多种真实世界的信息网络（语言、社会，引文）的有效性，该算法非常有效，能够在典型的单台机器上学习在几小时内嵌入具有数百万个顶点和数十亿个边的网络。 1. 介绍为了更好的在嵌入过程中保留网络中的拓扑结构信息（保留节点之间的关联关系）。LINE提出了一阶相似度和二阶相似度的概念。 一阶相似度指顶点之间直接连接信息。在真实网络数据中不足以用于保留全局的网络结构。故补充了二阶相似度的概念(即具有共享的邻居节点的顶点可能是相似的)。在社会学和文本语库中可以找到这样的推论。社交网络中，两个人的好友关系的重复度越高，两个人的相关性就越高。文本语料库中，我们可以通过一句话的其他内容来了解单个单词的意思。事实上，有许多共同好友的两个人大概率有相似的爱好并可能成为朋友，而常与同样的语句组合使用的单词更可能具有相同的意思。 LINE提出了一种保留了一阶相似度和二阶相似度的精心设计的目标函数。直接对真实信息网络使用随机梯度下降是不可取的。因为许多网络中的边是带权的，且权重呈现了高度的差异性。对于一个单词共现网络，单词对的权重变化可能从一到百到千，边的权重乘以梯度会引起梯度爆炸，进而影响性能。为了解决这个问题，LINE用与其权重成比例的概率对边进行采样，并将采样边视为二进制边以进行模型更新。在这样的取样过程下，目标函数不会发生变化， 且边的权重不再影响梯度。 LINE的贡献如下三点： LINE适用于任意类型的信息网络，并能够轻易拓展到百万个节点。它拥有一个可以保留一阶相似度和二阶相似度的目标函数。 提出了一种边采样算法以优化目标函数。该算法解决了经典随机梯度下降的局限性，提高了推理的有效性和效率。 在真实的信息网络中继续了广泛的实验。实验结果证明了LINE模型的有效性和效率。 2. 相关工作经典的图表征方法和降维方法使用数据点的特征向量来创建关联图。最近的文献介绍了图矩阵分解方法，使用优化的随机梯度下降方法进行了矩阵分解。该方法不能保留网络全局结构，并且只能应用于无向图。还有之前结束的DeepWalk。DeepWalk为获取更高阶的节点产生相似的低维表示，使用DFS随机游走对图进行节点采样，但没有提供一个明确的目标函数。而LINE使用了BFS的策略。此外，DeepWalk只能应用到无权的网络，而LINE可以应用于包含有权/无权的边的网络。 3. 问题定义定义1 信息网络 信息网络被定义为$G = (V, E)$，其中$V$表示节点集合，每个节点表示一个数据对象。$E$表示节点间的边。每一个$e \\in E$都是一个有序对 $e = (u, v)$且都有一个关联的权重$w_{uv} &gt; 0$。如果$G$是无向图，那么有$(u, v) \\equiv (v, u)$且$w_{uv} \\equiv w_{vu}$。如果$G$是有向图，则$(u, v) \\not\\equiv (v, u)$且$w_{uv} \\not\\equiv w_{vu}$。 定义2 一阶相似度 一阶相似度：一阶相似度是网络中两个节点的局部相似度。若节点$u$和$v$之间有边$(u,v)$，则$w_{uv}$表示$u$和$v$之间的一阶相似度。如果$u$和$v$之间没有可以观察的边，一阶相似度则为0。 定义3 二阶相似度 二阶相似度：网络中一对节点$(u, v)$之间的二阶相似度是他们相邻网络结构的相似度。数学化的定义，使$[p_{u} = (w_{u,1},… ,w_{u,|V|})$ 描述节点$u$与其他节点的一阶相似度，那么$u$与$v$的二阶相似度取决于$p_u$与$p_v$之间的相似度。如果没有从$u$到$v$连接（或从$v$到$u$）的中间节点。则$u$和$v$之间的二阶相似度为0。 定义4 大规模信息网络embedding 大规模信息网络embedding: 给定一个大型网络$G=(V, E)$，大规模信息网络嵌入的目标是把每个节点$u \\in V$ 嵌入到低维向量空间$R^{d}$中。如：学习一个函数$f_{G}:V\\to R^{d},d\\ll |V|$。在$R^{d}$空间内，节点间的一阶相似度和二阶相似度都被保留。 4. LINE：大规模信息网络嵌入真实世界网络下的一个理想的嵌入模型必须满足如下几个条件：1.保留一阶相似度和二阶相似度。2.能够支持含有百万节点和亿万边的大型网络的规模。3.能够处理任意类型的边(有无方向，有无权重)。 4.1 模型描述分别描述保持一阶近似和二阶近似的线性模型，然后介绍一种将两种近似结合起来的简单方法。 4.1.1 LINE的一阶相似度对于无向边$(i, j)$， 我们定义$v_i$和$v_j$的相连的可能性如下： p_{1}(v_{i},v_{j})=\\frac{1}{1+exp(-\\vec u_i^{T}\\cdot\\vec u_j)} \\tag{1}其中，$\\vec u_i\\in R^d$ 是$v_i$ 节点的低维向量表示。$p(.,.)$是 $V*V$ 的向量空间下的一个分布，它所验证的概率可以被定义为$\\hat p_1(i,j)=\\frac{w_{ij}}{W}$，其中$W=\\sum_{i,j\\in E}w_{ij}$ 为了保留一阶相似度，可以直接最小化以下目标函数： O_{1}=d(\\hat p_1(.,.),p_1(.,.)) \\tag{2}其中$d$是两个分布的距离，我们选择最小化两个可能分布的KL距离 (KL距离：$KL(p||q)= \\int p(x)log\\frac{p(x)}{q(x)}dx = -\\int p(x)log\\frac{q(x)}{p(x)}dx$ 用于衡量两个概率分布的差异情况, 其值越大说明两个分布的差异越大)。使用KL距离来替换d(.,.)并忽略一些约束。我们得到了： O_1=-\\sum_{i,j\\in E}w_{ij}logp_1(v_i,v_j) \\tag{3}注意：该一阶相似度仅应用于无向图，而非有向图。通过寻找能够使（3）式最小化的$\\{\\vec u_i\\}_{i=1..|V|}$ 。我们可以在$d$维的空间里表示每个节点。 4.1.2 LINE的二阶相似度二阶相似度可以应用于有向图以及无向图。给定一个网络，为不失一般性，我们假设它是有向的（无向边可以被视为两个方向相反、权重相等的有向边）。每个顶点既是顶点本身，也是其他顶点的上下文。在这种情况下，每个顶点也被视为一个特定的”上下文”，在“上下文”中具有相似分布的顶点被认为是相似的。因此，每个顶点扮演两个角色:顶点本身和其他顶点的一个特定“上下文”。所以提出两个向量$\\vec u_i$和$\\vec u_i^\\prime$，其中$\\vec u_i$代表点\\vec v_i$作为一个顶点时的表示，而$\\vec u_i^\\prime$代表其作为一个特定的”上下文”时的表示。对于每条有向边$(i, j)$，定义由顶点$v_i$生成的特定”上下文”$v_j$的概率为： p_2(v_j|v_i)=\\frac{exp(\\vec u_j\\prime^T \\cdot \\vec u_i)}{\\sum_{k=1}^{|V|}exp(\\vec u_k\\prime^T \\cdot \\vec u_i)} \\tag{4}其中，$|V|$是顶点或上下文的数量。对于每个顶点$v_i$,（4）式定义了一个上下文的条件分布$p_2(\\cdot|v_i)$，例如网络中节点的完整集合。为了保留二阶相似度，我们应该使用低维表征的上下文条件分布$p_2(\\cdot|v_i)$ 接近于经验分布$\\hat p_2(\\cdot|v_i)$ 。这样，我们最小化了以下目标函数： O_2=\\sum_{i\\in V}\\lambda_id(\\hat p_2(\\cdot|v_i),p_2(\\cdot|v_i)) \\tag{5}其中$d(.,.)$是两个分布之间的距离。由于顶点在网络中的重要性不同，我们引入了$\\lambda_i$ 到目标函数中来表示网络中顶点$i$的重要性，可以通过度来计算得到或者通过PageRank算法来评估。经验分布$\\hat p_2(\\cdot|v_i)$ 被定义为$\\hat p_2(v_j|v_i)=\\frac{w_{ij}}{d_i}$ ,其中$w_{ij}$是边$(i, j)$的权重，且$d_i$是顶点$i$的出度。即，$d_i=\\sum_{k\\in N(i)}w_{ik}$ . 其中$N(i)$是$v_i$节点的“出”邻居（从$i$节点出发的邻节点），在本文中，为了方便，我们设置$\\lambda_i$ 作为顶点$i$的出度。$\\lambda_i=d_i$，我们还采用KL散度作为距离函数，使用KL距离代替d(.,.).设置$\\lambda_i=d_i$并忽略约束，我们得到了： O_2 = -\\sum_{(i,j)\\in E}w_{ij}logp_2(v_j|v_i) \\tag{6}通过学习能够使以上目标函数最小化的$\\{\\vec u_i\\}_{i=1..|V|}$ 和 $\\{\\vec u_i\\prime\\}_{i=1..|V|}$，我们能够通过一个$d$维的向量$\\vec u_i$表示每个顶点$v_i$。 4.1.3 结合一阶相似度和二阶相似度文章分别保留一阶相似度和二阶相似度，然后，为每个顶点连接由两种方法训练得到的embedding。 更好的方法是结合两个相似度来联合训练目标函数（3）和（6）。 4. 2 模型优化优化目标函数（6）的计算代价昂贵，在计算条件概率$p2(\\cdot|v_i)$ 时需要对整个顶点集求和。所以采用了论文[13]中提出的负采样方法，根据每个边$(i,j)$的一些噪声分布对多个负边进行采样，它为每个边指定了以下目标函数： log\\sigma(\\vec u_j\\prime^T\\cdot\\vec u_i)+\\sum_{i=1}^KE_{v_n \\~ P_n(v)}[log\\sigma(-\\vec u_n\\prime^T\\cdot \\vec u_i)] \\tag{7}其中$\\sigma(x)= 1/exp(-x)$ 是sigmoid函数。第一项对观察到的边进行建模，第二项对从噪声分布中绘制的负边进行建模，而$K$是负边的数量。我们根据[13]，设置$p_n(v)\\propto d_v^{3/4}$ ，其中$d_v$是$v$节点的出度。 为了（3）式的目标函数。存在一个平凡解：$u_{ik}=\\infty$。其中$i=1,…,|V|$且 $k=1…,d$。为了避免平凡解，我们仍然可以使用负采样方法，仅将$\\vec u_{j}\\prime^T$变成$\\vec u_j^T$。 我们采用了异步随机梯度算法(ASGD)来优化等式（7）。在每一步，ASGD算法取样了一小部分的边并更新了模型的参数，如果边$(i,j)$被取样，那么关于$i$节点的embedding向量$\\vec u_i$的梯度可以被计算： \\frac{\\partial O_2}{\\partial \\vec u_i}=w_{ij}\\cdot \\frac{\\partial logp_2(v_j|v_i)}{\\partial \\vec u_i} \\tag{8}这样的梯度将乘以边的权重。当边的权重具有高方差时，这将成为问题。例如，在单词共现网络中，有些单词共现的次数上千，有些次数非常少。在这样的网络中，梯度的规模偏差太大，难以寻找一个好的学习比例。如果我们根据有较小权重的边来选择一个大的学习比率，权重较大的边的梯度会爆炸。如果根据较大权重的来选择一个小的学习比率，权重较小的边的梯度会太小。 4.2.1 边采样算法优化一个简单的方法是将一条带权的边展开为多种二进制边。例如，一个权重为$w$的边展开为$w$个二进制边。这样能够解决问题但增加了内存需求，尤其是在边的权重值非常大时。LINE从原始边进行取样，并将取样的边视为二进制边。采样概率与原始边的权重成比例。通过这种边采样处理，总体目标函数保持不变，问题归结为如何根据权重对边进行采样。 令$W=(w_1,w_2,w_3,…,w_{|E|})$表示边的权重的顺序。一种简单的方法是可以直接计算权重的总和 $w_{sum}=\\sum_{i=1}^{|E|}w_i$，然后在$[0,w_{sum}]$中取一个随机值来看随机值落入的区间$[\\sum_{j=0}^{i-1}w_j,\\sum_{j=0}^iw_j]$。这个方法得到样本的时间复杂度时$O(|E|)$。当边的数量$|E|$较大时开销较大。LINE根据复杂度仅为O(1)的alias table（别名表）[9]方法来取样。 从alias table中取样一条边的时间O(1),优化一个负采样需要$O(d(K+1))$的时间，其中$K$是负样本的数量。因此，总体每一步骤都需要$O(dK)$时间。在实践中，我们发现用于优化的步骤数量与边的数量$O(|E|)$成比例。因此，LINE的总的时间复杂度是$O(dK|E|)$,与边$|E|$的数量呈线性关系的，且不依赖于顶点数量$|V|$。这种边取样方法在不影响效率的情况下提升了随机梯度下降算法的有效性。 4.3 讨论低度顶点 第一个问题：如何精确嵌入具有较低度数的顶点？由于这类顶点的邻居数量很少，所以难以得到它所对应的精确表征，尤其是严重依赖上下文的二阶相似度。一种推论是，通过增加其高阶的邻居（如邻居的邻居）来拓展这些顶点的邻居。在LINE中，仅讨论增加二级邻居。即对每个顶点，增加其邻居的邻居。顶点$i$和其二级邻居节点$j$之间的距离可以被计算为： w_{ij}=\\sum _{k\\in N(i)}w_{ik}\\frac{w_{kj}}{d_k} \\tag{9}实际上，可仅为具有较低度数的顶点$i$增加一个有最大相似度$w_{ij}$的顶点子集${j}$。 新的顶点 第二个问题：如何得到新顶点的表征？对于一个新顶点$i$,如果已知它与已存在的顶点之间连接。我们可以根据已存在的顶点获得经验分布$\\hat p_1(\\cdot ,v_i)$和$\\hat p_2(\\cdot|v_i)$。为了获取新顶点的嵌入，根据目标函数（3）式和（6）式。一个直接的方法通过更新新顶点的嵌入并保持已存在顶点的嵌入来最小化以下任意一个目标函数： -\\sum_{j\\in N(i)}w_{ji}logp_1(v_j,v_i), or -\\sum_{j\\in N(i)}w_{ji}logp_2(v_j|v_i) \\tag{10}5. 试验5.1 试验设置数据集 语言网络 社交网络 引用网络 算法比较 与一些可以处理大规模网络的几种图嵌入方法进行比较。 Graph Factorization(GF): 一个信息网络可以被表示为一个相似矩阵（affinity matrix），通过矩阵分解可以得到每个顶点的低维向量表示。图分解算法经过随机梯度下降的优化可以用于处理大规模网络，但它仅应用于无向网络。 DeepWalk LINE-SGD: 通过随机梯度下降优化了等式(3)和(6)的LINE模型。该方法中模型更新时取样的边的权重直接与梯度相乘。该方法有两个变量：LINE-SGD(1st)和LINE-SGD(2nd),分别使用了一阶相似度和二阶相似度。 LINE：经过了边取样处理优化后的LINE模型。在每一个随机梯度下降的步骤，边会根据与权重成比例的可能性被取样，然后取样所得到的边在模型更新中按二进制边处理。与GF类似，LINE(1st)和LINE-SGD(1st)仅应用于无向图。LINE(2nd)和LINE-SGD(2nd)可以应用于有、无向图。 LINE(1st+2nd): 为了同时利用一阶相似度和二阶相似度，一种简单直接的方法是将通过LINE(1st)和LINE(2nd)学习到的表征向量串联得到一个长向量。串联之后，维度应该被重新加权以平衡两种表征。在一个有监督的学习任务中，维度的权重可以基于训练数据被自动得到。在无监督的学习任务重，很难去设置权重值，因此仅将LINE(1st+2nd)应用到有监督任务。 参数设置 所有方法的小批量随机梯度算法（mini-batch SGD）的规模被设置成1。（每次只用总训练集的一小部分来训练，loss的下降更稳定，占用资源更少）。与论文[13]相同，学习速率的初始值被设置成$\\rho _0=0.025$且$\\rho _t=\\rho _0(1-t/T)$.其中$T$是mini-batch或边样本的数量，为了公平的对比，语言网络的嵌入维数设置为200，与单词嵌入时使用的一样。对于其他网络，默认的维数是128，与论文[16]中使用的一样。其他默认设置包含：LINE和LINE-SGD的负样本数量$K=5$。LINE(1st)和LINE(2nd)的样本总数T=100亿，GF的T=200亿，窗口大小$win=10$,步长$t=40$。DeepWalk中每个节点的步数$\\gamma=40$。所有嵌入向量通过令$||\\vec w||_2=1$最终正则化。 5.2 定量结果5.2.1 语言网络单词分析和文本分类的应用场景被用于评估学习嵌入的有效性。 （一）单词分析 给定单词对$(a,b)$和单词$c$，目标是找到一个$d$使得$ab$之间的关系与$cd$之间的关系是相同的。给定一个单词的嵌入，目标是找到一个单词$d^{*}$，其嵌入与向量$\\vec u_b-\\vec u_a+\\vec u_c$余弦接近。即，$d^{*}=argmax_dcos((\\vec u_b - \\vec u_a+ \\vec u_c), \\vec u_d)$。任务中的单词分析包括语义分析和句法分析。表2展示了对维基百科网络应用网络嵌入的单词分析结果。对于GF，单词对之间的权重被定义为共现次数的对数，比直接定位为共现次数的性能表现更好。对于DeepWalk,将语言网络转换为二进制网络过程中尝试使用不同的截断门槛，当所有的边都保留在网络中时能够获得最好的性能。 我们可以看到LINE(2nd)的表现优于其他方法，包括Skip-Gram。这表示了二阶相似度能够比一阶相似度更好的获取单词语义。这并不意外，高的二阶相似度意味着两个单词能够在同样的上下文中相互替换。意外的是，LINE(2nd)的表现甚至优于Skip-Gram。原因可能是语言网络比单词序列能够更好的捕获全局的单词共现结构。其他方法中,GF和LINE(1st)表现显著优于DeepWalk，即使Deepwalk拓展了二阶相似度,这可能是因为Deepwalk忽略在语言网络中非常重要的边权重。通过SGD优化的LINE模型表现比较差，因为，语言网络的边的权重的偏差范围较大，可能从1-1万，影响了学习。使用经过边取样处理优化的LINE模型能够较好处理以上问题，使用了一阶相似度和二阶相似度的表现的尤其好。 所有的方法都运行在一个单个机器（1T内存，40个20Ghz、16个线程的CPU内核）。LINE(1st)和LINE(2nd)都非常有效，处理2百万节点和十亿条边的网络仅需要不到3个小时。两者都比图分解方法快至少10%，比DeepWalk方法快了5倍。 （二）文件分类 另一种评估单词嵌入的质量的方法是使用单词向量去计算文件表征，来评估文件分类任务。为了获取文件表征，由于目标是比较不同单词嵌入方法在文件分类中的应用表现以找到最好的方法，所以通过计算文本中所有单词向量表征的均值来简单获取文件的表征。实验下载了维基百科的摘要和分类。选择7个类别，包括艺术，历史，人文，数学，自然，科技，运动。对于每个类别，随机选择了10000文章，并且剔除了那些属于多个目录下的文章。我们随机按照不同的百分比来取样用于训练，并将剩下的用于评估。均选择LibLinear 包的一对多的线性回归分类器，使用micro-F1和macro-F1作为分类指标，通过对不同的训练数据进行采样，将结果平均在10次不同的运行中。 表三展示了维基百科页面分类结果。与单词分析任务可以得到相同的结论。由于Deepwalk忽视边的权重，图分解方法比DeepWalk的表现更好。LINE-SGD由于边的权重偏差过大表现较差。经过边取样处理优化后的LINE比直接应用SGD的表现略好。LINE(2nd)表现优于LINE(1st)，且轻微优于图分解。在有监督的学习任务中，LINE(1st)和LINE(2nd)学习的向量直接合并是可行的。 表4展示了给定单词使用一阶相似度和二阶相似度得到的最相似的单词。根据上下文相似度，使用二阶相似度召回的最相似单词都是语义相关的单词。而一阶相似度召回的最相似单词是语义和句法混合相关的单词。 5.2.2 社交网络社交网络比语言网络更加稀疏，尤其是Youtube。我们通过多分类任务来评估顶点。（一）Flickr network LINE(1st+2nd)表现显著优于其他方法。与语言网络相反的是，LINE(1st)表现略微优于LINE(2nd)，原因可能有两个（1）在社会网络中1阶相似度比2阶相似度要更加重要，因为他表示更强的链接；（2）当网络过于稀疏，且节点的邻节点数量平均值较低时，二阶相似度可能会不太准确。LINE(1st)表现优于图分解方法，表示它在建模一阶相似度上具有更好的能力。LINE(2nd)表现优于DeepWalk方法，证明了它在建模二阶相似度上具有更强的能力。（二）Youtube 网络 表6展示了Youtube网络（很稀疏，且平均度数低至5）上的结果。在使用不同百分比的训练数据得到的所有情况下，LINE(1st)表现优于LINE(2nd)，与FLICKR网络中一样。由于其巨大稀疏性，LINE(2nd)的表现低于DeepWalk。但LINE(1st+2nd)的性能不论是在128还是256维度上都表现得很好，证明了两种相似度是互补的。 Deepwalk 使用截断的随机游走(DFS)来应对网络的稀疏性。这样通过引入非直接邻节点来消除稀疏性，可能会导致引入远距离的节点。更可靠的方法是使用广度优先策略来拓展每个节点的邻居。即递归的增加邻居的邻居。为了验证，我们拓展了所有度数低于1000的节点的邻居节点直到它的邻节点的数量达到1000，但这并没有进一步提高性能。 这样重建的网络的结果在表6中括号中展示。GF, LINE(1st)和LINE(2nd)都得到了提升，尤其是LINE(2nd)。在这个重建网络中，LINE(2nd)在所有情况下的表现都优于DeepWalk.LINE(1st+2nd)在重建后的网络上的表现没有太大的提升。这表示原始网络中的一阶相似度和二阶相似度已经捕获了大部分的原始网络中的信息。 5.2.3 引用网络我们在两个引用网络中表示了结果，两个都是有向的。使用一阶相似度的GF和LINE不能应用于有向网络，所以文章只比较了Deepwalk和LINE(2nd)。我们选择7个流行的会议AAAI, CIKM, ICML, KDD, NIPS,SIGIR, and WWW作为分类lebel。假定在会议中发布的论文或会议中发表的作者属于与会议相对应的类别。（一） DBLP（作者引用）网络表7展示了结果。由于网络非常稀疏，DeepWalk表现优于LINE(2nd).然而通过对度数小于500的顶点递归增加邻节点的邻节点来重建网络，LINE(2nd)的表现得到显著的提升并赶超Deepwalk。直接通过随机梯度下降优化的LINE模型表现并没有像期望一样好。（二）DBLP(论文引用)网络 表8展示了结果，LINE(2nd)表现显著优于DeepWalk。这是因为论文引用网络使用随机游走只能沿着引用路径寻找论文（即，更早的论文）。而不能到达其他的参考文献。而LINE(2nd)根据论文的引用来表示每个论文的方式更加合理。结合对低度数的节点（度数&lt;200）进行填充处理的重构网络的LINE(2nd)方法具有进一步的性能提升。 5.3 网络布局我们将网络嵌入到二维空间进行可视化。从DBLP数据中分离了共著网络进行了可视化。我们从三个不同的搜索领域中选取了几个会议，数据挖掘（WWW,KDD），机器学习(NIPS,ICML)，计算机视觉(CVPR,ICCV)。过滤掉度数小于3的节点，最后网络包含18561个作者和207074条边。由于这三个领域非常相近，所以可视化共著者网络的难度较大。首先，我们使用多种嵌入方法把共著者网络映射到低维向量空间，然后进一步把低维向量使用t-SNE方法映射到2D空间中。图2比较了不同嵌入方法的可视化结果，图分解方法的可视化结果没有太大的意义，相同社团的作者并没有聚集在一起。Deepwalk的效果更好一些。然而，许多属于不同社团的作者被紧密聚合在中心区域，其中大多数都是在原网络中具有高度数的顶点。这是因为Deepwalk使用一个基于随机游走的方法补充顶点的邻居，由于随机性带来了大量的噪声，尤其是在具有更高度数的顶点。LINE(2nd)的表现相当好且产生了有意义的网络布局。（相同颜色的节点分布的更近） 5.4 网络稀疏与性能相关性在该子节中，我们形式化的分析了以上模型性能如何受网络稀疏性影响。我们首先研究了网络稀疏性如何影响LINE(1st)和LINE(2nd)。图3a展示了FLICKR网络下关于连接百分比的结果。我们选择了比Youtube更稠密的FLICKR网络。我们可以看到，刚开始，在网络非常稀疏的情况下，LINE(1st)比LINE(2nd)表现更好，当逐渐增加链路百分比时，LINE(2nd)表现比LINE(1st)更强。这说明了二阶相似度在网络十分稀疏的情况下是表现不良的，但当节点有足够多的邻节点时，表现会优于一阶相似度。图3b展示了在原始Youtube网络和经过重建的Youtube网络上顶点度数的与性能的关系。我们把顶点根据它们度数所在的区间分类到不同目录下(0，1]， [2，3]， [4，6]， [7， 12]，[13，30]，[31，+)。然后评估了不同组顶点的性能。总的来说，当节点度数增加时，不同模型的性能也会有所提升。在原始网络中，除了第一组，LINE(2nd)的表现优于LINE(1st)，证明了二阶相似度在度数较低的情况下不能更好的被利用。在重建后的稠密网络。LINE(1st)和LINE(2nd)的性能都优素提升，尤其是保留了二阶相似度的LINE(2nd)。我们还可以看到LINE(2nd)在重建网络上的表现每一组都优于Deepwalk。 5.5 参数敏感性接下来，文章研究了维度d参数与性能的相关性和在重建后的Youtube网络下不同模型的收敛性与样本数量的相关性。图4a记录了LINE模型与维度d的关系。我们可以发现LINE(1st)和LINE(2nd)的性能在维度过大时性能骤减。图4b展示了LINE和Deepwalk与优化过程中的样本数量的相关性。LINE(2nd)表现始终优于LINE(1st)和DeepWalk。LINE(1st)和LINE(2nd)都比Deepwalk的收敛速度要快。 5.6 可拓展性最后通过部署多个线程进行优化来研究了LINE模型经过边取样处理和异步梯度下降优化后的LINE模型的可拓展性。。图5a展示了在Youtube数据集上线程数量与速率的关系。关系相当接近于线性关系。图5b展示了在模型更新时使用多个线程下的分类性能保持平稳。这两个图共同展示了LINE模型的推理算法是可拓展的。","link":"/2019/12/21/graph-embedding-line/"},{"title":"【Spark】分类和回归算法-分类","text":"本节主要讲Spark ML中关于分类算法的实现。示例的算法Demo包含：LR、DT、RF、GBTs、多层感知器、线性支持向量机、One-vs-Rest分类器以及NB等。 1. Logistic regression在spark.ml中，逻辑回归可以用于通过二项逻辑回归来预测二元结果，或者它可以用于通过使用多项逻辑回归来预测多类结果。 使用family参数在这两个算法之间进行选择，或者保持不设置，Spark将推断出正确的变量。 通过将’family’参数设置为“multinomial”，可以将多项逻辑回归用于二元分类。 它将产生两组系数和两个截距。 1.1 二分类LR直接给出示例代码： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# @Time : 2019/8/2 17:42# @Author : buracagyang# @File : logistic_regression_with_elastic_net.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.classification import LogisticRegressionfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;LogisticRegressionWithElasticNet&quot;)\\ .getOrCreate() training = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) lr = LogisticRegression(maxIter=10, regParam=0.3, elasticNetParam=0.8) lrModel = lr.fit(training) print(&quot;Coefficients: &quot; + str(lrModel.coefficients)) print(&quot;Intercept: &quot; + str(lrModel.intercept)) # 对于二分类也可以参数设置为，family=&quot;multinomial&quot; mlr = LogisticRegression(maxIter=10, regParam=0.3, elasticNetParam=0.8, family=&quot;multinomial&quot;) mlrModel = mlr.fit(training) print(&quot;Multinomial coefficients: &quot; + str(mlrModel.coefficientMatrix)) print(&quot;Multinomial intercepts: &quot; + str(mlrModel.interceptVector)) spark.stop() 结果如下： 12345678Coefficients: (692,[...])Intercept: 0.224563159613Multinomial coefficients: 2 X 692 CSRMatrix(0,244) 0.0(0,263) 0.0001....Multinomial intercepts: [-0.12065879445860686,0.12065879445860686] LogisticRegressionTrainingSummary提供LogisticRegressionModel的一些训练指标摘要。 在二进制分类的情况下例如， ROC曲线。 继续前面的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-# @Time : 2019/8/2 17:49# @Author : buracagyang# @File : logistic_regression_summary_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.classification import LogisticRegressionfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession \\ .builder \\ .appName(&quot;LogisticRegressionSummary&quot;) \\ .getOrCreate() training = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) lr = LogisticRegression(maxIter=10, regParam=0.3, elasticNetParam=0.8) lrModel = lr.fit(training) trainingSummary = lrModel.summary # 获得每次迭代的优化目标(损失 + 惩罚项) objectiveHistory = trainingSummary.objectiveHistory print(&quot;objectiveHistory:&quot;) for objective in objectiveHistory: print(objective) # Obtain the receiver-operating characteristic as a dataframe and areaUnderROC. trainingSummary.roc.show() print(&quot;areaUnderROC: &quot; + str(trainingSummary.areaUnderROC)) # 设置模型阈值，使得最大化F度量值 fMeasure = trainingSummary.fMeasureByThreshold maxFMeasure = fMeasure.groupBy().max('F-Measure').select('max(F-Measure)').head() bestThreshold = fMeasure.where(fMeasure['F-Measure'] == maxFMeasure['max(F-Measure)']) \\ .select('threshold').head()['threshold'] lr.setThreshold(bestThreshold) spark.stop() 日志信息： 123456789101112131415161718192021222324252627282930objectiveHistory:0.683314913574...+---+--------------------+|FPR| TPR|+---+--------------------+|0.0| 0.0||0.0|0.017543859649122806||0.0| 0.03508771929824561||0.0| 0.05263157894736842||0.0| 0.07017543859649122||0.0| 0.08771929824561403||0.0| 0.10526315789473684||0.0| 0.12280701754385964||0.0| 0.14035087719298245||0.0| 0.15789473684210525||0.0| 0.17543859649122806||0.0| 0.19298245614035087||0.0| 0.21052631578947367||0.0| 0.22807017543859648||0.0| 0.24561403508771928||0.0| 0.2631578947368421||0.0| 0.2807017543859649||0.0| 0.2982456140350877||0.0| 0.3157894736842105||0.0| 0.3333333333333333|+---+--------------------+only showing top 20 rowsareaUnderROC: 1.0 1.2 多分类LR示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# -*- coding: utf-8 -*-# @Time : 2019/8/5 16:35# @Author : buracagyang# @File : multiclass_logistic_regression_with_elastic_net.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.classification import LogisticRegressionfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession \\ .builder \\ .appName(&quot;MulticlassLogisticRegressionWithElasticNet&quot;) \\ .getOrCreate() training = spark \\ .read \\ .format(&quot;libsvm&quot;) \\ .load(&quot;../data/mllib/sample_multiclass_classification_data.txt&quot;) lr = LogisticRegression(maxIter=10, regParam=0.3, elasticNetParam=0.8) lrModel = lr.fit(training) # 系数和截距项 print(&quot;Coefficients: \\n&quot; + str(lrModel.coefficientMatrix)) print(&quot;Intercept: &quot; + str(lrModel.interceptVector)) trainingSummary = lrModel.summary # 获得每次迭代的优化目标(损失 + 惩罚项) objectiveHistory = trainingSummary.objectiveHistory print(&quot;objectiveHistory:&quot;) for objective in objectiveHistory: print(objective) # 可以查看每个类的FPR &amp; TPR print(&quot;False positive rate by label:&quot;) for i, rate in enumerate(trainingSummary.falsePositiveRateByLabel): print(&quot;label %d: %s&quot; % (i, rate)) print(&quot;True positive rate by label:&quot;) for i, rate in enumerate(trainingSummary.truePositiveRateByLabel): print(&quot;label %d: %s&quot; % (i, rate)) print(&quot;Precision by label:&quot;) for i, prec in enumerate(trainingSummary.precisionByLabel): print(&quot;label %d: %s&quot; % (i, prec)) print(&quot;Recall by label:&quot;) for i, rec in enumerate(trainingSummary.recallByLabel): print(&quot;label %d: %s&quot; % (i, rec)) print(&quot;F-measure by label:&quot;) for i, f in enumerate(trainingSummary.fMeasureByLabel()): print(&quot;label %d: %s&quot; % (i, f)) accuracy = trainingSummary.accuracy falsePositiveRate = trainingSummary.weightedFalsePositiveRate truePositiveRate = trainingSummary.weightedTruePositiveRate fMeasure = trainingSummary.weightedFMeasure() precision = trainingSummary.weightedPrecision recall = trainingSummary.weightedRecall print(&quot;Accuracy: %s\\nFPR: %s\\nTPR: %s\\nF-measure: %s\\nPrecision: %s\\nRecall: %s&quot; % (accuracy, falsePositiveRate, truePositiveRate, fMeasure, precision, recall)) spark.stop() 结果如下： 1234567891011121314151617181920212223242526272829303132333435Coefficients: 3 X 4 CSRMatrix(0,3) 0.3176(1,2) -0.7804(1,3) -0.377Intercept: [0.05165231659832854,-0.12391224990853622,0.07225993331020768]objectiveHistory:1.09861228867...False positive rate by label:label 0: 0.22label 1: 0.05label 2: 0.0True positive rate by label:label 0: 1.0label 1: 1.0label 2: 0.46Precision by label:label 0: 0.694444444444label 1: 0.909090909091label 2: 1.0Recall by label:label 0: 1.0label 1: 1.0label 2: 0.46F-measure by label:label 0: 0.819672131148label 1: 0.952380952381label 2: 0.630136986301Accuracy: 0.82FPR: 0.09TPR: 0.82F-measure: 0.800730023277Precision: 0.867845117845Recall: 0.82 2. 决策树分类器举例 以LibSVM格式加载数据集，将其拆分为训练集和测试集，在第一个数据集上训练，然后在保留的测试集上进行评估。 我们使用两个特征变换器(transformers)来准备数据; 这些帮助标记和分类特征的索引类别，向决策树算法可识别的DataFrame添加元数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# -*- coding: utf-8 -*-# @Time : 2019/8/5 16:41# @Author : buracagyang# @File : decision_tree_classification_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml import Pipelinefrom pyspark.ml.classification import DecisionTreeClassifierfrom pyspark.ml.feature import StringIndexer, VectorIndexerfrom pyspark.ml.evaluation import MulticlassClassificationEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;DecisionTreeClassificationExample&quot;)\\ .getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) # 对于整个数据集，将label转换为索引 labelIndexer = StringIndexer(inputCol=&quot;label&quot;, outputCol=&quot;indexedLabel&quot;).fit(data) # 自动识别数据集中的分类特征，并且进行矢量化处理;设定maxCategories，以便将具有&gt; 4个不同值的特性视为连续的。 featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, outputCol=&quot;indexedFeatures&quot;, maxCategories=4).fit(data) # 切分训练集和测试集 (trainingData, testData) = data.randomSplit([0.7, 0.3]) # 训练一颗决策树 dt = DecisionTreeClassifier(labelCol=&quot;indexedLabel&quot;, featuresCol=&quot;indexedFeatures&quot;) # 连接indexers和决策树 pipeline = Pipeline(stages=[labelIndexer, featureIndexer, dt]) model = pipeline.fit(trainingData) # 进行预测 predictions = model.transform(testData) predictions.select(&quot;prediction&quot;, &quot;indexedLabel&quot;, &quot;features&quot;).show(5) # 计算测试误差 evaluator = MulticlassClassificationEvaluator( labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;) accuracy = evaluator.evaluate(predictions) print(&quot;Test Error = %g &quot; % (1.0 - accuracy)) treeModel = model.stages[2] print(treeModel) spark.stop() 结果如下： 12345678910111213+----------+------------+--------------------+|prediction|indexedLabel| features|+----------+------------+--------------------+| 1.0| 1.0|(692,[98,99,100,1...|| 1.0| 1.0|(692,[121,122,123...|| 1.0| 1.0|(692,[122,123,148...|| 1.0| 1.0|(692,[124,125,126...|| 1.0| 1.0|(692,[126,127,128...|+----------+------------+--------------------+only showing top 5 rowsTest Error = 0.0357143 DecisionTreeClassificationModel (uid=DecisionTreeClassifier_4f508c37c4be93461970) of depth 1 with 3 nodes 3. 随机森林分类器与DT类似的，只不过选择RF来进行训练，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding: utf-8 -*-# @Time : 2019/8/5 16:56# @Author : buracagyang# @File : random_forest_classifier_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml import Pipelinefrom pyspark.ml.classification import RandomForestClassifierfrom pyspark.ml.feature import IndexToString, StringIndexer, VectorIndexerfrom pyspark.ml.evaluation import MulticlassClassificationEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;RandomForestClassifierExample&quot;)\\ .getOrCreate() # 处理方式如DT类似 data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) labelIndexer = StringIndexer(inputCol=&quot;label&quot;, outputCol=&quot;indexedLabel&quot;).fit(data) featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, outputCol=&quot;indexedFeatures&quot;, maxCategories=4).fit(data) (trainingData, testData) = data.randomSplit([0.7, 0.3]) # TRAIN RF rf = RandomForestClassifier(labelCol=&quot;indexedLabel&quot;, featuresCol=&quot;indexedFeatures&quot;, numTrees=10) # 将标签的索引转换为原始标签 labelConverter = IndexToString(inputCol=&quot;prediction&quot;, outputCol=&quot;predictedLabel&quot;, labels=labelIndexer.labels) # 在Pipeline中进行整个训练流程 pipeline = Pipeline(stages=[labelIndexer, featureIndexer, rf, labelConverter]) model = pipeline.fit(trainingData) predictions = model.transform(testData) predictions.select(&quot;predictedLabel&quot;, &quot;label&quot;, &quot;features&quot;).show(5) evaluator = MulticlassClassificationEvaluator(labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;) accuracy = evaluator.evaluate(predictions) print(&quot;Test Error = %g&quot; % (1.0 - accuracy)) rfModel = model.stages[2] print(rfModel) spark.stop() 结果如下： 12345678910111213+--------------+-----+--------------------+|predictedLabel|label| features|+--------------+-----+--------------------+| 0.0| 0.0|(692,[98,99,100,1...|| 0.0| 0.0|(692,[122,123,148...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|+--------------+-----+--------------------+only showing top 5 rowsTest Error = 0.0294118RandomForestClassificationModel (uid=RandomForestClassifier_421b9fdfb8d0ee9acde3) with 10 trees 4. 梯度提升树分类器如前文类似，选用梯度提升树（Gradient-boosted trees, GBTs）来进行训练，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-# @Time : 2019/8/5 17:09# @Author : buracagyang# @File : gradient_boosted_tree_classifier_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml import Pipelinefrom pyspark.ml.classification import GBTClassifierfrom pyspark.ml.feature import StringIndexer, VectorIndexerfrom pyspark.ml.evaluation import MulticlassClassificationEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;GradientBoostedTreeClassifierExample&quot;)\\ .getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) labelIndex = StringIndexer(inputCol=&quot;label&quot;, outputCol=&quot;indexedLabel&quot;).fit(data) featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, outputCol=&quot;indexedFeatures&quot;, maxCategories=4).fit(data) (trainingData, testData) = data.randomSplit([0.7, 0.3]) # train gbt = GBTClassifier(labelCol=&quot;indexedLabel&quot;, featuresCol=&quot;indexedFeatures&quot;, maxDepth=10) # 在管道中进行整个训练流程 pipeline = Pipeline(stages=[labelIndex, featureIndexer, gbt]) model = pipeline.fit(trainingData) # 预测 predictions = model.transform(testData) predictions.select(&quot;prediction&quot;, &quot;indexedLabel&quot;, &quot;features&quot;).show(5) # 计算测试误差 evaluator = MulticlassClassificationEvaluator(labelCol=&quot;indexedLabel&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;) accuracy = evaluator.evaluate(predictions) print(&quot;Test Error = %g&quot; % (1.0 - accuracy)) gbtModel = model.stages[2] print(gbtModel) spark.stop() 结果如下： 12345678910111213+----------+------------+--------------------+|prediction|indexedLabel| features|+----------+------------+--------------------+| 1.0| 1.0|(692,[95,96,97,12...|| 1.0| 1.0|(692,[100,101,102...|| 1.0| 1.0|(692,[122,123,148...|| 1.0| 1.0|(692,[123,124,125...|| 1.0| 1.0|(692,[124,125,126...|+----------+------------+--------------------+only showing top 5 rowsTest Error = 0GBTClassificationModel (uid=GBTClassifier_4a1fa549ada75fa70795) with 20 trees 5. 多层感知器分类器多层感知器分类器（Multilayer perceptron classifier, MLPC）是基于前馈人工神经网络的分类器。 MLPC由多层节点组成。 每层完全连接到网络中的下一层。 输入层中的节点表示输入数据。 所有其他节点通过输入与节点权重$w$和偏差$b$的线性组合将输入映射到输出，并应用激活函数。 这可以用矩阵形式写入MLPC，$K + 1$层如下： y(x)= f_K（... f_2（w^T_2f_1（w^T_1x+ b_1）+ b_2）... +b_K） \\tag{1}中间层中的节点使用sigmoid函数： f（z_i）= \\frac{1}{1+e^{-z_i}} \\tag{2}输出层中的节点使用softmax函数： f（z_i）= \\frac{e^{z_i}}{\\sum_{k=1}^Ke^{z_K}} \\tag{3}输出层中的节点数$N$对应于类的数量。 MLPC采用反向传播来学习模型。 我们使用逻辑损失函数进行优化，使用L-BFGS作为优化过程。 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*-# @Time : 2019/8/5 17:30# @Author : buracagyang# @File : multilayer_perceptron_classification.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.classification import MultilayerPerceptronClassifierfrom pyspark.ml.evaluation import MulticlassClassificationEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;multilayer_perceptron_classification_example&quot;).getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_multiclass_classification_data.txt&quot;) (train_data, test_data) = data.randomSplit([0.6, 0.4], seed=2019) # 输入层为features的大小(4)，输出层为labels的大小(3) layers = [4, 5, 4, 3] # train trainer = MultilayerPerceptronClassifier(maxIter=100, layers=layers, blockSize=128, seed=2019) model = trainer.fit(train_data) # 计算在测试集上的准确率 predictions = model.transform(test_data) predictions.select(&quot;prediction&quot;, &quot;label&quot;, &quot;features&quot;).show(5) evaluator = MulticlassClassificationEvaluator(labelCol=&quot;label&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;) accuracy = evaluator.evaluate(predictions) print(&quot;Test Error = %g&quot; % (1.0 - accuracy)) print(model) spark.stop() 结果如下： 12345678910111213+----------+-----+--------------------+|prediction|label| features|+----------+-----+--------------------+| 0.0| 0.0|(4,[0,1,2,3],[-0....|| 0.0| 0.0|(4,[0,1,2,3],[-0....|| 0.0| 0.0|(4,[0,1,2,3],[0.0...|| 0.0| 0.0|(4,[0,1,2,3],[0.0...|| 0.0| 0.0|(4,[0,1,2,3],[0.1...|+----------+-----+--------------------+only showing top 5 rowsTest Error = 0.0172414MultilayerPerceptronClassifier_4f01847fd0f3f4531e41 6. 线性支持向量机示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-# @Time : 2019/8/5 17:48# @Author : buracagyang# @File : linearsvc.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.classification import LinearSVCfrom pyspark.ml.evaluation import BinaryClassificationEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;linearSVC Example&quot;)\\ .getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) (trainingData, testData) = data.randomSplit([0.7, 0.3], seed=2019) lsvc = LinearSVC(maxIter=10, regParam=0.1) lsvcModel = lsvc.fit(trainingData) # print(&quot;Coefficients: &quot; + str(lsvcModel.coefficients)) # print(&quot;Intercept: &quot; + str(lsvcModel.intercept)) # 计算在测试集上的准确率 predictions = lsvcModel.transform(testData) predictions.select(&quot;prediction&quot;, &quot;label&quot;, &quot;features&quot;).show(5) evaluator = BinaryClassificationEvaluator(labelCol=&quot;label&quot;, rawPredictionCol=&quot;prediction&quot;, metricName=&quot;areaUnderROC&quot;) accuracy = evaluator.evaluate(predictions) print(&quot;Test Error = %g&quot; % (1.0 - accuracy)) print(lsvcModel) spark.stop() 结果如下： 12345678910111213+----------+-----+--------------------+|prediction|label| features|+----------+-----+--------------------+| 0.0| 0.0|(692,[100,101,102...|| 0.0| 0.0|(692,[121,122,123...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|+----------+-----+--------------------+only showing top 5 rowsTest Error = 0LinearSVC_409bb95a7222b3ec2faa 7. One-vs-Rest分类器OneVsRest作为Estimator实现。 对于基类分类器，它接受分类器的实例，并为每个k类创建二进制分类问题。 训练i类的分类器来预测标签是否为i，将类i与所有其他类区分开来。通过评估每个二元分类器来完成预测，并且将自信(most confident)的分类器的索引输出为标签。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-# @Time : 2019/8/5 18:05# @Author : buracagyang# @File : one_vs_rest_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.classification import LogisticRegression, OneVsRestfrom pyspark.ml.evaluation import MulticlassClassificationEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;OneVsRestExample&quot;).getOrCreate() inputData = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_multiclass_classification_data.txt&quot;) (train, test) = inputData.randomSplit([0.8, 0.2], seed=2019) # 创建一个分类器 lr = LogisticRegression(maxIter=10, tol=1E-6, fitIntercept=True) # 实例化One Vs Rest分类器 ovr = OneVsRest(classifier=lr) ovrModel = ovr.fit(train) predictions = ovrModel.transform(test) evaluator = MulticlassClassificationEvaluator(metricName=&quot;accuracy&quot;) accuracy = evaluator.evaluate(predictions) print(&quot;Test Error = %g&quot; % (1.0 - accuracy)) spark.stop() 结果如下： 1Test Error = 0.030303 8. 朴素贝叶斯示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-# @Time : 2019/8/5 20:08# @Author : buracagyang# @File : naive_bayes_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.classification import NaiveBayesfrom pyspark.ml.evaluation import MulticlassClassificationEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;NaiveBayesExample&quot;).getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) splits = data.randomSplit([0.6, 0.4], seed=2019) train = splits[0] test = splits[1] # train nb = NaiveBayes(smoothing=1.0, modelType=&quot;multinomial&quot;) model = nb.fit(train) predictions = model.transform(test) predictions.show(5) evaluator = MulticlassClassificationEvaluator(labelCol=&quot;label&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;accuracy&quot;) accuracy = evaluator.evaluate(predictions) print(&quot;Test Error = %g&quot; % (1.0 - accuracy)) spark.stop() 结果如下： 123456789101112+-----+--------------------+--------------------+-----------+----------+|label| features| rawPrediction|probability|prediction|+-----+--------------------+--------------------+-----------+----------+| 0.0|(692,[100,101,102...|[-98334.092010814...| [1.0,0.0]| 0.0|| 0.0|(692,[121,122,123...|[-220853.86656723...| [1.0,0.0]| 0.0|| 0.0|(692,[124,125,126...|[-244907.22501172...| [1.0,0.0]| 0.0|| 0.0|(692,[124,125,126...|[-149338.93024598...| [1.0,0.0]| 0.0|| 0.0|(692,[124,125,126...|[-216105.12197743...| [1.0,0.0]| 0.0|+-----+--------------------+--------------------+-----------+----------+only showing top 5 rowsTest Error = 0","link":"/2019/08/02/spark-classification-and-regression-1/"},{"title":"【Spark】分类和回归算法-回归","text":"本节主要讲Spark ML中关于回归算法的实现。示例的算法Demo包含：线性回归、广义线性回归、决策树回归、随机森林回归、梯度提升树回归等。 1. 线性回归(Linear regression)与logistic regression类似的，直接附上示例代码吧： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# @Time : 2019/8/7 10:11# @Author : buracagyang# @File : linear_regression_with_elastic_net.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.regression import LinearRegressionfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;LinearRegressionWithElasticNet&quot;).getOrCreate() training = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_linear_regression_data.txt&quot;) lr = LinearRegression(maxIter=20, regParam=0.01, elasticNetParam=0.6) lrModel = lr.fit(training) # 参数和截距项 # print(&quot;Coefficients: %s&quot; % str(lrModel.coefficients)) # print(&quot;Intercept: %s&quot; % str(lrModel.intercept)) # 模型评估指标 trainingSummary = lrModel.summary print(&quot;numIterations: %d&quot; % trainingSummary.totalIterations) print(&quot;objectiveHistory: %s&quot; % str(trainingSummary.objectiveHistory)) trainingSummary.residuals.show() print(&quot;RMSE: %f&quot; % trainingSummary.rootMeanSquaredError) print(&quot;r2: %f&quot; % trainingSummary.r2) spark.stop() 结果如下($r^2$如此低。。。。)： 123456789101112131415numIterations: 8objectiveHistory: [0.49999999999999994, 0.4931849471651455, 0.4863393782275527, 0.48633557300904495, 0.48633543657045664, 0.4863354337756586, 0.4863354337094886, 0.4863354337092549]+-------------------+| residuals|+-------------------+| -10.9791066152217|| 0.9208605107751258|| -4.608888656779226||-20.424003572582702||-10.316545030639608|+-------------------+only showing top 5 rowsRMSE: 10.163110r2: 0.027836 2. 广义线性回归(Generalized linear regression)与假设输出遵循高斯分布的线性回归相反，广义线性模型（GLMs）是线性模型的规范，其中响应变量$Y_i$遵循指数分布族的一些分布。 Spark的GeneralizedLinearRegression接口允许灵活地指定GLMs，可用于各种类型的预测问题，包括线性回归，泊松回归，逻辑回归等。目前在spark.ml中，仅支持指数族分布的子集，在下面列出。 分布族 响应变量类型 Supported Links 高斯分布 Continuous Identity*,Log,Inverse Binomial 二元变量 Logit*, Probit, CLogLog 泊松分布 数值 Log*, Identity, Sqrt Gamma分布 连续变量 Inverse*, Identity, Log Tweedie分布 zero-inflated continuous Power link function *标准Link 注意：Spark目前通过其GeneralizedLinearRegression接口仅支持4096个特征，如果超出此约束，则会抛出异常。尽管如此，对于线性回归和逻辑回归，可以使用LinearRegression和LogisticRegression估计来训练具有更多特征的模型(对于高纬特征集没啥用。。。)。 GLMs需要指数族分布，这些分布可以用“标准(canonical)”或“自然(natural)”形式写成，也就是自然指数族分布。自然指数分布族(natural exponential family distribution)的形式如下： f_Y(y|\\theta, \\tau) = h(y, \\tau)exp(\\frac{\\theta.y - A(\\theta)}{d(\\tau)}) \\tag{1}其中$\\theta$是parameter of interest，$\\tau$是dispersion parameter。 在GLMs中，假设响应变量$Y_i$是从自然指数分布族中提取的： Y_i \\sim f(\\cdot|\\theta_i, \\tau) \\tag{2}其中，parameter of interest $\\theta_i$与响应变量的期望值$\\mu_i$相关: \\mu_i = A'(\\theta_i) \\tag{3}这里，$A’(\\theta_i)$根据选择的分布形式定义，GLMs还支持指定的链接函数(link function)，该函数定义响应变量的期望值$\\mu_i$与线性预测值$\\eta_i$之间的关系： g(\\mu_i) = \\eta_i = \\vec{x_i}^T \\cdot \\vec{\\beta} \\tag{4}通常，选择链接函数(link function)使得$A’ = g^{-1}$，其产生的parameter of interest $θ$与线性预测值$\\eta$之间的简化关系。 在这种情况下，链接函数$g(μ)$被称为“标准”(“canonical”)链接函数。 \\theta_i = A'^{-1}(\\mu_i) = g(g^{-1}(\\eta_i)) = \\eta_i \\tag{5}一个GLM根据最大化似然概率函数值寻找回归系数$\\vec{\\beta}$: \\max_{\\vec{\\beta}} \\mathcal{L}(\\vec{\\theta}|\\vec{y},X) = \\prod_{i=1}^{N} h(y_i, \\tau) \\exp{\\left(\\frac{y_i\\theta_i - A(\\theta_i)}{d(\\tau)}\\right)} \\tag{6}其中the parameter of interest $\\theta_i$与回归系数$\\vec{\\beta}$的关系为： \\theta_i = A'^{-1}(g^{-1}(\\vec{x_i} \\cdot \\vec{\\beta})) \\tag{7}示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-# @Time : 2019/8/7 13:12# @Author : buracagyang# @File : generalized_linear_regression_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.sql import SparkSessionfrom pyspark.ml.regression import GeneralizedLinearRegressionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;GeneralizedLinearRegressionExample&quot;).getOrCreate() dataset = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_linear_regression_data.txt&quot;) glr = GeneralizedLinearRegression(family=&quot;gaussian&quot;, link=&quot;identity&quot;, maxIter=10, regParam=0.3) model = glr.fit(dataset) # 参数和截距项 print(&quot;Coefficients: &quot; + str(model.coefficients)) print(&quot;Intercept: &quot; + str(model.intercept)) # 通不过模型检验啊... summary = model.summary print(&quot;Coefficient Standard Errors: &quot; + str(summary.coefficientStandardErrors)) print(&quot;T Values: &quot; + str(summary.tValues)) print(&quot;P Values: &quot; + str(summary.pValues)) print(&quot;Dispersion: &quot; + str(summary.dispersion)) print(&quot;Null Deviance: &quot; + str(summary.nullDeviance)) print(&quot;Residual Degree Of Freedom Null: &quot; + str(summary.residualDegreeOfFreedomNull)) print(&quot;Deviance: &quot; + str(summary.deviance)) print(&quot;Residual Degree Of Freedom: &quot; + str(summary.residualDegreeOfFreedom)) print(&quot;AIC: &quot; + str(summary.aic)) print(&quot;Deviance Residuals: &quot;) summary.residuals().show() spark.stop() 3. 决策树回归(Decision tree regression)与决策树分类类似，直接附上示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# @Time : 2019/8/7 13:57# @Author : buracagyang# @File : decision_tree_regression_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml import Pipelinefrom pyspark.ml.regression import DecisionTreeRegressorfrom pyspark.ml.feature import VectorIndexerfrom pyspark.ml.evaluation import RegressionEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;DecisionTreeRegressionExample&quot;).getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) # 自动识别分类特性，并对它们进行索引。指定maxCategories，这样存在 &gt; 4个不同值的特征将被视为连续的。 featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, outputCol=&quot;indexedFeatures&quot;, maxCategories=4).fit(data) (trainingData, testData) = data.randomSplit([0.7, 0.3], seed=2019) dt = DecisionTreeRegressor(featuresCol=&quot;indexedFeatures&quot;) # 通过Pipeline进行训练 pipeline = Pipeline(stages=[featureIndexer, dt]) model = pipeline.fit(trainingData) predictions = model.transform(testData) predictions.select(&quot;prediction&quot;, &quot;label&quot;, &quot;features&quot;).show(5) evaluator = RegressionEvaluator(labelCol=&quot;label&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;rmse&quot;) rmse = evaluator.evaluate(predictions) print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse) treeModel = model.stages[1] print(treeModel) spark.stop() 结果如下： 12345678910111213+----------+-----+--------------------+|prediction|label| features|+----------+-----+--------------------+| 0.0| 0.0|(692,[100,101,102...|| 0.0| 0.0|(692,[121,122,123...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|+----------+-----+--------------------+only showing top 5 rowsRoot Mean Squared Error (RMSE) on test data = 0.297044DecisionTreeRegressionModel (uid=DecisionTreeRegressor_4089a3fc367ac7a943d9) of depth 2 with 5 nodes 4. 随机森林回归(Random forest regression)与决策树回归类似，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# @Time : 2019/8/7 14:05# @Author : buracagyang# @File : random_forest_regressor_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml import Pipelinefrom pyspark.ml.regression import RandomForestRegressorfrom pyspark.ml.feature import VectorIndexerfrom pyspark.ml.evaluation import RegressionEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;RandomForestRegressorExample&quot;).getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) # 自动识别分类特性，并对它们进行索引。指定maxCategories，这样存在 &gt; 4个不同值的特征将被视为连续的。 featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, outputCol=&quot;indexedFeatures&quot;, maxCategories=4).fit(data) (trainingData, testData) = data.randomSplit([0.7, 0.3], seed=2019) rf = RandomForestRegressor(featuresCol=&quot;indexedFeatures&quot;) # 通过Pipeline进行训练 pipeline = Pipeline(stages=[featureIndexer, rf]) model = pipeline.fit(trainingData) predictions = model.transform(testData) predictions.select(&quot;prediction&quot;, &quot;label&quot;, &quot;features&quot;).show(5) evaluator = RegressionEvaluator(labelCol=&quot;label&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;rmse&quot;) rmse = evaluator.evaluate(predictions) print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse) rfModel = model.stages[1] print(rfModel) spark.stop() 结果如下： 12345678910111213+----------+-----+--------------------+|prediction|label| features|+----------+-----+--------------------+| 0.4| 0.0|(692,[100,101,102...|| 0.0| 0.0|(692,[121,122,123...|| 0.0| 0.0|(692,[124,125,126...|| 0.1| 0.0|(692,[124,125,126...|| 0.15| 0.0|(692,[124,125,126...|+----------+-----+--------------------+only showing top 5 rowsRoot Mean Squared Error (RMSE) on test data = 0.141421RandomForestRegressionModel (uid=RandomForestRegressor_4dc1b1ad32480cc89ddc) with 20 trees 5. 梯度提升树回归(Gradient-boosted tree regression)示例代码如下(需要注意的是，对于这个示例样本集，GBTRegressor只需要一次迭代，但是在通常情况下是不止一次的~)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: utf-8 -*-# @Time : 2019/8/7 14:11# @Author : buracagyang# @File : gradient_boosted_tree_regressor_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml import Pipelinefrom pyspark.ml.regression import GBTRegressorfrom pyspark.ml.feature import VectorIndexerfrom pyspark.ml.evaluation import RegressionEvaluatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;GradientBoostedTreeRegressorExample&quot;).getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) featureIndexer = VectorIndexer(inputCol=&quot;features&quot;, outputCol=&quot;indexedFeatures&quot;, maxCategories=4).fit(data) (trainingData, testData) = data.randomSplit([0.7, 0.3], seed=2019) gbt = GBTRegressor(featuresCol=&quot;indexedFeatures&quot;, maxIter=10) # 通过Pipeline进行训练 pipeline = Pipeline(stages=[featureIndexer, gbt]) model = pipeline.fit(trainingData) predictions = model.transform(testData) predictions.select(&quot;prediction&quot;, &quot;label&quot;, &quot;features&quot;).show(5) evaluator = RegressionEvaluator(labelCol=&quot;label&quot;, predictionCol=&quot;prediction&quot;, metricName=&quot;rmse&quot;) rmse = evaluator.evaluate(predictions) print(&quot;Root Mean Squared Error (RMSE) on test data = %g&quot; % rmse) gbtModel = model.stages[1] print(gbtModel) spark.stop() 结果如下： 12345678910111213+----------+-----+--------------------+|prediction|label| features|+----------+-----+--------------------+| 0.0| 0.0|(692,[100,101,102...|| 0.0| 0.0|(692,[121,122,123...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|| 0.0| 0.0|(692,[124,125,126...|+----------+-----+--------------------+only showing top 5 rowsRoot Mean Squared Error (RMSE) on test data = 0.297044GBTRegressionModel (uid=GBTRegressor_46239bc64cc2f59b1fb5) with 10 trees 6. 生存回归(Survival regression)在spark.ml中，实现了加速失败时间（Accelerated failure time, AFT）模型，它是一个用于删失数据的参数生存回归模型（survival regression model）。 它描述了生存时间对数的模型，因此它通常被称为生存分析的对数线性模型。 与为相同目的设计的比例风险模型不同，AFT模型更易于并行化，因为每个实例都独立地为目标函数做出贡献。 给定协变量$x’$的值，对于受试者$i = 1，…，n$的随机寿命$t_i$(random lifetime)，可能进行右截尾(right-censoring)，AFT模型下的似然函数如下： L(\\beta,\\sigma)=\\prod_{i=1}^n[\\frac{1}{\\sigma}f_{0}(\\frac{\\log{t_{i}}-x^{'}\\beta}{\\sigma})]^{\\delta_{i}}S_{0}(\\frac{\\log{t_{i}}-x^{'}\\beta}{\\sigma})^{1-\\delta_{i}} \\tag{8}其中$\\delta_i$是事件发生的指标，即是否经过截尾的。 使用$\\epsilon_{i}=\\frac{\\log{t_{i}}-x^{‘}\\beta}{\\sigma}$，对数似然函数采用以下形式： \\iota(\\beta,\\sigma)=\\sum_{i=1}^{n}[-\\delta_{i}\\log\\sigma+\\delta_{i}\\log{f_{0}}(\\epsilon_{i})+(1-\\delta_{i})\\log{S_{0}(\\epsilon_{i})}] \\tag{9}其中$S_{0}(\\epsilon_{i})$是幸存函数基线，$f_{0}(\\epsilon_{i})$是相应的密度函数。 最常用的AFT模型基于Weibull分布的生存时间。 生命周期的Weibull分布对应于生命日志的极值分布(the extreme value distribution for the log of the lifetime)，$S_{0}(\\epsilon)$函数是： S_{0}(\\epsilon_{i})=\\exp(-e^{\\epsilon_{i}}) \\tag{10}其中$f_{0}(\\epsilon_{i})$函数形式为： f_{0}(\\epsilon_{i})=e^{\\epsilon_{i}}\\exp(-e^{\\epsilon_{i}}) \\tag{11}带有Weibull生命分布的AFT模型的对数似然函数是： \\iota(\\beta,\\sigma)= -\\sum_{i=1}^n[\\delta_{i}\\log\\sigma-\\delta_{i}\\epsilon_{i}+e^{\\epsilon_{i}}] \\tag{12}由于最小化负对数似然函数等效于最大化后验概率的，我们用于优化的损失函数是$-\\iota(\\beta,\\sigma)$。 $\\beta$和$\\log\\sigma$的梯度函数分别为： \\begin{eqnarray} \\frac{\\partial (-\\iota)}{\\partial \\beta} &=& \\sum_{1=1}^{n}[\\delta_{i}-e^{\\epsilon_{i}}]\\frac{x_{i}}{\\sigma} \\\\ \\frac{\\partial (-\\iota)}{\\partial (\\log\\sigma)} &=& \\sum_{i=1}^{n}[\\delta_{i}+(\\delta_{i}-e^{\\epsilon_{i}})\\epsilon_{i}] \\end{eqnarray} \\tag{13}AFT模型可以被转换为凸优化问题，即，找到取决于系数向量$\\beta$和尺度参数的对数$\\log\\sigma$的凸函数的最小化的任务$-\\iota(\\beta,\\sigma)$。 实现的优化算法是L-BFGS。 实现匹配R的生存函数的幸存结果。 当拟合AFTSurvivalRegressionModel而不截断具有常量非零列的数据集时，Spark MLlib为常量非零列输出零系数。 此与R survival :: survreg不同 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-# @Time : 2019/8/7 14:38# @Author : buracagyang# @File : aft_survival_regression.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.regression import AFTSurvivalRegressionfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;AFTSurvivalRegressionExample&quot;).getOrCreate() training = spark.createDataFrame([ (1.218, 1.0, Vectors.dense(1.560, -0.605)), (2.949, 0.0, Vectors.dense(0.346, 2.158)), (3.627, 0.0, Vectors.dense(1.380, 0.231)), (0.273, 1.0, Vectors.dense(0.520, 1.151)), (4.199, 0.0, Vectors.dense(0.795, -0.226))], [&quot;label&quot;, &quot;censor&quot;, &quot;features&quot;]) quantileProbabilities = [0.3, 0.6] aft = AFTSurvivalRegression(quantileProbabilities=quantileProbabilities, quantilesCol=&quot;quantiles&quot;) model = aft.fit(training) print(&quot;Coefficients: &quot; + str(model.coefficients)) print(&quot;Intercept: &quot; + str(model.intercept)) print(&quot;Scale: &quot; + str(model.scale)) model.transform(training).show(truncate=False) spark.stop() 结果如下： 123456789101112Coefficients: [-0.49631114666506776,0.1984443769993409]Intercept: 2.6380946151Scale: 1.54723455744+-----+------+--------------+-----------------+---------------------------------------+|label|censor|features |prediction |quantiles |+-----+------+--------------+-----------------+---------------------------------------+|1.218|1.0 |[1.56,-0.605] |5.718979487634966|[1.1603238947151588,4.995456010274735] ||2.949|0.0 |[0.346,2.158] |18.07652118149563|[3.667545845471802,15.789611866277884] ||3.627|0.0 |[1.38,0.231] |7.381861804239103|[1.4977061305190853,6.447962612338967] ||0.273|1.0 |[0.52,1.151] |13.57761250142538|[2.7547621481507067,11.859872224069784]||4.199|0.0 |[0.795,-0.226]|9.013097744073846|[1.8286676321297735,7.872826505878384] |+-----+------+--------------+-----------------+---------------------------------------+ 7. Isotonic regressionIsotonic regression属于回归算法族。 对 isotonic regression定义如下，给定一组有限的实数$Y = {y_1, y_2, …, y_n}$表示观察到的响应，$X = {x_1, x_2, …, x_n}$表示未知的响应值，拟合一个函数以最小化： f(x) = \\sum_{i=1}^n w_i (y_i - x_i)^2 \\tag{14}以$x_1\\le x_2\\le …\\le x_n$为完整的顺序，其中$w_i$是正权重。 由此产生的函数称为isotonic regression，它是独一无二的。 它可以被视为有顺序限制下的最小二乘问题。 基本上isotonic regression是最适合原始数据点的单调函数。 Spark实现了一个相邻违规算法的池，该算法使用一种并行化isotonic regression的方法。 训练输入是一个DataFrame，它包含三列标签，label, features 和 weight。 此外，IsotonicRegression算法有一个isotonis(默认为true)的可选参数。 表示isotonic regression是isotonic的（单调递增的）还是antitonic的（单调递减的）。 训练返回IsotonicRegressionModel，可用于预测已知和未知特征的标签。isotonic regression的结果被视为分段线性函数。因此预测规则是： 如果预测输入与训练特征完全匹配，则返回相关联的预测。如果有多个具有相同特征的预测，则返回其中一个。哪一个是未定义的（与java.util.Arrays.binarySearch相同）。 如果预测输入低于或高于所有训练特征，则分别返回具有最低或最高特征的预测。如果存在具有相同特征的多个预测，则分别返回最低或最高。 如果预测输入落在两个训练特征之间，则将预测视为分段线性函数，并且根据两个最接近特征的预测来计算内插值。如果存在具有相同特征的多个值，则使用与先前点相同的规则。 示例代码如下： 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-# @Time : 2019/8/7 14:56# @Author : buracagyang# @File : isotonic_regression_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.regression import IsotonicRegressionfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession.builder.appName(&quot;IsotonicRegressionExample&quot;).getOrCreate() dataset = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_isotonic_regression_libsvm_data.txt&quot;) model = IsotonicRegression().fit(dataset) print(&quot;Boundaries in increasing order: %s\\n&quot; % str(model.boundaries)) print(&quot;Predictions associated with the boundaries: %s\\n&quot; % str(model.predictions)) model.transform(dataset).show(5) spark.stop() 结果如下： 1234567891011121314Boundaries in increasing order: [0.01,0.17,0.18,0.27,0.28,0.29,0.3,0.31,0.34,0.35,0.36,0.41,0.42,0.71,0.72,0.74,0.75,0.76,0.77,0.78,0.79,0.8,0.81,0.82,0.83,0.84,0.85,0.86,0.87,0.88,0.89,1.0]Predictions associated with the boundaries: [0.15715271294117644,0.15715271294117644,0.189138196,0.189138196,0.20040796,0.29576747,0.43396226,0.5081591025000001,0.5081591025000001,0.54156043,0.5504844466666667,0.5504844466666667,0.563929967,0.563929967,0.5660377366666667,0.5660377366666667,0.56603774,0.57929628,0.64762876,0.66241713,0.67210607,0.67210607,0.674655785,0.674655785,0.73890872,0.73992861,0.84242733,0.89673636,0.89673636,0.90719021,0.9272055075,0.9272055075]+----------+--------------+-------------------+| label| features| prediction|+----------+--------------+-------------------+|0.24579296|(1,[0],[0.01])|0.15715271294117644||0.28505864|(1,[0],[0.02])|0.15715271294117644||0.31208567|(1,[0],[0.03])|0.15715271294117644||0.35900051|(1,[0],[0.04])|0.15715271294117644||0.35747068|(1,[0],[0.05])|0.15715271294117644|+----------+--------------+-------------------+only showing top 5 rows","link":"/2019/08/07/spark-classification-and-regression-2/"},{"title":"【Graph Embedding】SDNE","text":"关于Graph Embedding系列的论文翻译解读文章： 【Graph Embedding】DeepWalk 【Graph Embedding】line 【Graph Embedding】node2Vec 【Graph Embedding】SDNE 【Graph Embedding】struc2vec 参考资料 paper: https://www.kdd.org/kdd2016/papers/files/rfp0191-wangAemb.pdf 摘要网络embedding是学习网络中点的低维表示的一种重要方法，目的是捕获和保持网络结构。现有的网络embedding方法几乎都采用了浅层模型。然而，由于底层网络结构复杂，浅层模型无法捕捉到高度非线性的网络结构，导致网络表示不够理想。因此，如何找到一种能够有效捕获高度非线性网络结构并保持全局和局部结构的方法是一个开放而重要的问题。为了解决这一问题，本文提出了一种结构化的深度网络嵌入方法，即SDNE。更具体地说，我们首先提出了一个具有多层非线性函数的半监督深度模型，从而能够捕获高度非线性的网络结构。在此基础上，我们提出了利用一阶近似和二阶近似共同保持网络结构的方法。非监督组件使用二阶接近度来捕获全局网络结构。而一阶邻近度作为监督分量中的监督信息，以保持局部网络结构。该方法通过在半监督深度模型中联合优化，既保留了局部网络结构又保留了全局网络结构，对稀疏网络具有较强的鲁棒性。在实证方面，我们对5个真实世界的网络进行了实验，包括一个语言网络、一个引文网络和3个社交网络。结果表明，与基线相比，该方法能较好地重建原始网络，并在多标签分类、链接预测和可视化三个方面取得了显著的效果。 1. 介绍如今，网络无处不在，许多真实世界的应用程序需要在这些网络中挖掘信息。例如，Twitter中的推荐系统旨在挖掘社交网络中用户喜欢的tweets。网络广告投放往往需要将用户聚集到社交网络的社区中。因此，在网络中挖掘信息是非常重要的。其中一个基本问题是如何学习有用的网络表示[5]。一种有效的方法是将网络嵌入到一个低维空间中，即学习每个顶点的向量表示，目的是在学习的嵌入空间中重建网络。因此，在网络中挖掘信息，如信息检索[34]，分类[15]和聚类[20]可以直接在低维空间中进行。 学习网络表征面临以下重大挑战: (1)高度非线性:如[19]所述，网络底层结构高度非线性。因此，如何设计一个模型来捕捉高度非线性的结构是相当困难的。(2)保持结构:为了支持分析网络的应用，需要通过网络嵌入来保持网络结构。然而，网络的底层结构非常复杂。顶点的相似性依赖于局部和全局网络结构。因此，如何同时保持局部和全局结构是一个棘手的问题。(3)稀疏性:许多真实世界的网络常常是如此的稀疏，以至于仅利用非常有限的观测链路不足以达到令人满意的性能。 在过去的几十年里，许多网络嵌入方法被提出，它们采用了浅模型，如IsoMAP[29]，Laplacian特征映射(LE)[1]和Line[26]。然而，由于浅层模型[2]的表示法能力有限，难以捕捉到高度非线性的网络结构[30]。虽然有些方法采用了核心技术[32]，但如[36]所述，核心方法也是浅层模型，不能很好地捕捉高度非线性的结构。 为了更好地捕获高度非线性的网络结构，本文提出了一种学习网络顶点表示的深度模型。这是由最近成功的深度学习驱动的，深度学习被证明具有强大的表示能力来学习数据[2]的复杂结构，并在处理图像[15]、文本[25]和音频数据[10]方面取得了实质性的成功。特别地，在我们提出的模型中，我们设计了一个由多个非线性函数组成的多层体系结构。多层非线性函数的组合可以将数据映射到一个高度非线性的潜在空间，从而能够捕捉到高度非线性的网络结构。 为了解决深度模型的结构保持和稀疏性问题，我们进一步提出将一阶和二阶近似[26]联合应用到学习过程中。一阶近似是仅在由边连接的顶点之间的局部两两相似，这是局部网络结构的特征。然而，由于网络的稀疏性，许多有效的链接都丢失了。因此，一阶邻近度不足以表示网络结构。因此，我们进一步提出二阶邻近度来表示顶点邻域结构的相似性，以捕捉全局网络结构。利用一阶和二阶邻近性，我们可以分别很好地刻画局部和全局网络结构。为了在深度模型中保护局部和全局网络结构,我们提出半监督架构,非监督的组件可以利用二阶距离保护全局网络结构而监督组件利用一阶距离作为监督信息保存局部的网络结构。因此，所学习的表示法可以很好地保持局部和全局网络结构。此外，如图1所示，具有二阶接近度的顶点对的数量要比具有一阶接近度的顶点对的数量大得多。因此，二阶邻近度的引入能够在描述网络结构方面提供更多的信息。结果表明，该方法对稀疏网络具有较强的鲁棒性。 根据经验，我们在五个真实的网络数据集和四个真实的应用程序上进行了实验。结果表明，与基线相比，我们的方法生成的表示能更好地重构原始网络，并在各种任务和各种网络(包括非常稀疏网络)上获得可观的收益。结果表明，我们在高度非线性空间中学习的表示方法能够很好地保持网络结构，并且对稀疏网络具有较强的鲁棒性。 综上所述，本文的贡献如下: 提出了一种结构化的深度网络embedding方法，即SDNE。该方法能够将数据映射到一个高度非线性的潜在空间中，从而保持网络结构，对稀疏网络具有较强的鲁棒性。 提出了一种新的半监督结构的深度模型，该模型同时优化了一阶近似和二阶近似。结果表明，该算法保持了局部和全局网络结构，对稀疏网络具有较强的鲁棒性。 该方法在5个实际数据集和4个应用场景中得到了广泛的评价。结果表明，该方法在多标签分类、重建、链接预测和可视化等方面具有较好的实用性。具体来说，我们的方法可以在标记数据缺乏的情况下实现比基线更显著的改进(20%)。在某些情况下，我们减少60%的训练样本，但仍然可以获得更好的性能。 2. 相关工作2.1 深度神经网络表示学习长期以来一直是机器学习的一个重要问题，许多研究工作都是针对样本的表示学习[3,35]。深度神经网络的最新进展表明，它们具有强大的表示能力[12]，可以为许多类型的数据生成非常有用的表示。例如，[15]提出了一个七层卷积神经网络来生成图像表示进行分类。[33]提出了一个多模态深度模型来学习图像-文本的统一表示来实现跨模态检索任务。 然而，就我们所知，深度学习用来处理网络的工作很少，尤其是学习网络表示的工作。在[9]中，采用限制玻尔兹曼机进行协同过滤。[30]采用深度自动编码器进行图形聚类。[5]提出了一种异构深度模型来进行异构数据嵌入。我们与这些作品有两个不同之处。首先，目标不同。我们的工作重点是学习低维结构保留的网络表示，这些表示可以用于任务之间。其次，我们考虑顶点之间的一阶和二阶邻近性，以保持局部和全局网络结构。但它们只关注一阶信息。 2.2 网络Embedding我们的工作解决了网络嵌入的问题，即学习网络的表示。一些早期的作品像Local Linear Embedding(LLE)[22]、IsoMAP[29]首先基于特征向量构造亲和图，然后求解主导特征向量作为网络表示。最近,[26]设计了两个试图分别捕获局部和全局网络结构的损失函数。此外，[4]扩展了工作以利用高阶信息。尽管这些网络embedding方法取得了成功，但它们都采用了浅层模型。如前所述，浅层模型很难有效地捕获底层网络中高度非线性的结构。此外，尽管他们中的一些人试图使用一阶和高阶邻近性来保存局部和全局网络结构，但他们分别学习这些表示并简单地连接这些表示。显然，在一个统一的架构中同时对它们进行建模来捕获局部和全局网络结构是次优的。 DeepWalk[21]结合随机漫步和跳跃图来学习网络表示。虽然在经验上是有效的，但它缺乏一个明确的目标函数来阐明如何保持网络结构。它倾向于只保留二级邻近性。然而，我们的方法设计了一个明确的目标函数，它通过保留一阶和二阶邻近性来同时保留局部和全局结构。 3. SDNE(Structural Deep Network Embedding)首先定义问题。然后介绍了SDNE的半监督深度模型。最后对模型进行了讨论和分析。 3.1 问题定义首先给出图的定义。 定义1. 图 设$G = (V, E)$是一个给定的网络。其中$V = \\{v_1, …, v_n\\}$代表顶点的集合，$E = \\{e_{i, j}\\}_{i,j=1}^n$代表边的集合，每条边$e_{i,j}$有一个权重$s_{i,j} \\geq 0$。如果$v_i$和$v_j$没有连接，则$s_{i,j} = 0$。此外，对于未加权的图$s_{i,j} = 1$，对于加权图$s_{i,j} &gt; 0$。 定义2. 一阶相似度 一阶近似描述一对顶点之间的两两相似性。对于任意一对顶点，如果$s_{i,j} &gt; 0$，则$v_i$与$v_j$之间存在正一阶近似。否则，$v_i$和$v_j$之间的一阶相似度为0 定义3. 二阶相似度 一对顶点之间的二阶相似度描述了相邻结构的邻近性。设$\\cal N_u = \\{s_{u,1}, …, s_{u, |V|}\\}$表示$v_u$和其他顶点之间的一阶相似度。然后，二阶相似度由$\\cal N_u$和$\\cal N_v$的相似度决定。 直观地说，二阶相似性假设如果两个顶点有许多共同的邻居，它们就趋向于相似。这种假设在很多领域都被证明是合理的[6,14]。例如，在语言学中，如果单词总是被相似的上下文[6]包围，它们就会是相似的。如果人们有很多共同的朋友，他们会成为朋友。二阶相似度已被证明是定义一对顶点相似度的良好度量，即使它们没有被一条边[17]连接，因此可以极大地丰富顶点之间的关系。因此，通过引入二阶相似性，能够表征全局网络结构，缓解稀疏性问题。 利用一阶近似和二阶近似，研究了在进行网络嵌入时如何同时集成它们以保持局部结构和全局结构的问题。这个问题的定义如下: 定义4. 网络Embedding 给定一个图$G = (V, E)$，网络embedding旨在学习一个映射函数$f: v_i \\to y_1 \\in \\Bbb R^d$，其中$d \\ll |V|$。该函数的目的是使$y_i$和$y_j$之间的相似度明确地保持$v_i$和$v_j$的一阶和二阶邻近性。 3.2 模型3.2.1 框架 本文提出了一种半监督深度模型来进行网络embedding，其框架如图2所示。为了捕获高度非线性的网络结构，我们提出了一种深度结构，它由多个非线性映射函数组成，将输入数据映射到一个高度非线性的潜在空间来捕获网络结构。此外，为了解决结构保持和稀疏性问题，我们提出了一种利用二阶和一阶近似的半监督模型。对于每个顶点，我们都可以得到它的邻域。因此，我们通过重构每个顶点的邻域结构来设计无监督分量来保持二阶邻近性。同时，对于一小部分节点对，我们可以得到它们的配对相似性，即一阶近似。因此，我们设计了监督分量来利用一阶近似作为监督信息来细化潜在空间中的表示。通过联合优化半监督深度模型，SDNE能较好地保持高度非线性的局部全局网络结构，对稀疏网络具有较强的鲁棒性。在下一节中，我们将详细介绍如何实现半监督深度模型。 3.2.2 损失函数在介绍损失函数之前，我们定义表1中的一些术语和符号，这些术语和符号将在后面使用。注意，上面的参数^表示解码器的参数。 现在我们介绍半监督模型的损失函数。我们首先描述无监督组件如何利用二阶邻近性来保持全局网络结构。 二阶邻近度是指一对顶点的邻域结构的相似程度。因此，为了对二阶近似进行建模，需要对每个顶点的邻域进行建模。给定一个网络$G = (V, E)$，我们可以得到它的邻接矩阵$S$，其中包含n个实例$s_1, …, s_n$。对于每个实例，$s_i = \\{s_{i,j}\\}_{j=1}^n, s_{i,j} &gt; 0$当且仅当$v_i$和$v_j$之间存在联系时。因此，$s_i$描述了顶点$v_i$的邻域结构，$S$提供了每个顶点的邻域结构信息。使用$S$，我们扩展了传统的深度自动编码器[23]，以保持二阶接近。 考虑到是自包含的，我们简要回顾了深层自动编码器的关键思想。它是一个由编码器和解码器两部分组成的无监督模型。编码器由多个将输入数据映射到表示空间的非线性函数组成。解码器由多个非线性函数组成，将表示空间中的表示映射到重构空间。然后给定输入$x_i$，各层的隐藏表示如下2所示: y_i^{(1)} = \\sigma(W^{(1)}x_i + b^{(1)}) \\\\ y_i^{(k)} = \\sigma(W^{(k)}y_i^{(k-1)} + b^{k}), k=2,...,K \\tag{1}在得到$y_i^{(k)}$之后，我们可以通过逆转编码器的计算过程得到输出$\\hat{x_i}$。自动编码器的目标是最小化输出和输入的重构误差。损失函数如下: \\cal L = \\sum_{i=1}^n\\parallel \\hat{x_i} - x_i \\parallel_{2}^2 \\tag{2}[23]证明，虽然最小化重构损失并不能显式地保持样本间的相似性，但是重构准则可以平滑地捕获数据流形，从而保持样本间的相似性。然后考虑我们的例子中,如果我们使用邻接矩阵$S$作为自动编码器作为输入,即$x_i = s_i$，因为每个实例$s_i$表示顶点$v_i$的邻域结构，重构过程将使具有相似邻域结构的顶点具有相似的潜在表示。 然而，由于网络的某些特定特性，这种重建过程不能直接应用于我们的问题。在网络中，我们可以观察到一些链接，但同时也观察不到许多合法的链接，这意味着顶点之间的链接确实表示它们之间的相似性，但没有链接不一定表示它们之间的差异性。此外，由于网络的稀疏性，$S$中非零元素的数量远远小于零元素的数量。然后如果我们直接使用$S$作为传统的自动编码器的输入，它更容易在$S$中重建零元素，然而，这不是我们想要的。为了解决这一问题，我们对非零元素的重构误差比零元素的重构误差施加了更多的惩罚。修正后的目标函数如下: \\cal L_{2nd} = \\mit \\sum_{i=1}^n\\parallel \\hat{x_i} - x_i \\odot b_i \\parallel_{2}^2 \\\\ =\\parallel(\\hat{X} - X) \\odot B \\parallel_F^2 \\tag{3}其中$\\odot$为Hadamard乘积，$bi = \\{b_{i,j}\\}_{j=1}^n$。如果$s_{i,j} =0$，则$b_{i,j} = 1$，否则$b_{i,j} = \\beta &gt; 1$。利用修正后的深度自编码器，以邻接矩阵S作为输入，将具有相似邻域结构的顶点映射到表示空间附近，由重构准则保证。换句话说，我们的模型的无监督组件可以通过重建顶点之间的二阶接近度来保持全局网络结构。 既要保留全局网络结构，又要捕捉局部结构。我们用一阶近似来表示局部网络结构。一阶近似可视为约束一对顶点潜在表示的相似性的监督信息。因此，我们设计监督组件来利用一阶邻近性。该目标的损失函数定义如下: \\cal L_{1st} = \\mit \\sum_{i,j=1}^n s_{i,j} \\parallel y_i^{(K)} - y_j^{(K)} \\parallel_2^2 \\\\ = \\sum_{i,j=1}^n s_{i,j} \\parallel y_i - y_j \\parallel_2^2 \\tag{4}等式4的目标函数借用了拉普拉斯变换的思想[1]，当相似的顶点被映射到离嵌入空间很远的地方时，就会受到惩罚。一些关于社交网络[13]的工作也使用了类似的想法。我们区分它们的方面是，我们在深层模型中加入了这个想法，使由一条边连接的顶点被映射到嵌入空间附近。因此，该模型保持了一阶近似性。 为了同时保持一阶和二阶邻近性，我们提出了一个结合等式3和等式4的半监督模型，使下列目标函数最小化： \\cal L_{mix} = L_{2nd} + \\alpha L_{1st} + vL_{reg} \\\\ = \\mit \\parallel(\\hat{X} - X) \\odot B\\parallel_F^2 + \\alpha\\sum_{i,j=1}^n s_{i,j} \\parallel y_i - y_j \\parallel_2^2 + v \\cal L_{reg} \\tag{5}其中，$\\cal L_{reg}$是一个$\\cal L2$正则项： \\cal L_{reg} = \\mit \\frac{1}{2}\\sum_{k=1}^K(\\parallel W^{(k)} \\parallel_F^2 + \\parallel \\hat{W}^{(k)} \\parallel_F^2)3.2.3 优化为了优化上述模型，目标是最小化$\\theta$的函数$\\cal L_{mix}$。其中的关键步骤是计算的偏导数$\\cal \\partial L_{mix} / \\partial \\hat{W}^{(k)}$和$\\cal \\partial L_{mix} / \\partial W^{(k)}$。偏导数的详细数学形式如下: \\frac {\\cal \\partial L_{mix}}{\\partial \\hat{W}^{(k)}} = \\frac{\\partial \\cal L_{2nd}}{\\partial \\hat{W}^{(k)}} + v \\frac{\\partial \\cal L_{reg}}{\\partial \\hat{W}^{(k)}} \\\\ \\frac {\\cal \\partial L_{mix}}{\\partial W^{(k)}} = \\frac{\\partial \\cal L_{2nd}}{\\partial W^{(k)}} + \\alpha \\frac{\\partial \\cal L_{1st}}{\\partial W^{(k)}} + v \\frac{\\partial \\cal L_{reg}}{\\partial W^{(k)}} \\tag{6}我们首先看$\\frac{\\partial \\cal L_{2nd}}{\\partial \\hat{W}^{(K)}}$，可以改写为： \\frac{\\partial \\cal L_{2nd}}{\\partial \\hat{W}^{(K)}} = \\frac{\\partial \\cal L_{2nd}}{\\partial \\hat{X}}.\\frac{\\partial \\hat{X}}{\\partial \\hat{W}^{(K)}} \\tag{7}对于第一项，根据等式3，我们有: \\frac{\\partial \\cal L_{2nd}}{\\partial \\hat{X}} = 2(\\hat{X} - X) \\odot B \\tag{8}第二项的计算$\\frac{\\partial \\hat{X}}{\\partial \\hat{W}}$很容易根据$\\hat{X} = \\sigma(\\hat{Y}^{(K-1)}\\hat{W}^{(K)} + \\hat{b}^{(K)})$计算。那么$\\frac{\\partial \\cal L_{2nd}}{\\partial \\hat{W}^{(K)}}$也是可得的。基于反向传播，我们可以迭代得到$\\frac{\\partial \\cal L_{2nd}}{\\partial \\hat{W}^{(K)}}, k=1,…,K-1$和$\\frac{\\partial \\cal L_{2nd}}{\\partial W^{(k)}}, k=1,…,K$。现在$\\cal L_{2nd}$的偏导数的计算已经完成了。 然后我们继续计算$\\frac{\\partial \\cal L_{1st}}{\\partial W^{(k)}}$的偏导数。$\\cal L_{1st}$的损失函数可以重新表述为: \\cal L_{1st} = \\mit \\sum_{i,j=1}^n s_{i,j} \\parallel y_i - y_j \\parallel_2^2 = 2tr(Y^TLY) \\tag{9}其中$L = D - S$，$D \\in \\Bbb R^{n \\times n}$是对角矩阵，$D_{i,j} = \\sum_j s_{i,j}$。 然后我们首先重点计算$\\frac{\\partial \\cal L_{1st}}{\\partial W^{(k)}}$: \\frac{\\partial \\cal L_{1st}}{\\partial W^{(k)}} = \\frac{\\partial \\cal L_{1st}}{\\partial Y}.\\frac{\\partial Y}{\\partial W^{(K)}} \\tag{10}因为$Y = \\sigma(Y^{(K-1)}W^{(K)} + b^{(K)})$，第二项的计算$\\frac{\\partial Y}{\\partial W^{(K)}}$也是比较容易的。对于第一项$\\frac{\\partial \\cal L_{1st}}{\\partial Y}$的计算，有： \\frac{\\partial \\cal L_{1st}}{\\partial Y} = 2(L + L^T).Y \\tag{11}同样地，利用反向传播我们可以完成$\\cal L_{1st}$的偏导计算。 现在我们得到了参数的偏导数。在参数初始化的情况下，利用随机梯度下降法对模型进行优化。注意，由于模型高度非线性，在参数空间中存在许多局部最优。因此，为了找到一个好的参数空间区域，我们首先使用深度信念网络对参数进行预训练，这在文献中已经被证明是深度学习中参数初始化的必要步骤[7]。完整的算法参见Alg. 1。 3.3 分析和讨论在这一节中，我们对所提出的SDNE半监督深度模型进行了一些分析和讨论。 新顶点: 网络embedding的一个实际问题是如何学习新顶点的表示。对于一个新的顶点$v_k$，如果其与已有顶点的连接已知，则可以得到其邻接向量$x = \\{s_{1,k}, …, s_{n,k}\\}$，其中$s_{i, k}$表示现有$v_i$与新顶点$v_k$的相似性。然后我们可以简单地将$x$输入到我们的深度模型中，并使用经过训练的参数$\\theta$来得到$v_k$的表示。这样一个过程的复杂度是$O(1)$。如果$v_i$和网络中现有的顶点之间没有连接，我们的方法和最先进的网络embedding方法都无法处理。为了处理这种情况，我们可以求助于其他方面的信息，比如新顶点的内容特性，我们将其留作以后的工作。 训练复杂度: 不难看出，我们的模型训练复杂度为$O(ncdI)$，其中$n$为顶点数，$d$为隐含层的最大维数，$c$为网络的平均度，$I$为迭代次数。参数$d$通常与嵌入向量的维数有关，而与顶点数无关。$I$和$n$是独立的。对于$c$来说，在实际应用中它通常可以看作一个常量。例如，在社交网络中，一个人的最大朋友数总是有限的[30]。在top-k相似图中，$c = k$，因此$cdI$与$n$无关，因此整体训练复杂度与网络中顶点的数量成线性关系。 4. 试验在本节中，我们将在几个真实世界数据集和应用程序上评估我们提出的方法。实验结果表明在基线上有显著的改进。 4.1 数据集为了全面评估这些表达的有效性，我们使用了5个数据集，包括3个社交网络、1个引用网络和1个语言网络，用于3个现实世界的应用，即多标签分类、链接预测和可视化。考虑到这些数据集的特点，我们为每个应用程序使用一个或多个数据集来评估性能。具体描述如下。 BLOGCATALOG[27]、FLICKR[27]和YOUTUBE[28]:它们是在线用户的社交网络。每个用户至少有一个类别的标签。总的来说，BLOGCATALOG有39个不同的类别，FLICKR有195个类别，类别有47个类别。这些类别可以用作每个顶点的基本事实。因此，它们可以通过多标签分类任务进行评价。 RXIV GR-QC[16]:是一个来自arXiv的论文协作网络，涵盖了广义相对论和量子宇宙学的论文。在这个网络中，顶点表示作者，而边缘表示作者在arXiv中合作发表过一篇科学论文。数据集用于链接预测任务，因为我们没有每个顶点的类别信息。 20-NEWSGROUP4:这个数据集是一个20000个新闻组文档的近似值集合，每个文档由20个不同组中的一个标记。我们使用每个单词的tfidf向量表示文档，余弦相似度表示两个文档之间的相似度。我们可以根据这样的相似性来构建网络。我们选择标记为comp.graphics, rec.sport.baseball和talk.politics.gums来执行可视化任务。 综上所述，我们进行了加权和非加权、稀疏和稠密、小网络和大网络的实验。因此，数据集可以全面反映网络embedding方法的特点。数据集的详细统计信息可在表2中汇总。 4.2 Baseline 算法我们使用以下五种方法作为基线。前四种是网络embedding方法。共同近邻直接预测网络上的链路，是实现链路预测[17]的有效方法。 DeepWalk[21]:采用随机游走和跳跃图模型生成网络表示。 LINE[26]:它定义了损失函数来分别保留一阶或二阶邻近性。在优化损失函数之后，它连接这些表示。 GraRep[4]:它扩展到高阶邻近，并使用SVD来训练模型。它还可以直接连接一阶和高阶的表示方法。 Laplacian特征映射(LE)[1]:它通过分解邻接矩阵的Laplacian矩阵来生成网络表示。它只利用一阶近似来保持网络结构。 共同邻居(Common Neighbor)[17]:它只使用共同邻居的数量来衡量顶点之间的相似性。它仅用于链路预测任务的基线。 4.3 评估指标在我们的实验中，我们完成了重建、链接预测、多标签分类和可视化的任务。对于重建和链路预测，我们使用precision@k和Mean Average Precision(MAP)来评估性能。它们的定义如下: precision@k是一个给返回实例同等权重的度量。定义如下: precision@k = \\frac{|\\{j|i,j \\in V,inder(j) \\leq k, \\Delta_i(j)=1\\}|}{k}其中V为顶点集，$index(j)$为第$j$个顶点的排序索引，$\\Delta_i(j) = 1$表示$v_i$与$v_j$有关联。 Mean Average Precision(MAP)： AP(i) = \\frac{\\sum_j precision@j(i).\\Delta_i(j)}{|\\{\\Delta_i(j) = 1\\}|} \\\\ MAP = \\frac{\\sum_{i \\in Q}AP(i)}{|Q|} 对于多标签分类任务，我们采用了micro-F1和macro-F1。 Macro-F1是一个给每个类同等权重的度量。定义如下: Macro-F1 = \\frac{\\sum_{A \\in C}F1(A)}{|C|}其中$F1(A)$为标签A的F1度量。 Micro-F1是一个给每个实例同等权重的度量。定义如下: Pr = \\frac{\\sum_{A \\in C}TP(A)}{\\sum_{A \\in C}(TA(A) + FP(A))}, R = \\frac{\\sum_{A \\in C}TP(A)}{\\sum_{A \\in C}(TA(A) + FN(A))} \\\\ Micro-F1 = \\frac{2\\*Pr\\*R}{Pr + R}4.4 参数设置在本文中，我们提出了一个多层的深层结构，层的数量随着不同的数据集而变化。表3列出了每个层的维数。神经网络有三层影藏层用于BLOGCATALOG, ARXIV GR-QC和20-NEWSGROUP，四层影藏层用于FLICKR和YOUTUBE。如果我们使用更深层次的模型，性能几乎保持不变，甚至变得更差。 对于我们的方法，通过在验证集上使用网格搜索来调整超参数$\\alpha$,$\\beta$和$v$，将基线的参数调整为最优。对于LINE，随机梯度下降的小批量大小设置为1。初始值的学习率为0.025。设负采样数为5，样本总数为100亿个。此外，根据[26]，连接1阶和2阶表示形成最终的embedding向量并通过L2归一化到最终的embedding向量，LINE产生更好的结果。我们按照他们的方式来得到结果。对于DeepWalk，我们设置窗口大小为10，步长为40，每个顶点的步长为40。对于GraRep，我们设置最大矩阵转移步长为5。 4.5 试验结果在本节中，我们首先评估重构性能。然后，我们报告了在三种经典的数据挖掘和机器学习应用，即多标签分类、链接预测和可视化中，不同embedding方法生成的网络表示的泛化结果。 4.5.1 网络重构在评估该方法在实际应用中的泛化性之前，我们首先对不同网络embedding方法的网络重构能力进行了基本评估。这个实验的原因是一个好的网络embedding方法应该保证所学习的嵌入能够保持原来的网络结构。我们使用语言网络ARXIV GR-QC和社交网络BLOGCATALOG代表。对于给定的网络，我们使用不同的网络embedding方法来学习网络表示，然后预测原始网络的链接。由于原网络中存在的链路已知，可以作为ground-truth，我们可以评估不同方法的重构性能，即训练集误差。使用precision@k和MAP作为评估指标。precision@k的结果如图3所示。MAP的结果见表4。 从结果来看，我们有以下观察和分析: 表4显示了我们的方法在两个数据集的基线之上实现了显著的改进。图3显示，当k增加时，我们方法的precision@k始终是最高的。结果表明，该方法能较好地保持网络结构。 具体来说，对于ARXIV GR-QC网络，我们的方法的precision@k可以达到100%左右,直到k增加到10000时保持在100%。这说明我们的方法几乎可以完美地重构出这个数据集中的原始网络，特别是考虑到这个数据集中的链接总数是28980条。 虽然SDNE和LINE都利用了一阶和二阶邻近性来保持网络结构，但SDNE的性能更好。原因可能是两方面。首先，LINE采用浅层结构，难以捕捉底层网络中高度非线性的结构。其次，LINE将一阶近似和二阶近似的表示法直接串联起来，这在SDNE中是次优的。 SDNE和LINE的性能都优于LE, LE只利用一阶近似来保持网络结构，说明引入二阶近似可以更好地保持网络结构。 4.5.2 多分类在众多的应用中，分类是一项非常重要的工作，因此许多相关的算法和理论已经被[18]研究过。因此，我们在本实验中通过一个多标签分类任务来评估不同网络表示的有效性。顶点的表示由网络embedding方法生成，并作为特征将每个顶点分类为一组标签。具体来说，我们采用LIBLINEAR[8]来训练分类器。在训练分类器时，我们随机抽取标记节点的一部分作为训练数据，其余部分作为测试。对于BLOGCATALOG，我们随机抽取10%到90%的顶点作为训练样本，并使用剩余的顶点来测试性能。对于FLICKR和YOUTUBE，我们随机抽取1%到10%的顶点作为训练样本，并使用剩余顶点来测试性能。另外，我们删除了在YOUTUBE上没有任何类别标记的顶点。我们重复这个过程5次，并报告平均的Micro-F1和Macro-F1。结果分别如图4和图5所示。 从结果来看，我们有以下观察和分析: 在图4和图5中，我们的方法的曲线始终高于基线的曲线。结果表明，与基线相比，该方法的学习网络表示能更好地推广到分类任务。 在图4 (BLOGCATALOG)中，当训练百分比从60%下降到10%时，我们的方法在基线上的改进幅度更加明显。结果表明，在标记数据有限的情况下，该方法比基线方法有更大的改进。这种优势对于实际应用尤其重要，因为标记的数据通常是稀缺的。 在大多数情况下，DeepWalk的性能是网络embedding方法中最差的。原因有两个。首先，DeepWalk没有明确的目标函数来捕获网络结构。其次,DeepWalk采用随机漫步的方式来丰富顶点的邻居，这种随机的方式引入了大量的噪声，特别是对于那些高阶顶点。 4.5.3 链路预测在本节中，我们主要针对链路预测任务进行了两个实验。第一个评估总体性能，第二个评估网络的不同稀疏性如何影响不同方法的性能。 在本节中，我们将使用数据集ARXIV GR-QC。为了在网络中进行链路预测任务，我们随机隐藏一部分现有链路，利用剩余网络训练网络embedding模型。训练结束后，我们可以得到预测未观测链路的表征。与重构任务不同，此任务预测未来链接，而不是重构现有链接。因此，该任务可以表现出不同网络embedding方法的可预测性。另外，我们添加共同近邻是一种有效的链路预测方法。 在第一个实验中，我们随机隐藏了15%的的已有链接(约4000个链接)，并使用precision@k作为预测隐藏链接的评价指标。我们逐步将k从2增加到10000，结果如表5所示。最佳性能以粗体突出显示。表5的一些观察和分析结果如下: 结果表明，当k增加时，我们的方法的性能始终优于其他网络嵌入方法。结果表明，用该方法学习的表征对新链接的形成具有更好的预测能力。 当k = 1000时，我们的方法的精度仍然高于0.9，但是其他方法的精度很快下降到0.8以下。结果表明，该方法能够保持较高的排名精度。这种优势对于推荐和信息检索等实际应用程序非常重要，因为用户更关心在这些应用程序中排名靠前的结果。 在第二个实验中，我们通过随机删除原网络中的一部分链接来改变网络的稀疏性，然后按照上述步骤报告不同网络embedding方法的结果。结果显示在图6。 结果表明，当网络越稀疏，LE与SDNE之间或LE与LINE之间存在的差距越大。结果表明，二阶近似的引入使得学习表示对稀疏网络具有更强的鲁棒性。此外，当我们删除80%的链接时，我们的方法仍然比基线执行得好得多。它还演示了SDNE在处理稀疏网络中的强大功能。 4.5.4 可视化网络embedding的另一个重要应用是在二维空间中生成网络的可视化。因此，我们将20个新闻组网络的学习表示可视化。我们使用不同网络embedding方法获得的低维网络表示作为可视化工具t-SNE[31]的输入。因此，每个新闻组文档都被映射为一个二维向量。然后我们可以把每个向量想象成二维空间中的一个点。对于标记为不同类别的文件，我们在对应的点上使用不同的颜色。因此，一个良好的可视化结果是，相同颜色的点彼此接近。可视化图如图7所示。除了可视化图形外，我们还使用与[4]相似的Kullback-Leibler散度作为定量评价指标。KL散度越小，性能越好。结果如表6所示。 从图7可以看出，LE和DeepWalk的结果并不令人满意，因为属于不同类别的点是混合在一起的。对于LINE，形成了不同类别的集群。但是在中间部分，不同类别的文档仍然混杂在一起。对于GraRep，结果看起来更好，因为相同颜色的点形成分段组。然而，每个群体的界限不是很清楚。显然，SDNE的可视化在组分离和边界方面表现得最好。表6中的结果也定量地证明了我们的方法在可视化任务中的优越性。","link":"/2020/01/14/graph-embedding-SDNE/"},{"title":"【Graph Embedding】node2vec","text":"关于Graph Embedding系列的论文翻译解读文章： 【Graph Embedding】DeepWalk 【Graph Embedding】line 【Graph Embedding】node2Vec 【Graph Embedding】SDNE 【Graph Embedding】struc2vec 参考资料 paper: https://www.kdd.org/kdd2016/papers/files/rfp0218-groverA.pdf code: https://github.com/aditya-grover/node2vec 摘要参考DeepWalk和LINE，node2vec定义了一个灵活的节点邻域的概念，并设计了一个有偏差的随机游走过程，可以看做是DeepWalk的扩展，其结合了DFS和BFS的随机游走。 1. 介绍网络分析中的许多重要任务都涉及对节点和边缘的预测。例如， 在社交网络中，我们可能对预测用户的兴趣感兴趣，或者在蛋白-蛋白交互网络中，我们可能对预测蛋白质的功能标签感兴趣[25,37]。 同样，在链路预测中，我们希望预测网络中的一对节点是否应该有一条连接它们的边[18]。链路预测在很多领域都很有用。在基因组学中，它帮助我们发现基因之间的新相互作用；在社会网络中，它可以识别现实世界中二人是否是朋友[2,34]。 任何监督机器学习算法都需要一组信息丰富的、有区别的和独立的特征。在网络预测问题中，这意味着必须为节点和边构造一个特征向量表示。典型的解决方案包括基于domain knowledge和手动的特征工程。即使不考虑特征工程所需的繁琐工作，这些特征通常是针对特定任务设计的，不会泛化到不同的预测任务中。 另一种方法是通过解决优化问题[4]来学习特征表示。特征学习的挑战是定义一个目标函数，它涉及计算效率和预测精度之间的平衡。虽然这种监督过程有较高的准确性，但其代价是由于需要估计的参数数量激增，导致训练时间复杂性很高。 然而，目前的技术并不能令人满意地定义和优化网络中可伸缩的无监督特征学习所需的合理目标。经典方法基于线性和非线性降维技术，如主成分分析、多维扩展[3, 27, 30, 35]使数据表示的方差最大化。因此，这些方法总是涉及到适当的数据矩阵的特征分解，这对于大型的真实网络是昂贵的。此外，由此产生的潜在表示在网络上的各种预测任务中表现较差。 或者，我们可以设计一个目标来保护节点的局部邻域。利用类似于单隐层前馈神经网络反向传播的随机梯度下降法可以有效地优化目标。最近在这方面的尝试[24,28]提出了有效的算法，但依赖于网络邻域的严格概念，这导致这些方法在很大程度上对网络特有的连接模式不敏感。特别是网络中的节点可以根据他们所属的社区来组织（同质性)。例如，在图1中，我们观察到节点$u$和$s_1$属于同一个紧密结合的节点社区，而两个不同的社区中的节点$u$和$s_6$共享一个hub节点的相同结构角色。现实世界的网络通常表现出这种等价的混合。因此,它是必要的,以便灵活的算法,可以学习节点表示遵守两个原则: 能够紧密地学习来自同一网络社区的嵌入节点的表示,以及学习共享相似角色的节点具有相似的embeddings。这将允许特征学习算法泛化各种领域和预测任务 现在的工作。提出了一种用于网络中可伸缩特征学习的半监督算法node2vec。在自然语言处理[21]的基础上，我们使用SGD优化了一个自定义的基于图的目标函数。直观地说，我们的方法返回的特征表示能够最大限度地在d维特征空间中保留节点的网络邻域。我们使用二阶随机游走的方法来生成(样本)节点的网络邻域。 我们的主要贡献在于定义了一个灵活的节点网络邻居概念。通过选择适当的邻域概念，node2vec可以学习基于节点的网络角色和/或它们所属的社区组织节点的表示形式。我们通过开发一组有偏随机游走来实现这一点，它有效地探索了给定节点的不同邻域。得到的算法是灵活的，通过可调参数控制搜索空间，这与之前工作中严格的搜索过程形成对比[24,28]。因此，我们的方法可以推广先前的工作，并且可以对网络中观察到的全谱等价进行建模。控制我们的搜索策略的参数有一个直观的解释，并倾向于不同的网络探索策略。这些参数也可以通过使用一小部分标记数据以半监督的方式直接学习。 我们还展示了如何将单个节点的特性表示扩展到成对的节点(边)。为了生成边的特征表示，我们使用简单的二元操作符来组合单个节点的学习特征表示。这种组合性使node2vec可以用于涉及节点和边的预测任务 实验集中在两个网络中常见的预测任务上:一个是多标签分类任务，其中每个节点被分配一个或多个类标签;另一个是链路预测任务，其中我们预测给定一对节点的边的存在。我们将node2vec的性能与最先进的特征学习算法进行了对比[24,28]。我们实验了几个来自不同领域的真实世界的网络，如社交网络、信息网络，以及系统生物学的网络。实验表明，node2vec在多标签分类和链路预测方面的性能比最先进的方法分别高出26.7%和12.6%。即使是10%的标记数据，该算法也有很好的表现，并且对噪声或缺失边形式的扰动上具有很强的鲁棒性。在计算上，node2vec的主要阶段是可并行的，它可以在几个小时内扩展到具有数百万节点的大型网络。 node2vec的贡献如下： node2vec是一种高效的可扩展的网络特征学习算法，它利用SGD有效地优化了一个新的网络感知、邻域保持的目标。 展示了node2vec如何符合网络科学中已建立的原则，灵活地提供不同等价的表示。 扩展了node2vec和其他基于邻域保留目标的特征学习方法，从节点扩展到基于边的预测任务。 对node2vec在多个真实数据集上的多标签分类和链路预测进行了经验评估。 2. 相关工作特征工程已经被机器学习社区在不同的标题下进行了广泛的研究。在网络中，为节点生成特征的传统范式是基于特征提取技术的，该技术通常涉及一些基于网络属性的人工设计的种子特征[8,11]。相反，我们的目标是通过将特征提取转换为表示学习问题来自动化整个过程，在这种情况下，我们不需要任何人工设计的特征。 无监督特征学习方法通常利用图的各种矩阵表示的谱特性，特别是拉普拉斯矩阵和邻接矩阵。从线性代数的角度来看，这些方法可以看作是降维技术。一些线性的(如主成分分析)和非线性的(例如，IsoMap)降维技术已经被提出[3, 27, 30, 35]。这些方法在计算和统计性能上都存在缺陷。在计算效率方面，矩阵的特征分解是昂贵的，除非解决方案的质量在很大程度上受到近似的影响，因此，这些方法很难扩展到大型网络。其次，这些方法针对网络中观察到的不同模式(如同质性和结构等价性)不具有鲁棒性的目标进行优化，并对底层网络结构与预测任务之间的关系进行假设。例如，光谱聚类做了一个强有力的同质性假设，即图割将有助于分类[29]。这样的假设在许多情况下都是合理的，但在有效地将其推广到不同的网络上时却不能令人满意。 自然语言处理的表征性学习的最新进展为离散对象(如单词)的特征学习开辟了新途径。特别是，Skip-Gram模型[21]旨在通过优化邻域保留似然目标来学习单词的连续特征表示。算法如下：它扫描文档中的单词，并将每个单词嵌入文档中，这样单词的特征就可以预测附近的单词(例如:，一些上下文窗口中的单词)。特征表示是通过负抽样[22]的SGD似然目标来学习的。跳跃图的目标是基于分布假设，即在相似的上下文中，单词往往具有相似的含义。也就是说，相似的单词往往出现在相似的词域中。 受Skip-Gram模型的启发，最近的研究通过将网络表示为“文档”，为网络建立了一个类比(24、28)。就像文档是一个有序的单词序列一样，我们可以从底层网络中采样节点序列，并将网络转换为有序的节点序列。然而，有许多可能的节点抽样策略，导致不同的学习特征表示。事实上，正如我们将要展示的，没有一个清晰的抽样策略可以适用于所有的网络和所有的预测任务。这是以前工作的一个主要缺点，不能提供任何灵活的抽样节点从网络[24,28]。我们的算法node2vec克服了这一限制，它设计了一个灵活的目标，不依赖于特定的采样策略，并提供参数来调整搜索空间(参见第3节)。 最后，对于基于节点和边缘的预测任务，有大量基于现有的和新的特定于图的深度网络架构的监督特征学习的最新工作[15,16,17,31,39]。这些体系结构使用多层非线性转换直接最小化下游预测任务的损失函数，从而获得较高的准确性，但由于需要较高的训练时间，因此以可扩展为损失。 3. 特征学习框架我们将网络中的特征学习描述为一个极大似然优化问题。设$G = (V, E)$是一个给定的网络。我们的分析是一般性的，适用于任何定向/非定向的加权/非加权网络。设$f: V \\to \\Bbb{R}^d$是从节点到特征表征物的映射函数，我们的目标是学习下游预测任务。这里$d$是一个参数，指定特征表示的维数。同样，$f$是一个参数大小为$|V| \\times d$的矩阵。对于每个节点$u \\in V$， 我们定义$N_{S}(u) \\subset V$ 作为通过邻域采样策略$S$生成节点$u$的网络邻域 我们将Skip-gram结构扩展到网络[21,24]。我们试图优化以下目标函数，使观察网络邻域的似然概率最大化: \\max_{f} \\, \\, \\, \\, \\, \\, \\, \\sum_{u \\in V}logPr(N_S(u) | f(u)). \\tag{1}为了使优化问题易于处理，我们做了两个标准假设: 条件独立性假设。给定源顶点，邻域节点出现的概率相互独立: Pr(N_S(u) | f(u)) = \\prod_{n_i \\in N_S(u)}Pr(n_i|f(u)). 特征空间对称性假设。在特征空间中，源节点与邻节点之间存在对称效应。也就是说作为源节点和作为邻节点时候共享同样的embedding向量(回想LINE中4.1.2中定义的二阶相似度，一个顶点作为源节点和邻节点时是用不同的embedding向量表示)因此，node2vec将每个源邻节点对的条件似然建模为一个softmax单元，并由它们的特征点积进行参数化: Pr(n_i|f(u)) = \\frac{exp(f(n_i).f(u))} {\\sum_{v \\in V}exp(f(v).f(u))}. 根据上述假设，式(1)中的目标简化为: \\max_{f} \\, \\, \\, \\, \\, \\, \\, \\sum_{u \\in V}[-log Z_u + \\sum_{n_i \\in N_{S}(u)}f(n_i).f(u)]. \\tag{2}每个节点的分配函数，$Z_u = \\sum_{v \\in V}exp(f(u).f(v))$的对于大型网络计算是很昂贵的，所以使用负采样[22]来近似它。我们使用定义特征的模型参数$f$上的随机梯度上升来优化等式（2）。 基于Skip-gram结构的特征学习方法最初是在自然语言[21]环境下发展起来的。考虑到文本的线性特性，邻域的概念可以通过在连续的单词上使用滑动窗口来自然地定义。然而，网络不是线性的，因此需要一个更丰富的邻域概念。为了解决这个问题，我们提出了一个随机过程，对给定源节点$u$的许多不同的邻域进行采样。邻域$N_S(u)$不仅限于相邻的邻域，而且根据采样策略$S$可以有非常不同的结构。 3.1 经典搜索策略 如图1，对单个节点$u$进行3个节点的采样。一般来说，生成$k$个节点的邻域集$N_S$有两种极端的采样策略: 宽度优先抽样(BFS) 如，对于大小为$k = 3$的邻域，BFS示例节点$s1、s2、s3$。 广度优先抽样(DFS) DFS对$s4、s5、s6$进行了采样。 广度优先和深度优先的抽样代表了他们所探索的搜索空间的极端情况，这对学习表征产生了有趣的影响。特别是，网络节点上的预测任务往往在两类相似性之间穿梭:同质性和结构等价性[12]。根据同质性假设[7,36]，高度互联且属于相似网络集群或社区的节点应紧密嵌入在一起(如图1中的节点$s_1$和$u$属于同一网络社区)。相反，在结构等价假设下，在网络中具有相似结构角色的[10]节点应该紧密嵌入在一起(如图1中的节点$u$和$s_6$作为其对应社区的枢纽)。重要的是，与同质性不同，结构等价并不强调连接性;节点可能在网络中相隔很远，但仍然具有相同的结构角色。在现实世界中，这些等价概念并不是排他的;网络通常表现出这两种行为，一些节点表现出同质性，而另一些则表现出结构等价性。 我们观察到，BFS和DFS策略在生成反映上述任一等价的表示方面起着关键作用。特别是，BFS采样的邻域导致了与结构等价性紧密对应的嵌入。直观地说，我们注意到，为了确定结构上的等价性，通常只需要准确地描述局部邻域就足够了。例如，基于网络角色(如桥接器和集线器)的结构等价性可以通过观察每个节点的直接邻域来推断。通过限制搜索到附近的节点，BFS实现了这种特性，并获得了每个节点邻居的微观视图。此外，在BFS中，采样的邻近节点往往重复许多次。这一点也很重要，因为它减少了描述1跳节点相对于源节点分布的方差。然而，对于任意给定的$k$，图中只有很小一部分被探索。 相反，DFS可以探索更大的网络部分，因为它可以远离源节点u(样本容量$k$固定)。在DFS中，采样的节点更准确地反映了邻居的宏观视图，这在基于同质性的社区推断中是必不可少的。然而，DFS的问题是，不仅要推断网络中存在哪些节点到节点的依赖关系，而且还要确定这些依赖关系的确切性质。这是困难的，因为我们有一个约束的样本大小和一个大的邻居去探索，导致高方差。其次，移动到更大的深度会导致复杂的依赖关系，因为采样的节点可能离源很远，而且可能不太具有代表性。 3.2 node2vec在此基础上，我们设计了一个灵活的邻域采样策略，使我们能够在BFS和DFS之间进行平滑插值。我们通过开发一种灵活的有偏随机游走程序来实现这一点，该程序可以同时探索a中的邻域 BFS和DFS。 3.2.1 随机游走在形式上，给定一个源节点$u$，我们模拟一个固定长度$l$的随机游走，让$c_i$表示游走中的第$i$个节点，从$c_0 = u$开始，节点$c_i$由以下分布产生: P(c_i = x | c_{i-1} = v) = \\begin{cases} \\frac{\\pi v x}{Z} & if (v, x) \\in E \\\\ 0 & otherwise \\end{cases}其中$\\pi v x$为节点$v$与$x$之间的未归一化转移概率，$Z$为归一化常数。 3.2.2 搜索偏差$\\alpha$ 使随机游走产生偏差的最简单的方法是根据静态边权值$w_{vx}$对下一个节点进行抽样。例如，$\\pi_{vx} = w_{vx}$。(对于未加权图$w_{vx} = 1$)。然而，这并不允许我们考虑网络结构，并指导我们的搜索过程探索不同类型的网络邻居。另外，与BFS和DFS不同的是，BFS和DFS是分别适用于结构等价性和同质性的极端抽样范式，我们的随机游走应该适应这样的事实，即这些等价的概念不是竞争的或排他的，而现实世界的网络通常是两者的混合。 我们定义了一个二阶随机游走，它有两个参数$p$和$q$来引导这个游动:考虑一个只穿过边$(t, v)$，现在驻留在节点$v$上(图2)。现在，需要决定下一步走哪个节点，所以计算了从$v$出发在边$(v, x)$上的转移概率$\\pi_{vx}$。我们将未归一化的转移概率设为$\\pi_{vx} = \\alpha_{pq}(t, x).w_{vx}$，其中 \\alpha_{pq}(t, x) = \\begin {cases} \\frac{1}{p} & if \\,\\,d_{tx} = 0 \\\\ 1 & if \\,\\,d_{tx} = 1 \\\\ \\frac{1}{q} & if \\,\\,d_{tx} = 2 \\\\ \\end {cases}$d_{tx}$表示节点$t$与$x$之间的最短路径距离。注意，$d_{tx}$必须是{0, 1, 2}中的一个。因此，这两个参数对于引导行走是必要且充分的。 直观地看，参数$p$和$q$控制行走探索和离开起始节点$u$附近的速度。特别是，参数允许我们的搜索过程(近似地)在BFS和DFS之间插入。 返回参数(return parameter)，p。参数p控制了在遍历中重新访问一个节点的可能性。将它设置为一个高值(&gt; max(q, 1)确保我们不太可能在以下两个步骤中采样一个已经访问过的节点(除非遍历中的下一个节点没有其他邻居)。这种策略鼓励适度的探索，避免了采样中的两跳冗余。另一方面，如果p低(&lt; min(q，1))，它将导致walk回溯一个步骤(图2)，这将使walk接近起始节点u。 向内向外参数(In-out parameter)，q。参数q允许搜索区分“向内”和“向外”节点。回到图2，如果 q &gt; 1，则随机游走偏向于靠近节点t的节点(偏向BFS)。这样的遍历获得了底层图相对于遍历中的起始节点的局部视图，以及近似的BFS行为，因为我们的样本包含了一个小区域内的节点。而当q &lt; 1时，walk更倾向于访问距离$t$较远的节点(偏向DFS)。因此，采样节点与给定源节点$u$的距离不是严格递增的，但反过来，我们受益于可处理的预处理和随机游走的优越采样效率。请注意，通过将$\\pi_{v,x}$设为$t$中前边节点的函数，随机游走是2阶马尔可夫过程。 随机游走的好处。在纯BFS/DFS方法上进行随机游走有几个好处。随机游走在空间和时间要求方面都具有很高的计算效率。存储图中每个节点的近邻的空间复杂度为$O(|E|)$。对于二阶随机游走，存储每个节点的邻居之间的相互连接是有帮助的，这导致$O(a^2|V |)$的空间复杂度，其中a是图的平均度，对于真实世界的网络通常是很小的。与传统的基于搜索的抽样策略相比，随机游走的另一个关键优势是它的时间复杂度。特别是，通过在样本生成过程中增加图连通，随机游动提供了一种方便的机制，通过跨不同源节点重用样本来提高有效采样率。由于随机漫步的马尔可夫链的性质，通过模拟的随机游走长度$l &gt; k$一次可以从$l -k$个节点中生成k个样品。这里，我们对每个样本采集的有效复杂度是$O(\\frac{l}{k(l-k)})$。例如，在图1中我们抽样一个随机游走${u, S_4, S_5, S_6, S_8, S_9}$的长度$l = 6$，得到$N_S(u) = {S_4, S_5, S_6}, N_S(S_4) = {S_5, S_6, S_8}$和$N_S(S_5) = {S_6, S_8, S_9}$。请注意，样本复用可能会在整个过程中引入一些偏差。然而，我们注意到它大大提高了效率。 3.2.3 node2vec算法 node2vec的伪代码在算法1中给出。在任意一个随机游走中，由于起始节点$u$的选择，都存在一个隐式偏差。由于我们学习了所有节点的表示，我们通过模拟从每个节点开始的固定长度$l$的随机游走来抵消这个偏差。在每一步中，采样都是基于转移概率$\\pi_{vx}$来完成的。该算法可以预先计算二阶马尔可夫链的转移概率$\\pi_{vx}$，从而利用别名采样(alias sampling)在O(1)时间内有效地模拟随机游走时的节点采样。node2vec的三个阶段，即，预处理计算转移概率，随机游走模拟和优化使用SGD，依次执行。node2vec延伸资料: http://snap.stanford.edu/node2vec 3.3 学习边的特征 node2vec算法为学习网络中节点的丰富特征表示提供了一种半监督方法。然而，我们通常对涉及成对节点而不是单个节点的预测任务感兴趣。例如，在链路预测中，我们预测网络中两个节点之间是否存在链路。由于我们的随机游走自然基于底层网络中节点之间的连接结构，所以我们使用自举方法在单个节点的特性表示上将它们扩展到节点对。 给出了两个节点$u$和$v$，定义了对应特征向量$f(u)$和$f(v)$上的一个二元算子$\\omicron$，以生成一个表示$g(u, v)$类似$g: V \\times V \\to \\Bbb{R}^{d’}$，其中$d’$为对$(u, v)$的表示大小。我们希望对任意一对节点定义操作符，即使这对节点之间不存在边，因为这样做可以使表示对链接预测有用，其中我们的测试集包含真边和假边(即，不存在)。我们考虑了几个操作符$\\omicron$的选择，如表1中总结的$d’ = d$。 4. 试验4.1 案列分析：《悲惨世界》网络(Les Misérables network) 在3.1节中，我们观察到，BFS和DFS策略代表了嵌入节点频谱上的两个极端，基于同质性原则(即，网络社区)以及结构等价性(即，节点的结构角色)。我们现在的目标是通过经验来证明这个事实，并证明node2vec实际上可以发现符合这两个原则的嵌入。 我们使用一个网络，其中节点对应于小说《悲惨世界》[13]中的人物，边缘连接共同出现的人物。该网络有77个节点和254条边。我们设置$d = 16$并运行node2vec来学习网络中每个节点的特征表示。使用k- means对特征表示进行聚类。然后，我们在二维空间中可视化原始网络，现在节点根据它们的集群分配颜色。 图3(顶部)显示了我们设置$p = 1, q = 0.5$时的示例。注意网络的区域(即，网络社区)使用相同的颜色。在这个场景中，node2vec发现了在小说的主要情节中经常相互作用的角色集群/社区。由于字符之间的边缘是基于共现的，我们可以得出结论，这种特征与同质性密切相关。 为了发现哪些节点具有相同的结构角色，我们使用相同的网络，但设$p = 1, q = 2$，使用node2vec获取节点特征，然后根据获得的特征对节点进行聚类。在这里，node2vec获得了一个节点到集群的互补分配，这样颜色就对应于结构等价性，如图3(底部)所示。例如，node2vec将蓝色的节点嵌入在一起。这些节点代表了小说中不同次要情节之间的桥梁。类似地，黄色节点主要表示位于外围的字符，它们之间的交互作用有限。可以为这些节点集群分配不同的语义解释，但关键是node2vec并不与特定的等价概念相关联。我们的实验表明，这些等价概念通常出现在大多数真实网络中，并且对预测任务的学习表示的性能有显著影响。 4.2 试验设置我们的实验评估了通过node2vec获得的标准监督学习任务的特征表示:节点的多标签分类和边的链接预测。对于这两个任务，我们评估了node2vec相对于以下特征学习算法的性能: 谱聚类[29]: 这是一种矩阵分解方法，我们取归一化的d个特征向量图G的拉普拉斯矩阵作为节点的特征向量表示。 DeepWalk[24]: DeepWalk中的采样策略可以看作是node2vec的一个特例，即$p = 1, q = 1$。 LINE[28] 我们排除了其他矩阵分解方法，这些方法已经被证明不如DeepWalk[24]。我们也排除了最近的一种方法，GraRep[6]，它概括了LINE来合并超过2跳的网络邻居的信息，但是不能有效地扩展到大型网络。 在采样阶段，将DeepWalk、LINE和node2vec的参数设置为在运行时生成相同数量的样本。例如，如果$\\cal K$是总体的采样设定，那么node2vec参数满足$\\cal K = \\mit r.l.|V|$。在优化阶段，所有这些基准测试都使用SGD进行优化，其中有两个关键的差异需要我们进行校正。首先，DeepWalk使用分层抽样来近似softmax概率，其目标类似于node2vec使用的目标。然而，与负采样[22]相比，分层softmax是低效的。因此，在保持其他一切不变的情况下，我们对DeepWalk进行负采样。其次，node2vec和DeepWalk都有一个用于优化上下文邻居节点数量的参数，并且节点数量越大，需要进行的优化轮数就越多。这个参数被设置为和LINE一致的，但是LINE比其他方法更快地完成一个epoch，我们让它运行k个epoch。 node2vec使用的参数设置与DeepWalk和LINE使用的典型值一致。具体地，我们设置$d = 128, r = 10, l = 80, k = 10$，并且优化运行一个epoch。我们对10个随机种子初始化重复实验，我们的结果具有统计学意义，p值小于0.01。通过在$p,q \\in \\{0.25, 0.50, 1, 2, 4\\}$上进行网格搜索，对10%标记数据进行10次交叉验证，获得最佳的向内-向外和返回超参数。 4.3 多分类在多标签分类设置中，每个节点从一个有限集$\\cal L$中分配一个或多个标签。在训练阶段，我们观察一定比例的节点及其所有标签。任务是预测剩余节点的标签。这是一个具有挑战性的任务，尤其是当$\\cal L$很大的时候。我们利用以下数据集: BlogCatalog[38]: 这是BlogCatalog网站上列出的博客作者的社会关系网络。标签代表博主的兴趣，这些兴趣是通过博主提供的元数据推断出来的。网络有10,312个节点，333,983条边，39个不同的标签。 蛋白质-蛋白质相互作用(PPI)[5]: 我们使用PPI网络的一个子图来研究智人。该子图对应由节点诱导的图，我们可以从标志基因集[19]中获得标记，并表示生物状态。该网络有3,890个节点，76,584条边，以及50个不同的标签。 Wikipedia[20]: 这是一个由出现在Wikipedia转储的前一百万字节中的单词组成的并发网络。这些标签表示使用Stanford POS - Tagger[32]推断的词性(POS)标记。该网络有4,777个节点、184,812条边和40个不同的标签。 所有这些网络都表现出相当程度的同质性和结构等价性。例如，我们期望博客的社交网络表现出强烈的基于同质性的关系；然而，也可能有一些“熟悉的陌生人”，即，博客不互动，但有共同的兴趣，因此在结构上是等同的节点。蛋白质-蛋白质相互作用网络中蛋白质的生物学状态也表现出这两种等价性。例如，当蛋白质执行与邻近蛋白质互补的功能时，它们表现出结构上的等价性;而在其他时候，它们以同质性为基础组织起来，协助邻近蛋白质执行类似的功能。摘要在维基百科语料库长度为2的窗口中，由于单词间的边界存在，所以单词间的关联网络比较密集。因此，具有相同POS标签的单词并不难找到，它们具有高度的同质性。同时，由于语法模式的不同，如名词跟在限定词后面，标点跟在名词后面等，我们希望POS标签在结构上能有一定的对等。 实验结果。将节点特征表示输入到一个具有L2正则化的one-vs-rest逻辑回归分类器中。训练和测试数据平均分配在10个随机实例中。我们使用Macro-F1（宏观F1）分数来比较表2中的性能，相对性能增益超过了最接近的基准。Micro-F1（微观F1）和准确性的趋势是相似的。 在BlogCatalog中，通过将参数$p$和$q$设置为较低的值来发现同质性和结构等价性的正确组合，从而Macro-F1得分超出DeepWalk22.3%、超过LINE229.2%。在PPI网络中，最好的探索策略($p = 4, q = 1$)与DeepWalk($p = 1, q = 1$)几乎没有区别，通过使用高p值避免已经访问过的节点的冗余，对比DeepWalk只有一个微弱优势，但是Macro-F1得分超出LINE23.8%。在维基百科中，均匀随机游走不能将搜索过程导向最佳样本，因此，macro-F1得分超出DeepWalk21.8%，超出LINE33.2%。 在性能上，同时将训练测试从10%更改为90%，对10%的数据学习参数p和q。为简洁起见，结果如图4所示。所有的方法都明显优于谱聚类，DeepWalk优于LINE, node2vec始终优于LINE。例如，我们在BlogCatalog 70%的标签数据上取得了最大的进步，超过DeepWalk26.7%。 4.4 参数敏感度 node2vec算法涉及许多参数，在图5a中，我们使用带标记和未带标记的数据各占一半的比例来研究不同参数的选择如何影响BlogCatalog数据集上node2vec的性能。除了要测试的参数外，其他所有参数都采用默认值。$p$和$q$的默认值设置为一致的。 我们将宏观F1分数作为参数$p$和$q$的函数进行测量，node2vec的性能随着向内-向外参数$p$和返回参数$q$的降低而提高。性能的提高可以基于我们期望在BlogCatalog中看到的同质性和结构等价性。当低$q$值时鼓励向外探索时，它被低$p$值所平衡，这确保了行走不会离起始节点太远。 我们还研究了特征数$d$和节点的邻域参数(步数$r$、步长$l$和邻域大小$k$)如何影响性能。我们观察到，一旦表示的维度达到100左右，性能就趋于饱和。类似地，观察到增加每个源的遍历次数和长度可以提高性能，因为有更大的总体抽样集$\\cal K$来学习表示。另外上下文大小$k$也提高性能，代价是增加了优化时间。但是在这种情况下，性能差异不是很大。 4.5 扰动分析对于许多真实的网络，我们无法获得关于网络结构的准确信息。我们进行了一个扰动研究，分析了node2vec在两个与BlogCatalog网络中的边结构相关的不完全信息场景下的性能。在第一个场景中，我们将性能作为缺失边的分数(相对于整个网络)的函数来度量。根据网络中连通分量数量不变的约束条件，随机选取缺失的边。从图5b(上)可以看出，随着缺失边比例的增加，宏观F1分数的下降大致呈线性，且斜率较小。 在第二个扰动设置中，我们在网络中随机选择的节点对之间有噪声边。如图5b所示(下图)，与缺失边设置相比，node2vec的初始下降速度略快，但随着时间的推移，宏观F1分数的下降速度逐渐放缓。同样，node2vec对假边的鲁棒性在一些情况下是有用的，例如用于构建网络的测量是有噪声的传感器网络。 4.6 可扩展性(Scalability) 为了测试可扩展性，我们使用node2vec学习节点表示，该节点表示具有Erdos-Renyi图的默认参数值，其大小从100个节点增加到100万个节点，平均度数为10。在图6中，我们根据经验观察到，node2vec随着节点数量的增加而线性扩展，在不到4小时的时间内为100万个节点生成表示。抽样程序包括计算我们的步行的转移概率的预处理和随机步行的模拟。利用负采样[22]和异步SGD[26]使优化阶段变得有效。 4.7 链路预测 在链路预测中，我们给定一个删除了一定比例边的网络，我们希望预测这些缺失边。我们生成边的标签数据集如下:获得正样本,我们除去50%的边缘随机选择从网络同时确保获得的残余网络边删除连接后,产生负样本,我们随机样本同等数量的节点对网络没有边缘连接。 根据一些流行的启发式分数对node2vec进行了额外的评估，这些分数在链接预测中获得了良好的性能。我们考虑的分数是根据构成这一对的节点的邻域集来定义的(见表3)。我们在以下数据集测试我们的基准: Facebook[14]: 在Facebook网络中，节点代表用户，边代表任意两个用户之间的友谊关系。该网络有4,039个节点和88,234条边。 蛋白-蛋白相互作用(PPI)[5]: 在PPI网络中，节点表示蛋白质，边表示一对蛋白质之间的生物相互作用。该网络有19,706个节点和390,633条边。 arXiv ASTRO-PH[14]:这是一个协作网络，由提交给e-print arXiv的论文生成，其中节点代表科学家，如果两名科学家合作过一篇论文，则存在一条边。网络已经18,722个节点和198,110条边。 实验结果。我们在表4中总结了链接预测的结果。为了便于表示，省略了每个node2vec条目的最佳$p$和$q$参数设置。从结果中我们可以得出一个普遍的观察结果，即节点对的学习特征表示显著优于启发式基准评分，其中node2vec对arXiv数据集的AUC提升最好，比性能最佳的基线(Adamic-Adar[1])提高了12.6%。","link":"/2020/01/05/graph-embedding-node2vec/"},{"title":"【Graph Embedding】struc2vec","text":"关于Graph Embedding系列的论文翻译解读文章： 【Graph Embedding】DeepWalk 【Graph Embedding】line 【Graph Embedding】node2Vec 【Graph Embedding】SDNE 【Graph Embedding】struc2vec 参考资料 paper: https://arxiv.org/pdf/1704.03165.pdf code: https://github.com/leoribeiro/struc2vec 摘要结构一致性是一个对称的概念，其中网络节点是根据网络结构及其与其他节点的关系来识别的。结构一致性在过去的几十年里已经在理论和实践中得到了研究，但直到最近才被表征性学习技术解决。这项工作提出了struc2vec，这是一种新颖且灵活的框架，用于学习节点结构身份的潜在表示。使用层次结构来测量不同尺度下的节点相似性，并构建多层图来编码结构相似性并生成节点的结构上下文。数值实验表明，最先进的节点表示学习技术未能捕获更强的结构身份概念，而struc2vec在这一任务中表现出更优越的性能，因为它克服了之前方法的限制。因此，数值实验表明，struc2vec提高了更多依赖于结构特性的分类任务的性能。 1. 介绍在几乎所有的网络中，节点往往具有一个或多个功能，这些功能在很大程度上决定了它们在系统中的角色。例如,社交网络中的社会角色和社会地位[11、19]，而蛋白质-蛋白质交互(PPI)网络施加specific函数[1,22]。直观地说,这些网络中的不同节点可能执行类似的功能，例如企业社交网络中的实习生，或者细胞PPI网络中的催化剂。根据节点在网络中的作用，可以将节点划分为等价的类。虽然当节点功能完全由网络结构决定时，就出现了利用节点的功能描述。在这种情况下，甚至连节点的标签也不是，而是它们与其他节点(边)的关系。事实上，自20世纪70年代以来，数学社会学家一直在研究这个问题，他们设计并计算社会网络中个体的结构身份[11,17,19]。除了社会学，webgraph中网页的角色是从网络结构中出现另一个身份(在这里是中心和权威)的例子，正如Kleinberg[8]的著名著作所描述的那样。 最常见的确定节点结构身份的实用方法是基于距离或递归。在前者中，利用节点的邻域的距离函数来测量所有节点对之间的距离，然后进行聚类或匹配，将节点放入等价的类中[5,9]。在后一种方法中，构造一个关于邻近节点的递归，然后迭代展开，直到收敛，使用最终值确定等价类[3,8,26]。虽然这种方法有优点和缺点，我们提供了一种替代方法，一种基于无监督学习的表示节点的结构身份。最近在学习网络中节点的潜在表示方面的研究在分类和预测任务方面取得了很大的成功[6,14,16,23]。特别是，这些工作将节点作为上下文编码，使用它们的邻居的一个通用概念(例如，随机游走的第w步，或具有共同邻居的节点)。简而言之，具有相似节点集的邻域的节点应该具有相似的潜在表示。但是邻域是由网络中的邻近性概念所决定的局部概念。因此，如果两个节点的邻居在结构上相似，但相距很远，则不会有相似的潜在表示。图1说明了这个问题，其中节点$u$和$v$扮演类似的角色(即但是在网络中它们之间的距离非常远。由于它们的邻居没有公共节点，所以最近的方法无法捕捉它们的结构相似性。 值得注意的是，最近用于学习节点表示的方法(如DeepWalk[16]和node2vec[6])在分类任务中成功，但在结构等价任务中往往失败。关键在于，在大多数真实网络中，许多节点特征表现出很强的同质性(例如，具有相同政治倾向的两个博客比随机连接的可能性要大得多)。具有给定特性的节点的邻居更有可能具有相同的特性。在我们看来，网络中距离较近的节点和潜在表示的节点往往具有相同的特征。同样地，网络中较远的两个节点也会倾向于在潜在表示中被分开，独立于它们的局部结构。因此，结构上的等价性将不能被适当地捕获在潜在的表示中。然而，如果对更多依赖于结构一致性而较少依赖于同质性的特征进行分类，那么这些最近的方法可能会被捕获结构等价的潜在表征所超越。 我们的主要贡献是一个可行的框架，用于学习节点结构身份的潜在表示，称为struc2vec。它是通过潜在表征研究结构一致性的一种替代和有力的工具。struc2vec的主要思想是： 评估独立于节点和边缘的节点之间的结构相似性，以及它们在网络中的位置。因此，两个具有相似的局部结构的节点将被认为是独立于其邻域内的网络位置和节点标签的。我们的方法也不需要连接网络，并且在不同的连接组件中定义了结构上类似的节点。 建立一个等级体系来衡量结构相似性，允许对结构相似性的定义逐渐变得更加严格。特别是，在层次结构的底部，节点之间的结构相似性只取决于它们的度，而在层次结构的顶部，相似性取决于整个网络(从节点的角度来看)。 为节点生成随机上下文，这些节点是结构相似的节点的序列，通过一个加权的随机漫步遍历一个多层图(而不是原始网络)可以观察到。因此，经常出现具有相似上下文的两个节点可能具有相似的结构。语言模型可以利用这种上下文来学习节点的潜在表示。 我们实现了一个struc2vec的实例，并通过一个例子和真实网络的数值实验，展示了它的潜力，和DeepWalk[16]、node2vec[6]、RolX[7]比较其性能。我们的结果表明，DeepWalk和node2vec未能捕捉到结构身份的概念，但struc2vec在这一任务中表现出色，即使原始网络受到强随机噪声(随机边缘去除)的影响。我们还证明了struc2vec在类分类任务中更优，在类分类任务中，节点标签更多地依赖于结构标识(例如，航空运输网络，标签代表机场活动)。 我们实现的一个实例struc2vec并通过数值实验显示其潜在的例子和实际网络,和DeepWalk[16]、node2vec[6]、RolX[7]比较其性能。 2. 相关工作在欧几里得空间中嵌入网络节点在过去几十年里受到了不同社区的重视。该技术对于利用网络数据的机器学习应用程序很有帮助，因为节点嵌入可以直接用于类分类和集群等任务。 在自然语言处理[2]中，为稀疏数据生成密集的embedding向量具有悠久的历史。最近,Skip-Gram[12、13]提出了作为一个高效的技术去学习嵌入文本数据(例如,句子)。在其他属性中，学习到的语言模型将语义相似的单词放在空间中相邻的位置。 DeepWalk[16]首先提出了从网络中学习语言模型。它使用随机游走从网络中生成节点序列，然后用Skip-Gram把这些节点当作句子。直观地说，在网络中接近的节点往往具有相似的上下文(序列)，因此它们的嵌入彼此很接近。这个想法后来被node2vec[6]扩展。node2vec提出了一个偏置的二阶随机游走模型，在生成顶点的上下文时提供了更多的灵活性。特别地，驱动有偏随机游走的边权值可以在一个矩阵映射图中被设计来同时捕获顶点同质性和结构等价性。然而，一个基本的限制是，如果结构上相似的节点的距离(跳数)大于Skip-Gram的窗口数，它们就永远不会共享相同的上下文。 subgraph2vec[14]是最近另一种学习子图嵌入的方法，与以前的技术不同，它不使用随机游走来生成上下文。另外，节点的上下文只是由它的邻居来决定。此外，subgraph2vec通过将具有相同局部结构的节点嵌入到空间中的相同点来获取结构等价性。尽管如此，结构等价的概念是非常严格的，因为它被定义为一个由Weisfeler - Lehman同构测试[21]决定的二元性质。因此，两个节点在结构上非常相似，并且没有重叠的邻居，在空间上可能并不相邻。 与subgraph2vec类似，最近对学习更丰富的网络节点表示方法进行了大量研究[4, 24]。然而，构建显式捕获结构的表示是struc2vec的重点。 最近一种仅使用网络结构显式标识节点角色的方法是RolX[7]。这种无监督方法的基础是枚举节点的各种结构特征，找出更适合这个联合特征空间的基向量，然后为每个节点分配一个分布在标识的角色(基)上，允许角色之间的混合成员关系。如果没有显式地考虑节点相似性或节点上下文(在结构方面)，RolX很可能会遗漏在结构上等价的节点对。 3. STRUC2VEC考虑获取网络中节点的结构标识的表示学习问题。一个成功的方法应该表现出两个期望的特性： 节点的潜在表示之间的距离应与它们的结构相似度密切相关。因此，两个具有相同局部网络结构的节点应该具有相同的潜在表示，而具有不同结构标识的节点应该相距较远。 潜在表示不应该依赖于任何节点或边缘的属性，包括节点标签。在结构上相似的节点应该有密切的潜在表示，独立于节点和边缘的属性。节点的结构身份必须独立于其在网络中的位置。、 考虑到这两个特性，我们提出了struct2vec，这是一个学习节点潜在表示的通用框架，由以下四个主要步骤组成： （1）对于不同的邻域大小，确定图中每个顶点对之间的结构相似性。这在节点之间的结构相似性度量中引入了层次结构，提供了更多的信息来评估层次结构的每一层的结构相似性。 （2）构造一个加权的多层图，其中网络中的所有节点都存在于每一层中，每一层在测量结构相似度时对应于层次的一个层次。此外，各层内各节点对的权值与结构相似度成反比。 （3）使用多层图为每个节点生成上下文。特别地，在多层图上使用有偏随机游走来生成节点序列。这些序列可能包括结构上更相似的节点 （4）应用一种技术，从由节点序列给出的上下文中学习潜在表示，例如，Skip-Gram。 请注意，struct2vec是完全可以实现的，因为它不要求任何特定的结构相似性度量或表示学习框架。接下来，我们将详细解释struct2vec的每个步骤，并提供一种严格的方法来测量结构相似性。 3.1 测量结构相似struct2vec的第一步是确定两个节点之间的结构相似性，而不使用任何节点或边缘。此外，这种相似性度量应该是层次化的，并且能够处理不断增加的邻域大小，从而捕捉到更多有关结构相似性的概念。直观地说，具有相同度的两个节点在结构上是相似的，但是如果它们的邻居也具有相同度，那么它们在结构上甚至更加相似。 令$G = (V,E)$代表顶点集$V$和的无向无权边集$E$的网络，其中$n = |V|$表示网络中的节点数，$k^*$是其直径。令$R_k(u)$代表在$G$中与$u$的距离（跳数）恰好为 $k \\geq 0$的节点集。注意$R_1(u)$代表$u$的邻居,$R_k(u)$表示距离$k$的节点环。设$s(S)$为节点集合$S \\subset V$的有序度序列。通过比较距离$u$和$v$为k处的环的有序度序列，我们可以建立一个层次结构来衡量结构相似性。其中，令$f_k(u,v)$表示在考虑其$k$跳邻域时，$u$和$v$之间的结构距离(距离小于等于$k$的所有节点以及它们之间的所有边)。定义如下： f_k(u,v) = f_{k-1}(u,v) + g(s(R_k(u)), s(R_k(v))), \\\\ k \\geq 0 \\quad and \\quad |R_k(u)|, |R_k(v)| > 0 \\tag{1}其中$g(D_1,D_2) \\geq 0$表示有序次序列$D_1$和$D_2$之间的距离，并且$f_{-1} = 0$。注意，根据定义，$f_k(u,v)$在$k$中不递减，只有当$u$或$v$在距离$k$处都有节点时才有定义。此外，在$f_k(u,v)$中使用距离为$k$的环，可以强制比较距离为$u$和$v$相同的节点的度序列。最后，注意如果$u$和$v$的$k$跳邻域是同构的，并且将$u$映射到$v$上，那么$f_{k-1}(u,v) = 0$。 最后一步是确定比较两个度序列的函数。注意，$s(R_k(u))$和$s(R_k(v))$可以是不同的大小，其元素是[0, n-1]范围内的任意整数，可能存在重复。我们采用动态时间规整(Dynamic Time Warping, DTW)来测量两个有序度序列之间的距离，该技术可以更好地处理不同大小的序列，并对序列模式进行松散比较[18,20]。 非正式地说，DTW是两个序列A和B之间的最优比对。给定一个距离函数$d(a, b)$，对于序列中的元素，DTW匹配每个元素$a \\in A$到$b \\in B$，使得匹配元素之间的距离之和最小。由于序列A和B的元素是节点的度数，我们采用以下距离函数: d(a, b) = \\frac{max(a,b)}{min(a,b)} - 1 \\tag{2}注意当$a = b$时，$d(a,b) = 0$。因此，两个相同的有序度序列的距离为零。还要注意，通过取最大值和最小值的比值，1和2的度数比101和102的度数差得多，这是在测量节点度数之间的距离时所需的属性。最后，当我们使用DTW来评估两个有序度序列之间的相似度时，我们的框架可以采用任何其他的损失函数。 3.2 构建上下文图我们构造了一个多层加权图来编码节点之间的结构相似性。设$M$表示用节点的$k$跳邻域表示$k$层的多层图。每一层$k = 0,…,k^*$是由具有节点集$V$的加权无向完全图构成的，因此，对于${n \\choose 2}$条边，层中两个节点之间的边权值为： w_k(u,v) = e^{-f_k(u,v)},k=0,...,k^\\* \\tag{3}请注意，只有在定义了$f_k(u,v)$的情况下才定义边，并且权重与结构距离成反比，并且假设值小于等于1，只有当$f_k(u,v)=0$时才等于1。注意，在结构上与$u$相似的节点在$M$的各个层上的权值更大。 我们使用有向边连接这些层，如下所示。每个顶点被连接到它在上面和下面层的相应顶点。因此，$k$层的每个顶点$u \\in V$都与对应的$k + 1$层和$k - 1$层的顶点$u$相连。层间的边权重如下: \\begin{eqnarray} &w(u_k, u_{k+1})& = log(\\Gamma_k(u) + e) , k=0,...,k^\\*-1 \\\\ &w(u_k, u_{k-1})& = 1, k=1,...,k^\\* \\tag{4} \\end{eqnarray}其中$\\Gamma_k(u)$是与$u$关联的边数，其权值大于$k$层中完整图的平均边权值。特别低： \\Gamma_k(u) = \\sum_{v \\in V} 1(w_k(u,v) > \\bar{w_k}) \\tag{5}其中$\\bar{w_k} = \\sum_{(u,v) \\in {V \\choose 2}}w_k(u,v) / {n \\choose 2}$。因此，$\\Gamma_k(u)$度量$k$层中节点$u$与其他节点的相似度。请注意，如果当前层中有许多类似的节点，那么它应该更改层以获得更多的上下文。注意，向上移动一层，类似节点的数量只会减少。最后，log函数简单地减少了给定层中与$u$相似的大量节点的数量。注意$M$有$nk^*$个顶点，最多$k * {n \\choose 2} + 2n(k^* - 1)$条加权边。 3.3 为节点生成上下文使用多层图$M$为每个节点生成结构上下文$u \\in V$。注意，$M$完全不使用任何标签信息来捕获$G$中节点之间的结构相似性。与之前的工作一样，struct2vec使用随机游走来生成节点序列，以确定给定节点的上下文。特别地，我们考虑一个有偏的随机游走，它在$M$附近移动，根据$M$的权值做出随机选择。在每一步之前，随机游走首先决定它是要改变层还是在当前层上行走(随机行走停留在当前层的概率为$q &gt; 0$)。 假设它将停留在当前层，则在$k$层中从节点$u$到节点$v$的概率为: p_k(u, v) = \\frac{e^{-f_k(u,v)}}{Z_k(u)} \\tag{6}其中$Z_k(u)$是在$k$层的节点$v$的归一化因子： Z_k(u) = \\sum_{v \\in V,v \\neq u}e^{-f_k(u,v)} \\tag{7}请注意，随机游走将更倾向于走到与当前顶点在结构上更相似的节点上，避免与它的结构相似度很低的节点。因此，一个节点$u \\in V$的上下文可能具有结构上类似的节点，与它们的标签和它们在原始网络$G$中的位置无关。 存在概率为$1 - q$，随机游走决定改变层数，并以与边权值成正比的概率移动到$k + 1$层或$k - 1$层中相应的节点。特别是: \\begin{eqnarray} &p_k(u_k, u_{k+1})& = \\frac{w(u_k, u_{k+1})}{w(u_k, u_{k+1}) + w(u_k, u_{k-1})} \\\\ &p_k(u_k, u_{k-1})& = 1 - p_k(u_k, u_{k+1}) \\tag{8} \\end{eqnarray}注意，每次在层中行走时，它都将当前顶点作为上下文的一部分，独立于层。因此，一个顶点$u$可能在第$k$层有一个给定的上下文(由这个层的结构相似度决定)，但是在第$k + 1$层有这个上下文的一个子集，因为当我们移动到更高的层时，结构相似度不能增加。 最后，对于每个节点$u \\in V$，我们在其相应的顶点在0层开始随机游走。随机漫步的长度固定且相对较短(步数)，并且该过程重复一定次数，从而产生多个独立的随机游走结果(即，节点$u$的多个上下文)。 3.4 学习一个语言模型最近的语言建模技术已经广泛地用于学习单词嵌入，并且只需要几组句子就可以生成有意义的表示。非正式地说，这个任务可以定义为学习给定上下文的单词概率。特别是，Skip-Gram[12]已被证明是有效的学习各种数据的有意义的表示。为了将其应用到网络中，可以使用人工生成的节点序列来代替句子。在我们的框架中，这些序列是由多层图$M$上的有偏随机游走产生的。给定一个节点，跳跃图的目标是最大化其在序列中上下文的可能性，其中一个节点的上下文由一个以其为中心的大小为$w$的窗口给出。 对于这项工作，我们使用Hierarchical Softmax。对于每个节点$v_j \\in V$，Hierarchical Softmax在分类树中指定一条特定的路径，由一组树节点$n(v_j,1),n(v_j,2),…,n(v_j,h)$定义，其中$n(v_j,h) = v_j$，在这种情况下： P(v_j | v_i) = \\prod_{k=1}^h C(n(v_j,k), v_i) \\tag{9}其中$C$是树中每个节点的二分类器。注意，因为分层Softmax操作的是二叉树，所以复杂度为$O(log|V|)$。 我们根据式(9)给出的优化问题来训练Skip-Gram。请注意，我们使用Skip-Gram来学习节点嵌入，任何其他学习文本数据潜在表征的技术都可以在我们的框架中使用。 3.5 复杂度和优化为了构造M，必须计算每个层的每个节点对之间的结构距离，即对$u,v \\in V$计算$f_k(u, v)$,且$0 \\leq k \\leq k^*$。然而，$f_k(u,v)$使用了两个度序列之间的DTW计算结果。而经典的DTW实现其复杂度为$O(\\ell^2)$，存在复杂度为$O(\\ell)$的快速技术，其中$\\ell$是最大序列的大小。设$d_{max}$为网络中最大的度。对所有的节点$u$和层$k$，度序列的大小$|s(R_k(u))| \\leq min(d_{max}^k, n)$。因为在每层中有${n \\choose 2}$节点对，计算k层中所有距离的复杂度为$O(n^2 . min(d_{max}^k, n))$。最终的复杂度为$O(k * n^3)$。在接下来的部分中，我们将描述一系列的优化，这些优化将显著减少框架的计算和内存需求 减少度序列的长度(OPT1)。尽管k层的度序列的长度以$min(d_{max}^k, n)$为界，对于某些网络，即使$k$很小，这个长度也会很大(例如，对于$k = 3$，序列已经是$O(n)$)。为了降低比较大序列的成本，我们提出对有序度序列进行如下压缩。对于序列中的每个度，我们计算该度的出现次数。压缩的有序度序列是一个包含度和出现次数的元组。由于网络中的许多节点往往具有相同的度，因此在实践中，压缩后的有序度序列可以比原来的有序度序列小一个数量级。 设$A^{‘}$和$B^{‘}$分别表示$A$和$B$的压缩度序列。由于$A^{‘}$和$B^{‘}$的元素是元组，所以我们采用了如下函数计算DTW距离： dist(a, b) = \\left(\\frac{max(a_0, b_0)}{min(a_0, b_0)} - 1 \\right)max(a_1, b_1) \\tag{10}其中$a = (a_0, a_1)$和$b = (b_0, b_1)$是在$A^{‘}$和$B^{‘}$中的元组，$a_0$和$b_0$是度，$a_1$和$b_1$是出现的次数。注意，使用压缩的度序列会导致具有相同度的原始序列片段之间的比较(而不是比较每个度)。因此，由式(10)可以得到原始度序列上的DTW的近似值，如式(2)所示。 减少成对相似度计算的数量(OPT2)。当原始框架在每一层$k$评估每个节点对之间的相似性时，显然这是不必要的。考虑两个度非常不同的节点(例如，2和20)。他们的结构距离即使在$k=0$时也是非常大的。因此，在$M$中它们之间的边的权重非常小。因此，当对这些节点创建上下文时，随机游走不太可能走过这条边，故在$M$中没有这条边并不会显著地改变模型。 我们限制对于每一层$k$中节点的成对相似度计算的数量到$O(log(n))$。设$J_u$代表在$M$中与$u$相邻的节点集合，每一层都是一样的。$J_u$的节点结构应该与$u$是最相似的。为了确定$J_u$，我们取与$u$度最相似的节点。这可以通过对网络中所有节点的有序度序列(对于节点$u$的度)进行二叉搜索，并在搜索完成后的每个方向上取$log n$个连续的节点来方便地计算出来。因此，计算所有节点的$J_u$有$O(nlog(n))$的复杂度。至于内存需求，$M$的每一层现在都有$O(nlog(n))$条边，而不是$O(n^2)$。 减少层数(OPT3)。$M$中的层数由网络的直径$k^*$给出。然而，对于许多网络来说，直径可能远远大于平均距离。此外，评估两个节点之间的结构相似性的重要性随着$k$值的增大而降低。特别的，当$k$接近$k^*$时，环上的度序列$s(R_k(u))$长度也会变得相对较短，因此$f_k(u,v)$与$f_{k-1}(u,v)$相差不大。因此，我们将$M$中的层数限制为$k^{‘} &lt; k^*$，以获取用于评估结构相似性的最重要的层数。这显著减少了构造$M$的计算和内存需求。 4. 试验4.1 杠铃图（Barbell Graph）我们将$B(h,k)$表示为$(h,k)-barbell$图，它由两个完全图$K_1$和$K_2$(每个图有$h$个节点)组成，由一个长度为$k$的路径图$P$连接。两个节点$b_1 \\in V(K_1)$和$b_2 \\in V(K_2)$代表桥梁。使用$\\{p_1, …, p_k\\}$表示$V(P)$，我们将$b_1$连接到$p_1$，$b_2$连接到$p_k$，从而将三个图连接起来。 Barbell Graph具有相同结构标识的节点数目。设$C_1 = V(K_1) / \\{b_1\\}$和$C_2 = V(K_2) / \\{b_2\\}$，注意$v \\in \\{C_1 \\cup C_2\\}$是结构上等价的，任何一对这样的节点之间都存在自同构。此外，我们还有所有的节点对$\\{p_i, p_{k-i}\\}，1 \\leq i \\leq k-1$，与$\\{b_1, b_2\\}$在结构上是等同的。图2展示了一个$B(10, 10)$图，结构等效节点有相同的颜色。 因此，我们期望struct2vec学习顶点表示来获得上面提到的结构等价性。每个在结构上等价的节点对都应该具有类似的潜在表示。此外，学习表示还应该捕获结构层次：虽然节点$p_1$并不等同于节点$p_2$或节点$b_1$，但我们可以清楚地看到，从结构的角度来看，它更类似于$p_2$。 根据图2，DeepWalk没有捕捉到结构上的等价，这是意料之中的，因为它没有考虑到结构上的等价。即使node2vec的参数$p$和$q$有不同的变化，它也不能捕获结构标识。实际上，它学习的主要是图的距离，将更近的节点放在图中更近的潜在空间节点上。node2vec的另一个限制是，Skip-Gram的窗口大小使得$K_1$和$K_2$中的节点不可能出现在相同的上下文中。 另一方面，struct2vec学习正确分隔相同类的表示，将在结构上等价的节点放在彼此附近的潜在空间中。注意，相同颜色的节点紧密地分组在一起。此外，$p_1$和$p_10$被放置在$K_1$和$K_2$的节点附近，因为它们是桥梁。最后，请注意，这三种优化对表示的效果没有任何影响。实际上，在OPT1下的潜在表示中，结构上等价的节点之间的距离更近。 最后，我们将$RolX$应用于杠铃图(图2(b))。总共确定了6个角色，其中一些角色确实精确地捕获了结构等价性(角色1和角色3)。然而，在结构上等价的节点(在$K_1$和$K_2$中)被放置在三个不同的角色中(角色0、角色2和角色5)，而角色4包含路径中所有剩余的节点。因此，尽管在向节点分配角色时，RolX确实捕获了一些结构等价的概念，但struct2vec更好地识别和分离了结构等价。 4.2 空手道网络（Karate Network）空手道俱乐部[25]是一个由34个节点和78条边组成的网络，其中每个节点代表一个俱乐部成员，边表示两个成员在俱乐部外互动。在这个网络中，边缘通常被解释为成员之间友谊的象征。 我们构建一个网络组成的两个副本的$G_1$和$G_2$，其中每个节点$v \\in V(G_1)$都有一个镜像节点$u \\in V(G_2)$。我们还通过在镜像节点1和37之间添加一条边来连接两个网络。尽管这对于我们的框架来说不是必需的，但是DeepWalk和node2vec不能将图的不同连接组件放在相同的上下文节点中。因此，为了与两个基线进行更公平的比较，我们添加了边。图4a展示了具有相同颜色对应对的镜像网络。 图3展示了通过DeepWalk，node2vec和struct2vec学习的潜在表示，显然，Deepwalk和node2vec并没有在潜在空间中得到结构上等价的节点，包括镜像节点。 同样，struct2vec设法学习能够正确捕获节点的结构标识的特性。镜像对-在潜在空间中有相同颜色的节点-保持紧密的联系，在表示的组合方式上有一个复杂的结构层次。 例如，请注意节点1、34及其对应的镜像(37和42)在潜在空间中处于单独的集群中。有趣的是，这些节点恰恰代表了俱乐部教练Hi先生和他的管理员John A。网络由两个节点组成，节点1和节点34分别以Mr. Hi和John A为中心，将俱乐部成员分成两组。请注意，struct2vec捕获了它们的函数，尽管它们之间没有边界。 潜伏空间内另一可见簇由节点2，3，4和33，还有他们的镜像节点。这些节点在网络中也具有特定的结构标识：它们都具有较高的度，并且还与至少一个中心相连。最后，节点26和节点25(在潜在空间的最右边)具有非常接近的表示，这与它们的结构作用相一致:它们的度都很低，距离节点34有2跳的距离。 注意，节点7和节点50(粉色和黄色)被映射到潜在空间中的闭合点。令人惊讶的是，这两个节点在结构上是等价的。可以更容易地看到一旦节点6和7也结构等效,和节点6的镜像节点50也结构等效。 最后，图4b显示了$RolX$在镜像空手道网络中标识的角色(标识了28个角色)。注意，1和34被置于不同的角色。1的镜像(节点37)也被放置在不同的角色中，而34的镜像(节点42)被放置在与34相同的角色中。总共有7对对应的配对被置于相同的角色。然而，一些其他的结构相似点也被识别出来，例如，节点6和节点7在结构上是等价的，并被分配了相同的角色。同样，RolX似乎捕获了网络节点之间结构相似性的一些概念，但struct2vec可以通过潜在表示来识别和分离结构等价。 考虑节点的潜在表示之间的距离。我们度量对应于镜像节点的对之间以及所有节点对之间的距离分布(使用图3所示的表示)。图5显示了node2vec和struc2vec学习的表示的两个距离分布。对于node2vec，这两个分布实际上是相同的，这表明镜像对之间的距离与所有对之间的距离很好地融合在一起。struc2vec有两个非常不同的分布:94%的镜像节点对的距离小于0.25，而所有节点对中的68%的距离大于0.25。而且，所有节点对之间的平均距离比镜像节点对的平均距离大5.6倍，而对于node2vec来说，这个比例略小于1。 为了更好地描述struc2vec学习的潜在表示中结构距离和距离之间的关系，我们计算了所有节点对的两个距离之间的相关性。特别地，对于每一层$k$，我们计算$f_k(u,v)$之间的Spearman和Pearson相关系数，如公式(1)所示，以及学习表示中$u$和$v$之间的欧氏距离。表1所示的镜像空手道网络的结果确实证实了两个距离之间存在很强的相关性，对于每一层，这两个系数都能捕捉到。这表明，struc2vec确实在潜在空间中捕获了该方法所采用的结构相似性测度。 4.3 边缘去除的鲁棒性我们说明了在噪声存在时，该框架在表征结构特性方面的潜力。特别是，我们从网络中随机删除边，直接改变其结构。我们采用简约的边缘采样模型来实例化两个结构相关的网络[15]。该模型的工作原理是取一个固定的图$G = (V,E)$通过对每条边$e \\in E$以概率$s$进行采样，生成一个图$G_1$。因此，$G$中的每条边以概率$s$在$G_1$中存在。使用$G$重复此过程以生成另一个图$G_2$。因此，$G_1$、$G_2$是结果相关的的，$s$控制结构相关量。注意当$s=1$时，$G_1$和$G_2$是同构的，当$s=0$时，所有结构消失。 我们将边缘采样模型应用于从Facebook(224个节点，3192条边，最大度99，最小度1)[10]中提取的egonet，生成不同$s$值的$G_1$和$G_2$。我们重新标记$G_2$中的节点(以避免相同的标签)，并将两个图的并集作为框架的输入网络。注意，这个图至少有两个连接的组件(对应于$G_1$和$G_2$)，每个节点(在$G_1$中)都有一个对应的组件(在$G_2$中)。 图6为$s$各值对应的节点对与所有节点对之间的距离分布(对应的平均值如表2所示)。对于$s = 1$，两种距离分布存在显著差异，所有对的平均距离是对应对的21倍。更有趣的是，当$s = 0.9$时，这两个分布仍然非常不同。注意，进一步减小$s$对所有对的距离分布影响不大，但会缓慢增大对应对的分布。然而，即使$s = 0.3$(即原始边同时出现在G1和G2中的概率为0.09，$s^2$)，该框架仍将相应的节点更靠近潜空间。实验表明了该框架的鲁棒性，即使存在结构噪声，也能揭示节点的结构特征。 4.4 分类网络节点潜在表示的一个常见应用是分类。当节点的标签更多地与它们的结构标识相关，而不是与相邻节点的标签相关时，可以利用struc2vec完成此任务。为了说明这种可能性，我们考虑空中交通网络:未加权的、无定向的网络，其中节点对应于机场，边表示商业航班的存在。机场将被分配一个与他们的活动水平相对应的标签，以航班或人员来衡量(下面讨论)。我们考虑以下数据集： 巴西空中交通网络: 收集自国家民航局(ANAC)从2016年1月至12月的数据。该网络有131个节点，1038条边(直径为5)。 美国空中交通网络: 收集自美国运输统计局2016年1月至10月的数据。网络有1190个节点，13599条边(直径为8)，机场活动以同期通过(到达+离开)机场的总人数来衡量。 欧洲空中交通网络: 收集自2016年1月至11月的欧盟统计局的数据。网络有399个节点，5995条边(直径为5)，机场活动以同期的总起降次数来衡量。 对于每个机场，我们为它们的活动分配四个可能的标签之一。特别是对于每个数据集，我们使用从经验活动分布中获得的四分位数将数据集分为四组，并为每个组分配不同的标签。在美国，标签1是给25%不太活跃的机场，等等。注意，所有的类(标签)都具有相同的大小(机场的数量)。 我们使用struc2vec和node2vec学习每个空中交通网络节点的潜在表示，使用网格搜索为每个案例选择最佳超参数。注意，此步骤不使用任何节点标签信息。每个节点的潜在表示成为训练监督分类器的特征。我们也只考虑节点度作为一个特征，因为它捕获了结构身份的一个非常基本的概念。最后，由于类的大小相同，所以我们只使用准确性来评估性能。使用随机样本重复实验10次来训练分类器，报告其平均性能。 图7显示了所有空中交通网络不同特征的分类性能。显然，struc2vec优于其他方法，而且它的优化具有很强的实用性。对于巴西的网络，struc2vec比node2vec提高了50%的分类精度。有趣的是，对于这个网络，node2vec的平均性能(略)低于节点度，这表明了节点的结构身份在分类中的重要性。 4.5 可扩展性 为了说明它的可扩展性，我们对Erdos-Renyi随机图模型的实例应用了优化的struc2vec(使用128维、每个节点十次游走、行走长度80、Skip-Gram窗口10)。我们计算了在大小为100到1,000,000个节点和平均度为10的图上运行10次独立运行的平均执行时间。为了加快对语言模型的训练，我们使用了带负采样[13]的Skip-Gram。图8显示了执行时间(以log-log比例表示)，表明struc2vec的比例是超线性的，但更接近于线性，而不是$n^{1.5}$(虚线)。因此，尽管struc2vec在最坏情况下具有时间和空间复杂性，但实际上它可以应用于非常大的网络。","link":"/2020/01/15/graph-embedding-struc2vec/"},{"title":"剑指Offer-数据结构与算法练习题","text":"《剑指Offer》中的一些常见练习题，包含二叉树、链表以及其他的一些常见算法练习题；最近又系统性地做了下，大致整理了一下解题思路，均用Python实现，持续更新中… 1. 二叉树首先需要定义好二叉树的结构，后续所有关于二叉树的算法默认其已经定义好对应的树结构，所以在节点处有val、left、right属性。 1.1 定义树节点定义树节点一般如下： 12345class TreeNode(object): def __init__(x): self.val = x self.left = None self.right = None 1.2 根据序列生成一颗树生成树的方法有很多种，通常用到的一般是根据前序遍历的结果生成树和广度优先遍历结果的结果生成树。 根据前序遍历的结果生成树： 1234567891011def create_tree_by_list_1(arr): if len(arr) &lt;= 0: return None val = arr.pop(0) root = None if val != &quot;#&quot;: # 先左后右 root = TreeNode(int(val)) root.left = create_tree_by_list_1(arr) # 一直创建左子树，直到遇到&quot;#&quot; root.right = create_tree_by_list_1(arr) return root 根据广度优先遍历结果生成树 1234567891011121314def create_tree_by_list_2(root, arr, i): if i &lt; len(arr): if arr[i] == &quot;#&quot;: return None else: root = TreeNode(arr[i]) # 向左递归，创建左子树 root.left = create_tree_by_list_2(root, arr, 2 * i + 1) # 向右递归，创建右子树 root.right = create_tree_by_list_2(root, arr, 2 * i + 2) return root else: return None 1.2.1 二叉树序列化和反序列化序列化：将二叉树序列化为一组元素；反序列化：根据一组元素生成一颗二叉树。 12345678910111213def serialize(root): &quot;&quot;&quot; 按照前序遍历顺序，将二叉树序列化为一组元素 &quot;&quot;&quot; if not root: return &quot;#&quot; return str(root.val) + &quot;,&quot; + serialize(root.left) + &quot;,&quot; + serialize(root.right)def deserialize(s): serialized_list = s.split(&quot;,&quot;) # 根据前序遍历的结果生成树 create_tree_by_list_1(serialized_list) 1.3 前中后序遍历均分为递归实现和非递归实现。 1.3.1 前序遍历前序遍历顺序： root —&gt; left —&gt; right。 递归实现 12345678910def pre_order_traversal_1(root): &quot;&quot;&quot; 递归实现二叉树前序遍历 &quot;&quot;&quot; if not root: return None # 中左右 result.append(root.val) # 需提前定义好全局变量result pre_order_traversal_1(root.left) pre_order_traversal_1(root.right) 非递归实现 1234567891011121314151617def pre_order_traversal_2(root): &quot;&quot;&quot; 根据节点入栈出栈进行二叉树前序遍历 &quot;&quot;&quot; queue = [root] order = [] while len(queue): tmp = queue.pop() order.append(tmp.val) # 先进后出，故先将右节点push进行，再push左节点 if tmp.right: queue.append(tmp.right) if tmp.left: queue.append(tmp.left) return order 1.3.2 中序遍历中序遍历顺序：left —&gt; root —&gt; right。 递归实现 12345678910def in_order_traversal_1(root): &quot;&quot;&quot; 递归实现二叉树中序遍历 &quot;&quot;&quot; if not root: return None # 左中右 in_order_traversal_1(root.left) result.append(root.val) # 同样，需要提前定义好全局变量result in_order_traversal_1(root.right) 非递归实现 123456789101112131415161718192021222324def in_order_traversal_2(root): &quot;&quot;&quot; 非递归实现二叉树中序遍历 &quot;&quot;&quot; order = [] if not root: return order queue = [] cur = root while cur or len(queue): # 为了获取到最左节点 while cur: queue.append(cur) cur = cur.left node = queue.pop() order.append(node.val) # 一直往上回溯到有右子树的节点，再push进栈中 while not node.right and len(queue): node = queue.pop() order.append(node.val) cur = node.right # 获取到右节点，对右子树同样进while循环 return order 1.3.3 后序遍历后序遍历顺序： left —&gt; right —&gt; root。 递归实现 12345678910def post_order_traversal_1(root): &quot;&quot;&quot; 递归实现二叉树后序遍历 &quot;&quot;&quot; if not root: return None # 左右中 post_order_traversal_1(root.left) post_order_traversal_1(root.right) result.append(root.val) # 同样，需要提前定义好全局变量result 非递归实现 12345678910111213141516171819def post_order_traversal_2(root): &quot;&quot;&quot; 非递归实现二叉树后徐遍历： 将前前序遍历顺序由root--&gt;left--&gt;right更改为root--&gt;right--&gt;left，再将结果转置一下，即得到left--&gt;right--&gt;root &quot;&quot;&quot; queue = [root] order = [] while len(queue): tmp = queue.pop() order.append(tmp.val) # 先进后出,先左进后右进 if tmp.left: queue.append(tmp.left) if tmp.right: queue.append(tmp.right) order.reverse() return order 1.4 BFS 和 DFS1.4.1 BFS123456789101112131415def bfs(root): if not root: return [] queue = [root] # 入栈顺序 order = [] # 遍历顺序 while len(queue): tmp = queue.pop(0) order.append(tmp.val) # 如果该节点存在对应的左右节点 if tmp.left: queue(tmp.left) if tmp.right: queue(tmp.right) return order 1.4.2 DFS123456789101112131415def dfs(root): if not root: return [] queue = [root] order = [] while len(queue): tmp = queue.pop() order.append(tmp.val) # 后进先出，所以先pop出来的一直都是最左子树的节点 if tmp.right: queue.append(tmp.right) if tmp.left: queue.append(tmp.left) return order 1.4.3 将二叉树打印成多行将二叉树打印成多行，其实就是一个BFS: 12345678910111213141516171819202122def print_tree(root): if not root: return [] queue = [root] order = [] while len(queue): # 获取到当前层的节点数，每个循环只对队列中size个数的节点获取其下属左右节点的操作 size = len(queue) tmp = [] # 获取当前栈中的节点 for i in queue: tmp.append(i.val) order.append(tmp) for _ in range(size): node_now = queue.pop(0) if node_now.left: queue.append(node_now.left) if node_now.right: queue.append(node_now.right) return order 1.4.4 将二叉树按”之”字形打印按照”之”字形打印二叉树，奇数行从左往右打印，偶数行从右往左打印；方法与1.4.3一样，加一步判断层数的奇偶性。 123456789101112131415161718192021222324def print_tree(root): if not root: return [] queue = [root] order = [] while len(queue): # 获取到当前层的节点数，每个循环只对队列中size个数的节点获取其下属左右节点的操作 size = len(queue) tmp = [] # 获取当前栈中的节点 for i in queue: tmp.append(i.val) order.append(tmp) for _ in range(size): node_now = queue.pop(0) if node_now.left: queue.append(node_now.left) if node_now.right: queue.append(node_now.right) # 对于树的层数作一下判断 order = [t if idx % 2 == 0 else t[::-1] for idx, t in enumerate(order)] return order 1.5 中序遍历下的下一个节点给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 考虑如下： 有右子树的：下一个节点就是其右子树的最左边节点； 没有右子树的：a. 是父节点的左子节点，那么父节点就是其下一个节点b. 是父节点的右子节点，找他的父节点的父节点的父节点…，直到当前节点是父节点的左节点，则返回当前节点的父节点(如果没有,则为尾节点) 123456789101112131415161718def get_next_node(root): if not root: return None # 1. 如果有右子树 if root.right: node = root.right while node.left: node = node.left return node # 2. 如果没有右子树 while root.father: tmp = root.father if tmf.left = root: # 直到当前节点是父节点的左子节点 return tmp root = tmp return None 1.6 二叉树的深(高)度输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 1234567def tree_depth(root): if not root: return 0 left = tree_depth(root.left) right = tree_depth(root.right) return max(left, right) + 1 1.6.1 二叉树最小路径与求深度不一样的是，求树是根节点到叶子节点的最小路径长度： 12345678def tree_min_depth(root): if not root: return 0 left = tree_depth(root.left) right = tree_depth(root.right) if left == 0 or right == 0: return left + right + 1 return min(left, right) + 1 1.6.2 判断是否是平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 如果左子树和右子树深度相等则是平衡二叉树：a. 遍历每一个节点，根据获取深度的递归函数，根据该节点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断b. 上述做法有个缺点是，在判断上层节点时，会重复遍历下层节点；如果改为从下往上遍历，如果子树是平衡数，则返回其高度；否则直接停止迭代。 方法一，从上往下迭代： 123456def is_balanced_tree(root): if root is None: return True if abs(tree_depth(root.left) - tree_depth(root.right) &gt; 1): return False return is_balanced_tree(root.left) and is_balanced_tree(root.right) 方法二，从下往上判断 12345678910111213141516171819202122def is_balanced_tree_2(root): &quot;&quot;&quot; 从下往上判断，如果子树是平衡数，则返回其高度；否则直接迭代返回False &quot;&quot;&quot; return get_depth_of_tree(root) != -1def get_depth_of_tree(root): &quot;&quot;&quot; 返回-1，代表不是平衡树 &quot;&quot;&quot; if root is None: return 0 left = get_depth_of_tree(root.left) if left == -1: return -1 right = get_depth_of_tree(root.right) if right == -1: return -1 # 如果子树高度不相等则返回-1，否则返回其树的高度 return -1 if abs(left - right) &gt; 1 else max(left, right) + 1 1.7 获取二叉树的镜像获取二叉树的镜像。根据迭代，不断交换其左右子树即可。 123456789def get_mirror_of_tree(root): if root is not None: # 交换其对应的左右节点 root.left, root.right = root.right, root.left # 递归即可 get_mirror_of_tree(root.left) get_mirror_of_tree(root.right) return root 1.7.1 对称二叉树请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 123456789101112def solution(root): return judge_same_tree(root, root)def judge_same_tree(tree1, tree2): if tree1 is None and tree2 is None: return True if tree1 is None or tree2 is None: return False if tree1.val != tree2.val: return False judge_same_tree(tree1.left, tree2.right) and judge_same_tree(tree1.right, tree2.left) 1.8 根据前序和中序遍历结果重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567891011121314151617def reconstruct_tree(pre, tin): &quot;&quot;&quot; pre: 前序遍历结果 tin: 中序遍历结果 首先根据前序遍历序列中的第一个节点获取到当前树的root节点 再从中序遍历序列中找到root节点对应的idx,该idx以前的便是左子树的节点，以后的便是右子树的节点 递归即可 &quot;&quot;&quot; if not pre or not tin: return None root = TreeNode(pre.pop(0)) idx = tin.index(root.val) # 找到中序遍历结果中对应的idx root.left = reconstruct_tree(pre, tin[:idx]) root.right = reconstruct_tree(pre, tin[idx+1:]) return root 1.9 判断子树输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 123456789101112131415def solution(root1, root2): if not root1 or not root2: return None # 递归考虑root2是否是root1的子树 return judge(root1, root2) or judge(root1.left, root2) or judge(root1.right, root2)def judge(main_tree, sub_tree): if not sub_tree: return True if not main_tree or main_tree.val != sub_tree.val: return False # 同时判断左树和右树是否相同 return judge(main_tree.left, sub_tree.left) and judge(main_tree.right, sub_tree.right) 1.10 二叉树判断路径和在二叉树中判断路径和是否定于一个数；路径和定义为从root到leaf节点的和； 1234567def has_path_sum(root, path_sum): if root is None: return False if root.left is None and root.right is None and root.val == path_sum: return True return has_path_sum(root.left, path_sum - root.val) or has_path_sum(root.right, path_sum - root.val) 1.10.1 不一定以root和leaf开头结尾统计路径和等于一个数的路径数量；路径不一定以root开头，也不一定以leaf结尾。 12345678910111213141516def has_path_sum2(root, path_sum): if root is None: return 0 res = path_sum_start(root, path_sum) + path_sum_start(root.left, path_sum) + path_sum_start(root.right, path_sum) return resdef path_sum_start(root, s): if root is None: return 0 res = 0 if root.val == s: res += 1 res += path_sum_start(root.left, s-root.val) + path_sum_start(root.right, s-root.val) return res 2. 二叉搜索树(BST)二叉搜索树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。二叉查找树中序遍历有序。 2.1 二叉树中第k小的节点给定一棵二叉搜索树，请找出其中的第k小的结点。例如,(5, 3, 7, 2, 4, 6, 8)中，按结点数值大小顺序第三小结点的值为4。 对于二叉搜索树，中序遍历顺序就是从小到大排序的。 1234567891011121314151617181920def find_kth_node(root, k): global result result = [] # 获得中序遍历结果 in_order_traversal(root) if k &gt; len(result) or k &lt;= 0: return None else: return result[k-1] def in_order_traversal(root): if not root: return None # 左中右 in_order_traversal(root.left) result.append(root.val) in_order_traversal(root.right) 3. 其他常见3.1 [双指针]和为S的两个数字输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 左右夹逼，如果和比S小则左边往右挪，如果和比S大则右边往左挪。 123456789101112131415161718def sulution(array, tsum): if len(array) &lt;= 1: return [] start = 0 end = len(array) - 1 while start &lt; end: if array[start] + array[end] == tsum: return [array[start], array[end]] if array[start] + array[end] &lt; tsum: start += 1 if array[start] + array[end] &gt; tsum: end -= 1 return [] 3.2 和为S的连续正数序列输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序；e.g. 9~16、 18,19,20,21,22的和均为100 1)由于我们要找的是和为S的连续正数序列，因此这个序列是个公差为1的等差数列，而这个序列的中间值代表了平均值的大小。假设序列长度为n， 那么这个序列的中间值可以通过（S / n）得到，知道序列的中间值和长度，也就不难求出这段序列了。 2)满足条件的n分两种情况： n为奇数时，序列中间的数正好是序列的平均值，所以条件为：(n &amp; 1) == 1 &amp;&amp; sum % n == 0； n为偶数时，序列中间两个数的平均值是序列的平均值，而这个平均值的小数部分为0.5，所以条件为：(sum % n) * 2 == n. 3)由题可知n &gt;= 2，那么n的最大值是多少呢？我们完全可以将n从2到S全部遍历一次，但是大部分遍历是不必要的。为了让n尽可能大， 我们让序列从1开始，根据等差数列的求和公式：S = (1 + n) * n / 2，得到. 最后举一个例子，假设输入sum = 100，我们只需遍历n = 13~2的情况（按题意应从大到小遍历），n = 8时，得到序列[9, 10, 11, 12, 13, 14, 15, 16]；n = 5时，得到序列[18, 19, 20, 21, 22]。 123456789101112131415import mathdef find_continuous_sequence(tsum): ans = [] for n in range(int(math.sqrt(2 * tsum)), 1, -1): # 判定规则 if (n % 2 == 1 and tsum % n == 0) or ((tsum % n) * 2 == n): result = [] res_min = int((tsum * 1.0 / n) - (n - 1) * 1.0 / 2) res_max = int((tsum * 1.0 / n) + (n - 1) * 1.0 / 2) for j in range(res_min, res_max + 1): result.append(j) ans.append(result) return ans 3.3 连续子数组的最大和计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和。 12345678910111213def find_greatest_sum_of_sub_array(arr): max_sum, cur_sum = -1000000, 0 for i in arr: # 如果当前的和已经小于0，直接将当前元素值赋给cur_sum if cur_sum &lt;= 0: cur_sum = i else: cur_sum += i if cur_sum &gt; max_sum: max_sum = cur_sum return max_sum 3.4 最小的K个数123456789101112131415def get_least_numbers(array, k): # 用前k个初始化 least_numbers_list = array[:k] # 标记一个最大值 max_n = max(least_numbers_list) for n in array[k:]: # 只要找个一个比最大值小的，就替换掉 if n &lt; max_n: least_numbers_list.remove(max_n) least_numbers_list.append(n) max_n = max(least_numbers_list) least_numbers_list.sort() return least_numbers_list 3.5 二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 12345678910def number_of1(n): count = 0 # 如果为负数 if n &lt; 0: n = n &amp; 0xffffffff while n != 0: count += 1 n = n &amp; (n-1) return count 3.6 调整数组顺序使奇数位于偶数前面题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路 要保证奇数和奇数、偶数和偶数之间的相对位置不变。故只能对调或者顺次移动 123456789101112def solution(array): # 相对位置不能变，故只能对调或者顺次移动 array_len = len(array) for i in range(array_len): for j in range(array_len-1, i, -1): # 如果前偶数后奇数就对调其位置 if array[j] % 2 == 1 and array[j-1] % 2 == 0: temp = array[j-1] array[j-1] = array[j] array[j] = temp return array 3.7 孩子们的游戏(圆圈中最后剩下的人)每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 2.3 数学推理：假设在N0=N的时候，第一次出列的孩子在队列中序号为K，那么这个孩子出列后，剩余N-1个孩子的序号是0,1,2….K-1, K+1,K+2,….N-1，这个序列要调整成N-K-1,N-K,N-K+1,…N-2, 0, 1, …,N-K-2，主要变化在：原来的K+1到N-1的每个序号减去（K+1），因为原来K+1的序号变成了0，原来的N-1就就变成了（N-1）-(K+1)=N-K-2,那么原来的0的序号变成了（N-K-1），那么原来的0到K-1的每个序号加上（N-K-1），因此原来的0变成了（N-K-1）。 数学规律总结：设置变化前有N个元素，出列小孩序号为K，那么K=（M-1）%N，设置剩余小孩调整前原始序号为X，那么重新调整后，新序号为f（X）=（X-K-1）% N,将K值带入：f(X)=X0=(X-(M-1)%N-1)%N=(X-M)%N,那么已知X0新序号推原序号就是X=（X0+M）% N 123456def solution(n, m): if n == 0: return -1 if n == 1: return 0 return (solution(n-1, m) + m) % n 3.8 二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 可以从右上角开始查找，如果： 如果数组中的值大于target,则列数减1 如果数组中的值小于target,则行数加1 123456789101112131415def solution(target, array): row = len(array) - 1 col = len(array[0]) - 1 r = 0 c = col while r &lt;= row and c &gt;= 0: if array[r][c] &lt;= target: r += 1 elif array[r][c] &gt;= target: c -= 1 else: return True return False 3.9 旋转数组的最小数字题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路 因为是一个非递减排序数组的一个旋转，所以从头到尾开始遍历，遇到第一个不满足递增规则的，如5—&gt;1，则返回1即可 123456789def solution(rotate_array): if len(rotate_array) &lt;= 0: return 0 res = -1 for num in rotate_array: if num &lt; res: return num res = num 3.10 顺时针打印矩阵题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： \\begin {pmatrix} 1, 2, 3, 4 \\\\ 5, 6, 7, 8 \\\\ 9, 10, 11, 12 \\\\ 13, 14, 15, 16 \\end {pmatrix}则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路 依次打印出： 1: 1, 2, 3, 4 2: 8, 12, 16 3: 13, 14, 15 4: 9, 5 5: 6, 7 6: 11 7: 10 每次只打印矩阵的第0行，再打印矩阵的第0行后将矩阵按照逆时针旋转90度，然后再打印矩阵的第0行。重复进行下去。 1234567891011121314151617181920212223242526272829303132def solution(matrix): result = [] # 先将矩阵的第0行打印出来 while matrix: result.append(matrix[0]) if not matrix: break # 将矩阵按照逆时针旋转90度 matrix = translate_matrix(matrix) return resultdef translate_matrix(m): &quot;&quot;&quot; 将矩阵按照逆时针旋转90度 :param m: :return: &quot;&quot;&quot; row = len(m) col = len(m[0]) translated_m = [] for c in range(col): tmp = [] for r in range(row): tmp.append(m[r][c]) translated_m.append(tmp) translated_m.reverse() return translated_m 3.11 数组中出现次数超过一半的数字题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路 ‘分治法’，先将第一个数字设置为1，下一个数字如果相同，则加1；否则减1，如果次数为0；则将下一个数字次数置换成1 先找出出现次数最多的数字 再判定其出现次数是否大于数组长度的一半 123456789101112131415161718192021222324def solution(numbers): # ‘分治法’，先将第一个数字设置为1，下一个数字如果相同，则加1；否则减1，如果次数为0；则将下一个数字次数置换成1 result = numbers[0] t = 1 # 先找出出现次数最多的数字 for i in range(1, len(numbers)): if t == 0: result = numbers[i] t = 1 if numbers[i] == result: t += 1 else: t -= 1 # 再判定其出现次数是否大于数组长度的一半 t = 0 for i in range(len(numbers)): if numbers[i] == result: t += 1 if t &gt; len(numbers) / 2: return result else: 3.12 将数组排成最小的数题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路对list内的数据进行排序，按照 将a和b转为string后若 int(str(a) + str(b) &lt; str(b) + str(a)) ， 则a在前,如 [‘2’, ‘21’]因为212 &lt; 221 所以排序后为[‘21’, ‘2’] 123456789101112131415161718192021222324# 在python3中,需要用functools中的cmp_to_key方法进行转换from functools import cmp_to_keydef solution_on_py3(numbers): if not numbers: return &quot;&quot; lmb = lambda n1, n2: int(str(n1) + str(n2)) - int(str(n2) + str(n1)) numbers.sort(key=cmp_to_key(lmb)) return ''.join([str(i) for i in numbers])# python2中sorted方法可以有cmp参数，但是在python3中不行def solution_on_py2(numbers): if not numbers: return &quot;&quot; lmb = lambda n1, n2: int(str(n1) + str(n2)) - int(str(n2) + str(n1)) array = sorted(numbers, cmp=lmb) return ''.join([str(i) for i in array])if __name__ == &quot;__main__&quot;: input_l = ['3', '32', '321'] print(solution_on_py3(input_l)) 3.13 丑数题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路 穷举法：对于因子2,3,5都维护一个index值；每次append丑数列表中的丑数由如下规则确定： 初始化2,3,5对应的index_list均为[0],[0],[0] 在丑数列表中找到2,3,5对应index对应的元素值 * 2/3/5 分别判定除以2， 3， 5对应的余数是否为0，如果为0，则对应2,3,5的indxe值加1，例如对于6这个丑数，2和3对应的index值均加上了1 12345678910111213141516171819def solution(index): if index &lt;= 0: return 0 # 丑数列表中第一个为0；后续的丑数递增地添加进list中 ugly_list = [1] index_two = 0 index_three = 0 index_five = 0 for i in range(index - 1): new_ugly = min(ugly_list[index_two] * 2, ugly_list[index_three] * 3, ugly_list[index_five] * 5) ugly_list.append(new_ugly) # 判断添加的丑数是2,3,5中哪个因子的倍数，同时对应的index加上1 if new_ugly % 2 == 0: index_two += 1 if new_ugly % 3 == 0: index_three += 1 if new_ugly % 5 == 0: index_five += 1 return ugly_list[-1] 3.14 数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路 如果问题简化为1个数出现在两个集合A,B中，则其并集 - 交集所得结果便是只出现在集合A或只出现在集合B中的元素。 所以不断二分递归下去，直到集合中只有一个元素，然后再对两个集合做这个操作，最终会将出现两次的数据消除掉，只剩下出现一次的数字。 12345678910111213141516171819def solution(array): return list(dc(array, 0, len(array)-1)) def dc(arr, start, end): res = set() if start &gt; end: return res if start == end: return set(arr[start:end+1]) mid = (start + end) / 2 # 不断二分递归 s1 = dc(arr, start, mid) s2 = dc(arr, mid+1, end) # 并集 - 交集 return s1.union(s2).difference(s1.intersection(s2)) 3.15 数组中的重复数字题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路如果数组元素与将该元素作为idx, 在位于该idx的元素是否相等，如果不相等则做一下交换；如果相等，则返回这个元素，说明这是一个重复数字 1234567891011121314151617def duplicate(numbers, duplication): for i in range(len(numbers)): if numbers[i] != i: # 如果元素值不等于其idx temp = numbers[numbers[i]] # 取得numbers[numbers[i] 的元素 # 如果numbers[i]与 numbers[numbers[i]]相等，说明已经重复，则直接返回这个数字 if temp == numbers[i]: duplication[0] = numbers[i] return True # 如果不相等则交换 else: numbers[numbers[i]] = numbers[i] numbers[i] = temp return False 3.16 构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 思路 下三角用连乘可以很容求得，上三角，从下向上也是连乘。 因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。 \\begin{bmatrix} 1, A_1, A_2, ..., A_{n-2}, A_{n-1} \\\\ A_0, 1, A_2, ..., A_{n-2}, A_{n-1} \\\\ A_0, A_2, 1, ..., A_{n-2}, A_{n-1} \\\\ ... \\\\ A_0, A_1, A_2, ..., 1, A_{n-1} \\\\ A_0, A_1, A_2, ..., A_{n-2}, 1 \\\\ \\end{bmatrix}123456789101112131415161718def solution(A): leng = len(A) if leng &lt;= 0: return None B = [1] * leng B[0] = 1 # 计算下三角 for i in range(1, leng): B[i] = B[i-1] * A[i-1] # 计算上三角 temp = 1 for j in range(leng-2, -1, -1): temp *= A[j+1] B[j] *= temp return B 3.17 字符流中第一个不重复的字符题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个符“google”时，第一个只出现一次的字符是”l”。 123456789101112131415161718class Solution(object): def __init__(self): self.s = &quot;&quot; self.dict = {} # 得到第一个只出现一次的字符 def get_first_appear_str(self): for s in self.s: if self.dict[s] == 1: return s return &quot;#&quot; def insert(self, char): self.s += char if char in self.dict: self.dict[char] += 1 else: self.dict[char] = 1 4. 链表4.1 [双指针]链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个结点。 可以用两个指针：p1 和 p2 先让p1跑k-1个节点，然后让p2开始跑；当p1跑到最后一个节点时，p2对应的节点就是倒数第k个节点。 1234567891011121314def solution(head, k): p1 = head p2 = head i = 0 node_count = 0 # 记录一下节点数，如果节点数小于k值，则返回空值 while p1 is not None: p1 = p1.next node_count += 1 if i &gt;= k: p2 = p2.next i += 1 if node_count &lt; k: return None return p2 4.2 反转链表输入一个链表，反转链表后，输出新链表的表头。 123456789101112def solution(pHead): if not pHead or pHead.next is None: return pHead # 先定义last节点是None last = None while pHead: temp = pHead.next # 首先获取到当前节点的下一个节点，存储下来 pHead.next = last # 对于当前的头节点，反转过后其next节点就是None last = pHead # 将当前节点赋值给last pHead = temp # 将下一个节点赋给pHead return last 4.3 两个链表的第一个公共节点输入两个链表，找出它们的第一个公共结点。 当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；(a+b)同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。(b+a)这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。 123456789101112131415161718192021222324252627def solution(pHead1, pHead2): l1 = pHead1 l2 = pHead2 while l1 != l2: l1 = pHead2 if l1.next is None else l1.next l2 = pHead1 if l2.next is None else l2.next return l1def solution2(pHead1, pHead2): &quot;&quot;&quot; 先保存链表1的节点，再遍历链表2，如果在链表1中出现，则返回跳出循环。否则返回None :param pHead1: :param pHead2: :return: &quot;&quot;&quot; l = [] while pHead1: l.append(pHead1) pHead1 = pHead1.next while pHead2: if pHead2 in l: return pHead2 break pHead2 = pHead2.next return None 4.4 合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 12345678910111213def solution(pHead1, pHead2): # 可以挨个合并，递归可以解决这个问题 if pHead1 is None: return pHead2 if pHead2 is None: return pHead1 if pHead1.val &lt;= pHead2.val: pHead1.next = solution(pHead1.next, pHead2) return pHead1 else: pHead2.next = solution(pHead1, pHead2.next) return pHead2 4.5 复杂链表的复制题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 123456789101112131415161718192021222324252627class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = Nonedef iter_node(node): # 迭代返回node的下一个节点 while node: yield node node = node.nextdef clone_list(p_head): mem = dict() for i, n in enumerate(iter_node(p_head)): mem[id(n)] = i lst = [RandomListNode(n.label) for n in iter_node(p_head)] # copy a new list for t, f in zip(iter_node(p_head), lst): # 如果该节点有next节点，则获取到next节点的id，再从mem中根据id找到对应的节点 if t.next: f.next = lst[mem[id(t.next)]] # 如果该节点有random节点，则获取到random节点的id，再从mem中根据id找到对应的节点 if t.random: f.random = lst[mem[id(t.random)]] return lst[0] if lst else None 4.6 二叉搜索树与双向链表题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向 12345678910111213141516171819202122232425262728def node_list(root_of_tree): &quot;&quot;&quot; 得到其中序遍历结果 :param root_of_tree: :return: &quot;&quot;&quot; if not root_of_tree: return [] return node_list(root_of_tree.left) + [root_of_tree] + node_list(root_of_tree)def convert(root_of_tree): res = node_list(root_of_tree) if len(res) == 0: return None if len(res) == 1: return root_of_tree res[0].left = None res[0].right = res[1] res[-1].left = res[-2] res[-1].right = None for i in range(1, len(res)-1): res[i].left = res[i-1] res[i].right = res[i+1] return res[0] 4.7 链表中环的入口节点题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路 有两个： 遍历整个链表，将节点缓存起来，第一个重复的节点就是环的入口(时间、空间复杂度都是O(n)); 第二个方法相对比较复杂： a. 如果将环抽象为如下形式，从链表起点A开始，经过环的入口B，假设从A—&gt;B的距离为x; 12345A -----&gt; B ------&gt; C ^ | | | | | &lt;---------- b. 假设快指针fast一次移动2步，慢指针一次移动1步，当快慢指针在环中的C点相遇时，假设整个环B—&gt;C—&gt;B的距离为c；从环的入口B到环中相遇节点C的距离为a. c. 可以得到如下信息， slow = x + n*c + a（n代表慢指针走过了n次环） fast = x + m*c + a（m代表快指针走过了m次环） 有： 2 * slow = fast ==&gt; x = (m-2n)c - a ==&gt; x = (m-2n-1)c + c - a 什么意思呢，即A—&gt;B的距离 = 数个环的长度(可能为0) + c - a(即相遇点C继续走到B的距离) d. 所以，可以再让一个指针从起点A开始走，让一个指针从相遇点C开始继续往后走，2个指针速度一样，那么两个指针的相遇点一定到达环的入口点。时间复杂度为O(n)， 空间复杂度为O(1)。 1234567891011121314151617181920212223242526272829303132333435def solution1(p_head): temp_list = [] p = p_head while p: if p in temp_list: return p else: temp_list.append(p) p = p.next return Nonedef solution2(p_head): if p_head is None or p_head.next is None or p_head.next.next is None: return None fast = p_head.next.next # 2 steps slow = p_head.next # 1 step # 先判断是否存在环 while fast != slow: if fast.next is not None and fast.next.next is not None: fast = fast.next.next slow = slow.next # 如果没有环则返回None else: return None # 如果存在环 fast = p_head # 一个指针从起点开始，另一个指针还是从相遇点开始 while fast != slow: fast = fast.next slow = slow.next return slow","link":"/2019/08/26/sword-refers-to-offer/"},{"title":"【Spark】特征工程2-Transformers","text":"Spark MLlib中关于特征处理的相关算法，大致分为以下几组： 提取(Extraction)：从“原始”数据中提取特征 转换(Transformation)：缩放，转换或修改特征 选择(Selection)：从较大的一组特征中选择一个子集 局部敏感哈希(Locality Sensitive Hashing，LSH)：这类算法将特征变换的各个方面与其他算法相结合。 本文介绍第二组： 特征转换器(Transformers) 1. 特征转换器1.1 分词器(Tokenizer)标记化(Tokenization)是将文本（例如句子）分解为单个术语（通常是单词）的过程。 一个简单的Tokenizer类提供此功能。 下面的示例显示了如何将句子拆分为单词序列。 RegexTokenizer允许基于正则表达式（正则表达式）匹配的更高级标记化。 默认情况下，参数“pattern”（正则表达式，默认值：“\\\\s +”）用作分隔输入文本的分隔符。 或者，用户可以将参数“gap”设置为false，指示正则表达式“pattern”表示“令牌”而不是分割间隙，并找到所有匹配的出现作为标记化结果。 举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: utf-8 -*-# @Time : 2019/7/31 14:58# @Author : buracagyang# @File : tokenizer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import Tokenizer, RegexTokenizerfrom pyspark.sql.functions import col, udffrom pyspark.sql.types import IntegerTypefrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;TokenizerExample&quot;)\\ .getOrCreate() sentenceDataFrame = spark.createDataFrame([ (0, &quot;Hi I heard about Spark&quot;), (1, &quot;I wish Java could use case classes&quot;), (2, &quot;Logistic,regression,models,are,neat&quot;) ], [&quot;id&quot;, &quot;sentence&quot;]) tokenizer = Tokenizer(inputCol=&quot;sentence&quot;, outputCol=&quot;words&quot;) regexTokenizer = RegexTokenizer(inputCol=&quot;sentence&quot;, outputCol=&quot;words&quot;, pattern=&quot;\\\\W&quot;) # 也可以选择， pattern=&quot;\\\\w+&quot;, gaps(False) countTokens = udf(lambda words: len(words), IntegerType()) tokenized = tokenizer.transform(sentenceDataFrame) tokenized.select(&quot;sentence&quot;, &quot;words&quot;).withColumn(&quot;tokens&quot;, countTokens(col(&quot;words&quot;))).show(truncate=False) regexTokenized = regexTokenizer.transform(sentenceDataFrame) regexTokenized.select(&quot;sentence&quot;, &quot;words&quot;).withColumn(&quot;tokens&quot;, countTokens(col(&quot;words&quot;))).show(truncate=False) spark.stop() 结果如下： 123456789101112131415+-----------------------------------+------------------------------------------+------+|sentence |words |tokens|+-----------------------------------+------------------------------------------+------+|Hi I heard about Spark |[hi, i, heard, about, spark] |5 ||I wish Java could use case classes |[i, wish, java, could, use, case, classes]|7 ||Logistic,regression,models,are,neat|[logistic,regression,models,are,neat] |1 |+-----------------------------------+------------------------------------------+------++-----------------------------------+------------------------------------------+------+|sentence |words |tokens|+-----------------------------------+------------------------------------------+------+|Hi I heard about Spark |[hi, i, heard, about, spark] |5 ||I wish Java could use case classes |[i, wish, java, could, use, case, classes]|7 ||Logistic,regression,models,are,neat|[logistic, regression, models, are, neat] |5 |+-----------------------------------+------------------------------------------+------+ 1.2 StopWordsRemover停用词是应该从输入中排除的词，通常是因为词经常出现而且没有那么多含义。 StopWordsRemover将字符串序列（例如，Tokenizer的输出）作为输入，并从输入序列中删除所有停用词。 停用词列表由stopWords参数指定。 通过调用StopWordsRemover.loadDefaultStopWords（语言）可以访问某些语言的默认停用词，其中可用选项为“danish”，“dutch”，“english”，“finnish”，“french”，“german”，“hungarian”，italian”, “norwegian”, “portuguese”, “russian”, “spanish”, “swedish” and “turkish”。 布尔参数caseSensitive指示匹配项是否区分大小写（默认为false）。 举例 假设我们有以下具有列id和raw的DataFrame： 1234id | raw----|---------- 0 | [I, saw, the, red, baloon] 1 | [Mary, had, a, little, lamb] 经过停用词处理： 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-# @Time : 2019/7/31 17:26# @Author : buracagyang# @File : stopwords_remover_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import StopWordsRemoverfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;StopWordsRemoverExample&quot;)\\ .getOrCreate() sentenceData = spark.createDataFrame([ (0, [&quot;I&quot;, &quot;saw&quot;, &quot;the&quot;, &quot;red&quot;, &quot;balloon&quot;]), (1, [&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]) ], [&quot;id&quot;, &quot;raw&quot;]) remover = StopWordsRemover(inputCol=&quot;raw&quot;, outputCol=&quot;filtered&quot;) remover.transform(sentenceData).show(truncate=False) spark.stop() 结果如下： 123456+---+----------------------------+--------------------+|id |raw |filtered |+---+----------------------------+--------------------+|0 |[I, saw, the, red, balloon] |[saw, red, balloon] ||1 |[Mary, had, a, little, lamb]|[Mary, little, lamb]|+---+----------------------------+--------------------+ 1.3 n-gram对于某些整数n，n-gram是n个tokens（通常是单词）的序列。 NGram类可用于将输入要素转换为n-gram。 NGram将字符串序列（例如，Tokenizer的输出）作为输入。 参数n用于确定每个n-gram中的项数。 输出将由一系列n-gram组成，其中每个n-gram由n个连续单词的空格分隔的字符串表示。 如果输入序列包含少于n个字符串，则不会生成输出。 举例 12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-# @Time : 2019/7/31 17:32# @Author : buracagyang# @File : n_gram_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import NGramfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;NGramExample&quot;)\\ .getOrCreate() wordDataFrame = spark.createDataFrame([ (0, [&quot;Hi&quot;, &quot;I&quot;, &quot;heard&quot;, &quot;about&quot;, &quot;Spark&quot;]), (1, [&quot;I&quot;, &quot;wish&quot;, &quot;Java&quot;, &quot;could&quot;, &quot;use&quot;, &quot;case&quot;, &quot;classes&quot;]), (2, [&quot;Logistic&quot;, &quot;regression&quot;, &quot;models&quot;, &quot;are&quot;, &quot;neat&quot;]) ], [&quot;id&quot;, &quot;words&quot;]) ngram = NGram(n=2, inputCol=&quot;words&quot;, outputCol=&quot;ngrams&quot;) ngramDataFrame = ngram.transform(wordDataFrame) ngramDataFrame.select(&quot;ngrams&quot;).show(truncate=False) spark.stop() 结果如下： 1234567+------------------------------------------------------------------+|ngrams |+------------------------------------------------------------------+|[Hi I, I heard, heard about, about Spark] ||[I wish, wish Java, Java could, could use, use case, case classes]||[Logistic regression, regression models, models are, are neat] |+------------------------------------------------------------------+ 1.4 二元化(Binarizer)二元化是将数值特征阈值化为二元（0/1）特征的过程。 Binarizer采用公共参数inputCol和outputCol，以及二元化的阈值。 大于阈值的特征值被二进制化为1.0; 小于等于阈值的值被二值化为0.0。 inputCol支持Vector和Double类型。 举例 123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-# @Time : 2019/7/31 17:36# @Author : buracagyang# @File : binarizer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.sql import SparkSessionfrom pyspark.ml.feature import Binarizerif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;BinarizerExample&quot;)\\ .getOrCreate() continuousDataFrame = spark.createDataFrame([ (0, 0.1), (1, 0.8), (2, 0.2) ], [&quot;id&quot;, &quot;feature&quot;]) binarizer = Binarizer(threshold=0.5, inputCol=&quot;feature&quot;, outputCol=&quot;binarized_feature&quot;) binarizedDataFrame = binarizer.transform(continuousDataFrame) print(&quot;Binarizer output with Threshold = %f&quot; % binarizer.getThreshold()) binarizedDataFrame.show() spark.stop() 结果如下： 12345678Binarizer output with Threshold = 0.500000+---+-------+-----------------+| id|feature|binarized_feature|+---+-------+-----------------+| 0| 0.1| 0.0|| 1| 0.8| 1.0|| 2| 0.2| 0.0|+---+-------+-----------------+ 1.5 主成分分析(PCA)PCA是一种统计过程，它使用正交变换将可能相关变量的一组观察值转换为称为主成分的线性不相关变量的一组值。 PCA类使用PCA训练模型以将向量映射到低维空间。 下面的示例显示了如何将5维特征向量映射到3维主成分中。 举例 1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-# @Time : 2019/7/31 17:39# @Author : buracagyang# @File : pca_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import PCAfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;PCAExample&quot;)\\ .getOrCreate() data = [(Vectors.sparse(5, [(1, 1.0), (3, 7.0)]),), (Vectors.dense([2.0, 0.0, 3.0, 4.0, 5.0]),), (Vectors.dense([4.0, 0.0, 0.0, 6.0, 7.0]),)] df = spark.createDataFrame(data, [&quot;features&quot;]) pca = PCA(k=3, inputCol=&quot;features&quot;, outputCol=&quot;pcaFeatures&quot;) model = pca.fit(df) result = model.transform(df).select(&quot;pcaFeatures&quot;) result.show(truncate=False) spark.stop() 结果如下： 1234567+-----------------------------------------------------------+|pcaFeatures |+-----------------------------------------------------------+|[1.6485728230883807,-4.013282700516296,-5.524543751369388] ||[-4.645104331781534,-1.1167972663619026,-5.524543751369387]||[-6.428880535676489,-5.337951427775355,-5.524543751369389] |+-----------------------------------------------------------+ 1.6 多项式扩展(PolynomialExpansion)多项式展开是将要素扩展为多项式空间的过程，该多项式空间由原始维度的n度组合制定。 PolynomialExpansion类提供此功能。 以下示例显示如何将特征扩展为3度多项式空间。 举例 123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-# @Time : 2019/7/31 17:44# @Author : buracagyang# @File : polynomial_expansion_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import PolynomialExpansionfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;PolynomialExpansionExample&quot;)\\ .getOrCreate() df = spark.createDataFrame([ (Vectors.dense([2.0, 1.0]),), (Vectors.dense([0.0, 0.0]),), (Vectors.dense([3.0, -1.0]),) ], [&quot;features&quot;]) polyExpansion = PolynomialExpansion(degree=3, inputCol=&quot;features&quot;, outputCol=&quot;polyFeatures&quot;) polyDF = polyExpansion.transform(df) polyDF.show(truncate=False) spark.stop() 结果如下： 1234567+----------+------------------------------------------+|features |polyFeatures |+----------+------------------------------------------+|[2.0,1.0] |[2.0,4.0,8.0,1.0,2.0,4.0,1.0,2.0,1.0] ||[0.0,0.0] |[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0] ||[3.0,-1.0]|[3.0,9.0,27.0,-1.0,-3.0,-9.0,1.0,3.0,-1.0]|+----------+------------------------------------------+ 简单解释一下： 原始特征: $x_1$, $x_2$ 二阶多项式的展开部分：$x_1^2$, $x_1x_2$, $x_2^2$ 三阶多项式的展开部分：$x_1^2x_2$, $x_1x_2^2$, $x_1^3$, $x_2^3$ 所以得到, 二阶多项式扩展为： 原始特征 + 二阶多项式的展开部分 三阶多项式扩展为： 原始特征 + 二阶多项式的展开部分 + 三阶多项式的展开部分 1.7 离散余弦距离(Discrete Cosine Transform, DCT)离散余弦变换将时域中的长度N实值序列变换为频域中的另一长度N实值序列。 DCT类提供此功能，实现DCT-II并将结果缩放$\\frac{1}{\\sqrt{2}}$，使得变换的表示矩阵是单一的。应用于变换序列没有移位（例如，变换序列的第0个元素是第0个DCT系数而不是N / 2个）。 举例 1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-# @Time : 2019/7/31 17:59# @Author : buracagyang# @File : dct_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import DCTfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;DCTExample&quot;)\\ .getOrCreate() df = spark.createDataFrame([ (Vectors.dense([0.0, 1.0, -2.0, 3.0]),), (Vectors.dense([-1.0, 2.0, 4.0, -7.0]),), (Vectors.dense([14.0, -2.0, -5.0, 1.0]),)], [&quot;features&quot;]) dct = DCT(inverse=False, inputCol=&quot;features&quot;, outputCol=&quot;featuresDCT&quot;) dctDf = dct.transform(df) dctDf.select(&quot;featuresDCT&quot;).show(truncate=False) spark.stop() 结果如下： 1234567+----------------------------------------------------------------+|featuresDCT |+----------------------------------------------------------------+|[1.0,-1.1480502970952693,2.0000000000000004,-2.7716385975338604]||[-1.0,3.378492794482933,-7.000000000000001,2.9301512653149677] ||[4.0,9.304453421915744,11.000000000000002,1.5579302036357163] |+----------------------------------------------------------------+ 1.8 字符串索引器(StringIndexer)StringIndexer将标签的字符串列编码为标签索引列。 索引在[0，numLabels)中，按标签频率排序，因此最常见的标签得到索引0。如果用户选择保留它们，则看不见的标签将被放在索引numLabels处。 如果输入列是数字，我们将其转换为字符串并索引字符串值。 当下游管道组件（如Estimator或Transformer）使用此字符串索引标签时，必须将组件的输入列设置为此字符串索引列名称。 在许多情况下，您可以使用setInputCol设置输入列。 举例 假设我们有以下DataFrame，列id和类别： 12345678id | category----|---------- 0 | a 1 | b 2 | c 3 | a 4 | a 5 | c category是一个包含三个标签的字符串列：“a”，“b”和“c”。 使用StringIndexer作为输入列，categoryIndex作为输出列，我们应该得到以下结果： 12345678 id | category | categoryIndex----|----------|--------------- 0 | a | 0.0 1 | b | 2.0 2 | c | 1.0 3 | a | 0.0 4 | a | 0.0 5 | c | 1.0 “a”得到索引0，因为它是最常见的，其次是索引1的“c”和索引2的“b”。 此外，当您在一个数据集上使用StringIndexer然后使用它来转换另一个数据集时，有三种策略可以解决StringIndexer如何处理看不见的标签： 抛出异常（这是默认值） 完全跳过包含看不见的标签的行, “skip” 将看不见的标签放在索引numLabels的特殊附加存储桶中, “keep” 举例 让我们回到之前的示例，但这次重用我们之前在以下数据集上定义的StringIndexer： 1234567 id | category----|---------- 0 | a 1 | b 2 | c 3 | d 4 | e 如果您没有设置StringIndexer如何处理看不见的标签或将其设置为“error”，则会抛出异常。 但是，如果您调用了setHandleInvalid（“skip”），则将生成以下数据集： 12345 id | category | categoryIndex----|----------|--------------- 0 | a | 0.0 1 | b | 2.0 2 | c | 1.0 请注意，不显示包含“d”或“e”的行。如果调用setHandleInvalid（“keep”），将生成以下数据集： 1234567 id | category | categoryIndex----|----------|--------------- 0 | a | 0.0 1 | b | 2.0 2 | c | 1.0 3 | d | 3.0 4 | e | 3.0 示例代码如下： 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-# @Time : 2019/7/31 18:11# @Author : buracagyang# @File : string_indexer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import StringIndexerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;StringIndexerExample&quot;)\\ .getOrCreate() df = spark.createDataFrame( [(0, &quot;a&quot;), (1, &quot;b&quot;), (2, &quot;c&quot;), (3, &quot;a&quot;), (4, &quot;a&quot;), (5, &quot;c&quot;)], [&quot;id&quot;, &quot;category&quot;]) indexer = StringIndexer(inputCol=&quot;category&quot;, outputCol=&quot;categoryIndex&quot;) indexed = indexer.fit(df).transform(df) indexed.show() spark.stop() 1.9 IndexToString与StringIndexer相反，IndexToString将一列标签索引映射回包含原始标签作为字符串的列。 一个常见的用例是使用StringIndexer从标签生成索引，使用这些索引训练模型，并使用IndexToString从预测索引列中检索原始标签。 但是，您可以自由提供自己的标签。 举例 将categoryIndex作为输入列应用IndexToString，将originalCategory作为输出列，我们可以检索原始标签（它们将从列的元数据中推断出来）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-# @Time : 2019/7/31 18:59# @Author : buracagyang# @File : index_to_string_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import IndexToString, StringIndexerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;IndexToStringExample&quot;)\\ .getOrCreate() df = spark.createDataFrame( [(0, &quot;a&quot;), (1, &quot;b&quot;), (2, &quot;c&quot;), (3, &quot;a&quot;), (4, &quot;a&quot;), (5, &quot;c&quot;)], [&quot;id&quot;, &quot;category&quot;]) indexer = StringIndexer(inputCol=&quot;category&quot;, outputCol=&quot;categoryIndex&quot;) model = indexer.fit(df) indexed = model.transform(df) print(&quot;Transformed string column '%s' to indexed column '%s'&quot; % (indexer.getInputCol(), indexer.getOutputCol())) indexed.show() print(&quot;StringIndexer will store labels in output column metadata\\n&quot;) converter = IndexToString(inputCol=&quot;categoryIndex&quot;, outputCol=&quot;originalCategory&quot;) converted = converter.transform(indexed) print(&quot;Transformed indexed column '%s' back to original string column '%s' using &quot; &quot;labels in metadata&quot; % (converter.getInputCol(), converter.getOutputCol())) converted.select(&quot;id&quot;, &quot;categoryIndex&quot;, &quot;originalCategory&quot;).show() spark.stop() 结果如下： 12345678910111213141516171819202122232425Transformed string column 'category' to indexed column 'categoryIndex'+---+--------+-------------+| id|category|categoryIndex|+---+--------+-------------+| 0| a| 0.0|| 1| b| 2.0|| 2| c| 1.0|| 3| a| 0.0|| 4| a| 0.0|| 5| c| 1.0|+---+--------+-------------+StringIndexer will store labels in output column metadataTransformed indexed column 'categoryIndex' back to original string column 'originalCategory' using labels in metadata+---+-------------+----------------+| id|categoryIndex|originalCategory|+---+-------------+----------------+| 0| 0.0| a|| 1| 2.0| b|| 2| 1.0| c|| 3| 0.0| a|| 4| 0.0| a|| 5| 1.0| c|+---+-------------+----------------+ 1.10 One-Hot(OneHotEncoderEstimator)One-hot编码将表示为标签索引的分类特征映射到二进制向量，该二进制向量具有至多单个一个值，该值表示所有特征值集合中存在特定特征值。 此编码允许期望连续特征（例如Logistic回归）的算法使用分类特征。 对于字符串类型输入数据，通常首先使用StringIndexer对分类特征进行编码。 OneHotEncoderEstimator可以转换多个列，为每个输入列返回一个热编码的输出向量列。 通常使用VectorAssembler将这些向量合并为单个特征向量。 OneHotEncoderEstimator支持handleInvalid参数，以选择在转换数据期间如何处理无效输入。 可用选项包括’keep’（任何无效输入分配给额外的分类索引）和’error’（抛出错误）。 举例 12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-# @Time : 2019/7/31 19:05# @Author : buracagyang# @File : onehot_encoder_estimator_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import OneHotEncoderEstimatorfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;OneHotEncoderEstimatorExample&quot;)\\ .getOrCreate() # 分类特征通常先用StringIndexer先进行编码 df = spark.createDataFrame([ (0.0, 1.0), (1.0, 0.0), (2.0, 1.0), (0.0, 2.0), (0.0, 1.0), (2.0, 0.0) ], [&quot;categoryIndex1&quot;, &quot;categoryIndex2&quot;]) encoder = OneHotEncoderEstimator(inputCols=[&quot;categoryIndex1&quot;, &quot;categoryIndex2&quot;], outputCols=[&quot;categoryVec1&quot;, &quot;categoryVec2&quot;]) model = encoder.fit(df) encoded = model.transform(df) encoded.show() spark.stop() 结果如下： 12345678910+--------------+--------------+-------------+-------------+|categoryIndex1|categoryIndex2| categoryVec1| categoryVec2|+--------------+--------------+-------------+-------------+| 0.0| 1.0|(2,[0],[1.0])|(2,[1],[1.0])|| 1.0| 0.0|(2,[1],[1.0])|(2,[0],[1.0])|| 2.0| 1.0| (2,[],[])|(2,[1],[1.0])|| 0.0| 2.0|(2,[0],[1.0])| (2,[],[])|| 0.0| 1.0|(2,[0],[1.0])|(2,[1],[1.0])|| 2.0| 0.0| (2,[],[])|(2,[0],[1.0])|+--------------+--------------+-------------+-------------+ 1.11 矢量索引器(VectorIndexer)VectorIndexer帮助索引Vectors的数据集中的分类特征。它既可以自动决定哪些特征是分类的，也可以将原始值转换为类别索引。具体来说，它执行以下操作： 获取Vector类型的输入列和参数maxCategories。 根据不同值的数量确定哪些要素应该是分类的，其中最多maxCategories的要素被声明为分类。为每个分类特征计算基于0的类别索引。 索引分类要素并将原始要素值转换为索引。 索引分类特征允许决策树和树集合等算法适当地处理分类特征，从而提高性能。 举例 在下面的示例中，我们读入标记点的数据集，然后使用VectorIndexer确定哪些要素应被视为分类。我们将分类特征值转换为它们的索引。然后，可以将转换后的数据传递给处理分类特征的DecisionTreeRegressor等算法。 123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-# @Time : 2019/7/31 19:11# @Author : buracagyang# @File : vector_indexer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import VectorIndexerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;VectorIndexerExample&quot;)\\ .getOrCreate() data = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) indexer = VectorIndexer(inputCol=&quot;features&quot;, outputCol=&quot;indexed&quot;, maxCategories=10) indexerModel = indexer.fit(data) categoricalFeatures = indexerModel.categoryMaps print(&quot;Chose %d categorical features: %s&quot; % (len(categoricalFeatures), &quot;, &quot;.join(str(k) for k in categoricalFeatures.keys()))) indexedData = indexerModel.transform(data) indexedData.show() spark.stop() 结果如下： 1234567891011121314151617181920212223242526...+-----+--------------------+--------------------+|label| features| indexed|+-----+--------------------+--------------------+| 0.0|(692,[127,128,129...|(692,[127,128,129...|| 1.0|(692,[158,159,160...|(692,[158,159,160...|| 1.0|(692,[124,125,126...|(692,[124,125,126...|| 1.0|(692,[152,153,154...|(692,[152,153,154...|| 1.0|(692,[151,152,153...|(692,[151,152,153...|| 0.0|(692,[129,130,131...|(692,[129,130,131...|| 1.0|(692,[158,159,160...|(692,[158,159,160...|| 1.0|(692,[99,100,101,...|(692,[99,100,101,...|| 0.0|(692,[154,155,156...|(692,[154,155,156...|| 0.0|(692,[127,128,129...|(692,[127,128,129...|| 1.0|(692,[154,155,156...|(692,[154,155,156...|| 0.0|(692,[153,154,155...|(692,[153,154,155...|| 0.0|(692,[151,152,153...|(692,[151,152,153...|| 1.0|(692,[129,130,131...|(692,[129,130,131...|| 0.0|(692,[154,155,156...|(692,[154,155,156...|| 1.0|(692,[150,151,152...|(692,[150,151,152...|| 0.0|(692,[124,125,126...|(692,[124,125,126...|| 0.0|(692,[152,153,154...|(692,[152,153,154...|| 1.0|(692,[97,98,99,12...|(692,[97,98,99,12...|| 1.0|(692,[124,125,126...|(692,[124,125,126...|+-----+--------------------+--------------------+only showing top 20 rows 1.12 交互作用(Interaction)Interaction是一个Transformer，它接收向量或双值列，并生成一个向量列，其中包含每个输入列中一个值的所有组合的乘积。 例如，如果您有2个矢量类型列，每个列都有3个维度作为输入列，那么您将获得9维向量作为输出列。 举例 假设我们有以下DataFrame，其列为“id1”，“vec1”和“vec2”： 12345678id1|vec1 |vec2 ---|--------------|--------------1 |[1.0,2.0,3.0] |[8.0,4.0,5.0] 2 |[4.0,3.0,8.0] |[7.0,9.0,8.0] 3 |[6.0,1.0,9.0] |[2.0,3.0,6.0] 4 |[10.0,8.0,6.0]|[9.0,4.0,5.0] 5 |[9.0,2.0,7.0] |[10.0,7.0,3.0]6 |[1.0,1.0,4.0] |[2.0,8.0,4.0] 将交互应用于这些输入列，然后将interactedCol作为输出列包含: 12345678id1|vec1 |vec2 |interactedCol ---|--------------|--------------|------------------------------------------------------1 |[1.0,2.0,3.0] |[8.0,4.0,5.0] |[8.0,4.0,5.0,16.0,8.0,10.0,24.0,12.0,15.0] 2 |[4.0,3.0,8.0] |[7.0,9.0,8.0] |[56.0,72.0,64.0,42.0,54.0,48.0,112.0,144.0,128.0] 3 |[6.0,1.0,9.0] |[2.0,3.0,6.0] |[36.0,54.0,108.0,6.0,9.0,18.0,54.0,81.0,162.0] 4 |[10.0,8.0,6.0]|[9.0,4.0,5.0] |[360.0,160.0,200.0,288.0,128.0,160.0,216.0,96.0,120.0]5 |[9.0,2.0,7.0] |[10.0,7.0,3.0]|[450.0,315.0,135.0,100.0,70.0,30.0,350.0,245.0,105.0] 6 |[1.0,1.0,4.0] |[2.0,8.0,4.0] |[12.0,48.0,24.0,12.0,48.0,24.0,48.0,192.0,96.0] 示例脚本(Java/Scala)请参照这里。 1.13 标准化(Normalizer)Normalizer是一个Transformer，它转换Vector行的数据集，将每个Vector规范化为具有单位范数。 它需要参数p，它指定用于归一化的p范数。（默认情况下p = 2）此标准化有助于标准化输入数据并改善学习算法的行为。 举例 以下示例演示如何以libsvm格式加载数据集，然后将每行标准化为具有单位$\\ell^1$范数和单位$\\ell^{\\infty}$范数。 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-# @Time : 2019/7/31 19:51# @Author : buracagyang# @File : normalizer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import Normalizerfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;NormalizerExample&quot;)\\ .getOrCreate() dataFrame = spark.createDataFrame([ (0, Vectors.dense([1.0, 0.5, -1.0]),), (1, Vectors.dense([2.0, 1.0, 1.0]),), (2, Vectors.dense([4.0, 10.0, 2.0]),) ], [&quot;id&quot;, &quot;features&quot;]) # L1 normalizer = Normalizer(inputCol=&quot;features&quot;, outputCol=&quot;normFeatures&quot;, p=1.0) l1NormData = normalizer.transform(dataFrame) print(&quot;Normalized using L^1 norm&quot;) l1NormData.show() # L^{\\infty} lInfNormData = normalizer.transform(dataFrame, {normalizer.p: float(&quot;inf&quot;)}) print(&quot;Normalized using L^inf norm&quot;) lInfNormData.show() spark.stop() 结果如下： 1234567891011121314151617Normalized using L^1 norm+---+--------------+------------------+| id| features| normFeatures|+---+--------------+------------------+| 0|[1.0,0.5,-1.0]| [0.4,0.2,-0.4]|| 1| [2.0,1.0,1.0]| [0.5,0.25,0.25]|| 2|[4.0,10.0,2.0]|[0.25,0.625,0.125]|+---+--------------+------------------+Normalized using L^inf norm+---+--------------+--------------+| id| features| normFeatures|+---+--------------+--------------+| 0|[1.0,0.5,-1.0]|[1.0,0.5,-1.0]|| 1| [2.0,1.0,1.0]| [1.0,0.5,0.5]|| 2|[4.0,10.0,2.0]| [0.4,1.0,0.2]|+---+--------------+--------------+ 1.14 特征缩放(StandardScaler)StandardScaler将每个特征标准化为具有单位标准差和/或零均值。 它需要参数： withStd：默认为True。 将数据缩放到单位标准偏差。 withMean：默认为False。 在缩放之前使用均值将数据居中。 它将构建密集输出，因此在应用稀疏输入时要小心。 StandardScaler是一个Estimator，可以放在数据集上以生成StandardScalerModel; 这等于计算摘要统计。 然后，模型可以将数据集中的“矢量”列(特征)转换为具有单位标准差和/或零均值特征。 请注意，如果要素的标准差为零，则它将在该要素的Vector中返回默认的0.0值。 举例 以下示例演示如何以libsvm格式加载数据集，然后将每个要素标准化以具有单位标准偏差。 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-# @Time : 2019/7/31 20:01# @Author : buracagyang# @File : standard_scaler_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import StandardScalerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;StandardScalerExample&quot;)\\ .getOrCreate() dataFrame = spark.read.format(&quot;libsvm&quot;).load(&quot;../data/mllib/sample_libsvm_data.txt&quot;) # scaler is a Estimator scaler = StandardScaler(inputCol=&quot;features&quot;, outputCol=&quot;scaledFeatures&quot;, withStd=True, withMean=False) scalerModel = scaler.fit(dataFrame) # Transformer scaledData = scalerModel.transform(dataFrame) scaledData.show() spark.stop() 结果如下： 12345678910111213141516171819202122232425+-----+--------------------+--------------------+|label| features| scaledFeatures|+-----+--------------------+--------------------+| 0.0|(692,[127,128,129...|(692,[127,128,129...|| 1.0|(692,[158,159,160...|(692,[158,159,160...|| 1.0|(692,[124,125,126...|(692,[124,125,126...|| 1.0|(692,[152,153,154...|(692,[152,153,154...|| 1.0|(692,[151,152,153...|(692,[151,152,153...|| 0.0|(692,[129,130,131...|(692,[129,130,131...|| 1.0|(692,[158,159,160...|(692,[158,159,160...|| 1.0|(692,[99,100,101,...|(692,[99,100,101,...|| 0.0|(692,[154,155,156...|(692,[154,155,156...|| 0.0|(692,[127,128,129...|(692,[127,128,129...|| 1.0|(692,[154,155,156...|(692,[154,155,156...|| 0.0|(692,[153,154,155...|(692,[153,154,155...|| 0.0|(692,[151,152,153...|(692,[151,152,153...|| 1.0|(692,[129,130,131...|(692,[129,130,131...|| 0.0|(692,[154,155,156...|(692,[154,155,156...|| 1.0|(692,[150,151,152...|(692,[150,151,152...|| 0.0|(692,[124,125,126...|(692,[124,125,126...|| 0.0|(692,[152,153,154...|(692,[152,153,154...|| 1.0|(692,[97,98,99,12...|(692,[97,98,99,12...|| 1.0|(692,[124,125,126...|(692,[124,125,126...|+-----+--------------------+--------------------+only showing top 20 rows 1.15 MinMaxScalerMinMaxScaler将每个要素重新缩放到特定范围（通常为[0,1]）。 它需要参数： min：默认为0.0。 转换后的下限，由所有功能共享。 max：默认为1.0。 转换后的上限，由所有功能共享。 MinMaxScaler计算数据集的摘要统计信息并生成MinMaxScalerModel。 然后，模型可以单独转换每个特征，使其处于给定范围内。 特征E的重新缩放值计算为， Rescaled(e_i) = \\frac{e_i - E_{min}}{E_{max} - E_{min}} * (max-min) + min对于$E_{max} = E_{min}$的情况，$Rescaled(e_i) = 0.5 *(max+min)$的情况 请注意，由于零值可能会转换为非零值，因此即使对于稀疏输入，变压器的输出也将是DenseVector。 举例 12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-# @Time : 2019/7/31 20:08# @Author : 01373821 (mingchengyang@sf-express.com)# @File : min_max_scaler_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import MinMaxScalerfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;MinMaxScalerExample&quot;)\\ .getOrCreate() # 每一行是一个样本，每一列是一个特征 dataFrame = spark.createDataFrame([ (0, Vectors.dense([1.0, 0.1, -1.0]),), (1, Vectors.dense([2.0, 1.1, 1.0]),), (2, Vectors.dense([3.0, 10.1, 3.0]),) ], [&quot;id&quot;, &quot;features&quot;]) scaler = MinMaxScaler(inputCol=&quot;features&quot;, outputCol=&quot;scaledFeatures&quot;) scalerModel = scaler.fit(dataFrame) scaledData = scalerModel.transform(dataFrame) print(&quot;Features scaled to range: [%f, %f]&quot; % (scaler.getMin(), scaler.getMax())) scaledData.select(&quot;features&quot;, &quot;scaledFeatures&quot;).show() spark.stop() 结果如下： 12345678Features scaled to range: [0.000000, 1.000000]+--------------+--------------+| features|scaledFeatures|+--------------+--------------+|[1.0,0.1,-1.0]| [0.0,0.0,0.0]|| [2.0,1.1,1.0]| [0.5,0.1,0.5]||[3.0,10.1,3.0]| [1.0,1.0,1.0]|+--------------+--------------+ 1.16 MaxAbsScalerMaxAbsScaler通过除以每个特征中的最大绝对值，将每个要素重新缩放到范围[-1,1]。 它不会移动/居中数据，因此不会破坏任何稀疏性。 MaxAbsScaler计算数据集的摘要统计信息并生成MaxAbsScalerModel。 然后，模型可以将每个特征单独转换为范围[-1,1]。 举例 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-# @Time : 2019/7/31 20:44# @Author : buracagyang# @File : max_abs_scaler_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import MaxAbsScalerfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;MaxAbsScalerExample&quot;)\\ .getOrCreate() dataFrame = spark.createDataFrame([ (0, Vectors.dense([1.0, 0.1, -8.0]),), (1, Vectors.dense([2.0, 1.0, -4.0]),), (2, Vectors.dense([4.0, 10.0, 8.0]),) ], [&quot;id&quot;, &quot;features&quot;]) scaler = MaxAbsScaler(inputCol=&quot;features&quot;, outputCol=&quot;scaledFeatures&quot;) scalerModel = scaler.fit(dataFrame) scaledData = scalerModel.transform(dataFrame) scaledData.select(&quot;features&quot;, &quot;scaledFeatures&quot;).show() spark.stop() 结果如下: 1234567+--------------+----------------+| features| scaledFeatures|+--------------+----------------+|[1.0,0.1,-8.0]|[0.25,0.01,-1.0]||[2.0,1.0,-4.0]| [0.5,0.1,-0.5]||[4.0,10.0,8.0]| [1.0,1.0,1.0]|+--------------+----------------+ 1.17 BucketizerBucketizer将一列连续特征转换为一列特征桶，其中桶由用户指定。它需要一个参数： splits：用于将连续要素映射到存储桶的参数。对于n + 1个分裂，有n个桶。由分割[x，y)定义的桶保存除最后一个桶之外的[x，y]范围内的值，最后一个桶也包括y。拆分应该严格增加。必须明确提供-inf，inf处的值以涵盖所有Double值;否则，指定的拆分之外的值将被视为错误。分裂的两个例子是Array（Double.NegativeInfinity，0.0, 1.0，Double.PositiveInfinity）和Array（0.0, 1.0, 2.0）。 请注意，如果您不知道目标列的上限和下限，则应添加Double.NegativeInfinity和Double.PositiveInfinity作为拆分的边界，以防止可能超出Bucketizer边界异常。 另请注意，您提供的分割必须严格按顺序递增，即s0 &lt;s1 &lt;s2 &lt;… &lt;sn。 举例 1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-# @Time : 2019/7/31 20:49# @Author : buracagyang# @File : bucketizer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.sql import SparkSessionfrom pyspark.ml.feature import Bucketizerif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;BucketizerExample&quot;)\\ .getOrCreate() splits = [-float(&quot;inf&quot;), -0.5, 0.0, 0.5, float(&quot;inf&quot;)] data = [(-999.9,), (-0.5,), (-0.3,), (0.0,), (0.2,), (999.9,)] dataFrame = spark.createDataFrame(data, [&quot;features&quot;]) bucketizer = Bucketizer(splits=splits, inputCol=&quot;features&quot;, outputCol=&quot;bucketedFeatures&quot;) bucketedData = bucketizer.transform(dataFrame) print(&quot;Bucketizer output with %d buckets&quot; % (len(bucketizer.getSplits())-1)) bucketedData.show() spark.stop() 结果如下： 1234567891011Bucketizer output with 4 buckets+--------+----------------+|features|bucketedFeatures|+--------+----------------+| -999.9| 0.0|| -0.5| 1.0|| -0.3| 1.0|| 0.0| 2.0|| 0.2| 2.0|| 999.9| 3.0|+--------+----------------+ 1.18 向量内积(ElementwiseProduct)ElementwiseProduct使用基于元素的乘法将每个输入向量乘以提供的“权重”向量。 换句话说，它通过标量乘数来缩放数据集的每一列。 这表示输入矢量v和变换矢量w之间的Hadamard乘积，以产生结果矢量。 \\begin{pmatrix} v_1 \\\\ \\vdots \\\\ v_N \\end{pmatrix} \\circ \\begin{pmatrix} w_1 \\\\ \\vdots \\\\ w_N \\end{pmatrix} = \\begin{pmatrix} v_1 w_1 \\\\ \\vdots \\\\ v_N w_N \\end{pmatrix}举例 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-# @Time : 2019/8/1 15:30# @Author : buracagyang# @File : elementwise_product_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import ElementwiseProductfrom pyspark.ml.linalg import Vectorsfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;ElementwiseProductExample&quot;)\\ .getOrCreate() data = [(Vectors.dense([1.0, 2.0, 3.0]),), (Vectors.dense([4.0, 5.0, 6.0]),)] df = spark.createDataFrame(data, [&quot;vector&quot;]) transformer = ElementwiseProduct(scalingVec=Vectors.dense([0.0, 1.0, 2.0]), inputCol=&quot;vector&quot;, outputCol=&quot;transformedVector&quot;) transformer.transform(df).show() spark.stop() 结果如下: 123456+-------------+-----------------+| vector|transformedVector|+-------------+-----------------+|[1.0,2.0,3.0]| [0.0,2.0,6.0]||[4.0,5.0,6.0]| [0.0,5.0,12.0]|+-------------+-----------------+ 1.19 SQLTransformerSQLTransformer实现由SQL语句定义的转换。 目前我们只支持SQL语法，如“SELECT … FROM THIS …”，其中“THIS”表示输入数据集的基础表。 select子句指定要在输出中显示的字段，常量和表达式，并且可以是Spark SQL支持的任何select子句。 用户还可以使用Spark SQL内置函数和UDF对这些选定列进行操作。 例如，SQLTransformer支持如下语句： SELECT a，a + b AS a_b FROM THIS SELECT a，SQRT（b）AS b_sqrt FROM THIS WHERE a &gt; 5 SELECT a，b，SUM（c）AS c_sum FROM THIS GROUP BY a，b 举例 假设我们有以下具有列id，v1和v2的DataFrame： 1234 id | v1 | v2----|-----|----- 0 | 1.0 | 3.0 2 | 2.0 | 5.0 这是SQLTransformer的输出，其语句为“SELECT ，（v1 + v2）AS v3，（v1 v2）AS v4 FROM THIS”： 123456+---+---+---+---+----+| id| v1| v2| v3| v4|+---+---+---+---+----+| 0|1.0|3.0|4.0| 3.0|| 2|2.0|5.0|7.0|10.0|+---+---+---+---+----+ 示例代码如下： 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-# @Time : 2019/8/1 15:35# @Author : buracagyang# @File : sql_transformer.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import SQLTransformerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;SQLTransformerExample&quot;)\\ .getOrCreate() df = spark.createDataFrame([ (0, 1.0, 3.0), (2, 2.0, 5.0) ], [&quot;id&quot;, &quot;v1&quot;, &quot;v2&quot;]) sqlTrans = SQLTransformer( statement=&quot;SELECT *, (v1 + v2) AS v3, (v1 * v2) AS v4 FROM __THIS__&quot;) sqlTrans.transform(df).show() spark.stop() 1.20 矢量汇编(VectorAssembler)VectorAssembler是一个Transformer，它将给定的字段列表组合到一个向量列中。 将原始特征和由不同特征变换器生成的特征组合成单个特征向量非常有用，以便训练ML模型，如逻辑回归和决策树。 VectorAssembler接受以下输入列类型：所有数字类型，布尔类型和矢量类型。 在每一行中，输入列的值将按指定的顺序连接到一个向量中。 举例 假设我们有一个带有id，hour，mobile，userFeatures和clicked列的DataFrame： 123 id | hour | mobile | userFeatures | clicked----|------|--------|------------------|--------- 0 | 18 | 1.0 | [0.0, 10.0, 0.5] | 1.0 userFeatures是一个包含三个用户特征的矢量列。 我们希望将hour，mobile和userFeatures组合成一个单个的特征向量，并使用它来预测被点击与否。 如果我们将VectorAssembler的输入列设置为hour，mobile和userFeatures，并将输出列设置为features，转换后我们应该得到以下DataFrame： 12345+-----------------------+-------+|features |clicked|+-----------------------+-------+|[18.0,1.0,0.0,10.0,0.5]|1.0 |+-----------------------+-------+ 示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-# @Time : 2019/8/1 15:40# @Author : buracagyang# @File : vector_assembler_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.linalg import Vectorsfrom pyspark.ml.feature import VectorAssemblerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;VectorAssemblerExample&quot;)\\ .getOrCreate() dataset = spark.createDataFrame( [(0, 18, 1.0, Vectors.dense([0.0, 10.0, 0.5]), 1.0)], [&quot;id&quot;, &quot;hour&quot;, &quot;mobile&quot;, &quot;userFeatures&quot;, &quot;clicked&quot;]) assembler = VectorAssembler( inputCols=[&quot;hour&quot;, &quot;mobile&quot;, &quot;userFeatures&quot;], outputCol=&quot;features&quot;) output = assembler.transform(dataset) print(&quot;Assembled columns 'hour', 'mobile', 'userFeatures' to vector column 'features'&quot;) output.select(&quot;features&quot;, &quot;clicked&quot;).show(truncate=False) spark.stop() 1.21 矢量大小提示(VectorSizeHint)有时可以明确指定VectorType列的向量大小。例如，VectorAssembler使用其输入列中的大小信息来为其输出列生成大小信息和元数据。虽然在某些情况下可以通过检查列的内容来获得此信息，但是在流数据中，在流启动之前内容不可用。 VectorSizeHint允许用户显式指定列的向量大小，以便VectorAssembler或可能需要知道向量大小的其他变换器可以将该列用作输入。 要使用VectorSizeHint，用户必须设置inputCol和size参数。将此转换器应用于dataframe会生成一个新的dataframe，其中包含inputCol的更新元数据，用于指定矢量大小。结果数据流的下游操作可以使用meatadata获得此大小。 VectorSizeHint还可以使用一个可选的handleInvalid参数，该参数在向量列包含空值或大小错误的向量时控制其行为。默认情况下，handleInvalid设置为“error”，表示应该抛出异常。此参数也可以设置为“skip”，表示应该从结果数据帧中过滤掉包含无效值的行，或“optimistic”，表示不应检查列是否存在无效值，并且应保留所有行。请注意，使用“optimistic”会导致生成的数据流处于不一致状态，应用VectorSizeHint列的元数据与该列的内容不匹配。用户应注意避免这种不一致的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-# @Time : 2019/8/1 15:47# @Author : 01373821 (mingchengyang@sf-express.com)# @File : vector_size_hint_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.linalg import Vectorsfrom pyspark.ml.feature import (VectorSizeHint, VectorAssembler)from pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;VectorSizeHintExample&quot;)\\ .getOrCreate() dataset = spark.createDataFrame( [(0, 18, 1.0, Vectors.dense([0.0, 10.0, 0.5]), 1.0), (0, 18, 1.0, Vectors.dense([0.0, 10.0]), 0.0)], [&quot;id&quot;, &quot;hour&quot;, &quot;mobile&quot;, &quot;userFeatures&quot;, &quot;clicked&quot;]) sizeHint = VectorSizeHint( inputCol=&quot;userFeatures&quot;, handleInvalid=&quot;skip&quot;, size=3) datasetWithSize = sizeHint.transform(dataset) print(&quot;Rows where 'userFeatures' is not the right size are filtered out&quot;) datasetWithSize.show(truncate=False) assembler = VectorAssembler( inputCols=[&quot;hour&quot;, &quot;mobile&quot;, &quot;userFeatures&quot;], outputCol=&quot;features&quot;) # 该数据流可以用于下游的Transformers output = assembler.transform(datasetWithSize) print(&quot;Assembled columns 'hour', 'mobile', 'userFeatures' to vector column 'features'&quot;) output.select(&quot;features&quot;, &quot;clicked&quot;).show(truncate=False) spark.stop() 结果如下： 12345678910111213Rows where 'userFeatures' is not the right size are filtered out+---+----+------+--------------+-------+|id |hour|mobile|userFeatures |clicked|+---+----+------+--------------+-------+|0 |18 |1.0 |[0.0,10.0,0.5]|1.0 |+---+----+------+--------------+-------+Assembled columns 'hour', 'mobile', 'userFeatures' to vector column 'features'+-----------------------+-------+|features |clicked|+-----------------------+-------+|[18.0,1.0,0.0,10.0,0.5]|1.0 |+-----------------------+-------+ 1.22 分位数离散化器(QuantileDiscretizer)QuantileDiscretizer采用具有连续特征的列，并输出具有分箱分类特征的列。 bin的数量由numBuckets参数设置。所使用的桶的数量可能小于该值，例如，如果输入的不同值太少而不能创建足够的不同分位数。 NaN值：在QuantileDiscretizer拟合期间，NaN值将从中移除。这将产生用于进行预测的Bucketizer模型。在转换过程中，Bucketizer会在数据集中找到NaN值时引发错误，但用户也可以选择通过设置handleInvalid来保留或删除数据集中的NaN值。如果用户选择保留NaN值，它们将被专门处理并放入自己的桶中，例如，如果使用4个桶，那么非NaN数据将被放入桶[0-3]，但是NaN将是算在一个特殊的桶[4]。 算法：使用近似算法选择bin范围（有关详细说明，请参阅approxQuantile的文档）。可以使用relativeError参数控制近似的精度。设置为零时，计算精确分位数（注意：计算精确分位数是一项昂贵的操作）。下边界和上边界将是-Infinity和+ Infinity，覆盖所有实际值。 举例 假设我们有一个包含列id，小时的DataFrame： 1234567891011 id | hour----|------ 0 | 18.0----|------ 1 | 19.0----|------ 2 | 8.0----|------ 3 | 5.0----|------ 4 | 2.2 小时是Double类型的连续特征。 我们希望将连续特征变为分类特征。 给定numBuckets = 3，我们应该得到以下DataFrame： 123456789+---+----+------+| id|hour|result|+---+----+------+| 0|18.0| 2.0|| 1|19.0| 2.0|| 2| 8.0| 1.0|| 3| 5.0| 1.0|| 4| 2.2| 0.0|+---+----+------+ 示例代码： 123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-# @Time : 2019/8/1 15:53# @Author : buracagyang# @File : quantile_discretizer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from __future__ import print_functionfrom pyspark.ml.feature import QuantileDiscretizerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;QuantileDiscretizerExample&quot;)\\ .getOrCreate() data = [(0, 18.0), (1, 19.0), (2, 8.0), (3, 5.0), (4, 2.2)] df = spark.createDataFrame(data, [&quot;id&quot;, &quot;hour&quot;]) df = df.repartition(1) discretizer = QuantileDiscretizer(numBuckets=3, inputCol=&quot;hour&quot;, outputCol=&quot;result&quot;) result = discretizer.fit(df).transform(df) result.show() spark.stop() 1.23 ImputerImputer转换器使用缺失值所在的列的平均值或中值来完成数据集中的缺失值。 输入列应为DoubleType或FloatType。 目前，Imputer不支持分类功能，并且可能为包含分类功能的列创建不正确的值。 Imputer可以通过.setMissingValue（custom_value）将“NaN”以外的自定义值包括在内。 例如，.setMissingValue（0）将计算所有出现的（0）。 注意，输入列中的所有空值都被视为缺失，因此也会被估算。 举例 假设我们有一个包含a和b列的DataFrame： 1234567 a | b ------------|----------- 1.0 | Double.NaN 2.0 | Double.NaN Double.NaN | 3.0 4.0 | 4.0 5.0 | 5.0 在此示例中，Imputer将使用从相应列中的其他值计算的均值（默认插补策略）替换所有出现的Double.NaN（缺失值的缺省值）。 在此示例中，列a和b的替代值分别为3.0和4.0。 转换后，输出列中的缺失值将替换为相关列的替代值。 123456789+---+---+-----+-----+| a| b|out_a|out_b|+---+---+-----+-----+|1.0|NaN| 1.0| 4.0||2.0|NaN| 2.0| 4.0||NaN|3.0| 3.0| 3.0||4.0|4.0| 4.0| 4.0||5.0|5.0| 5.0| 5.0|+---+---+-----+-----+ 示例代码如下: 1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-# @Time : 2019/8/1 15:59# @Author : buracagyang# @File : imputer_example.py# @Software : PyCharm&quot;&quot;&quot;Describe: &quot;&quot;&quot;from pyspark.ml.feature import Imputerfrom pyspark.sql import SparkSessionif __name__ == &quot;__main__&quot;: spark = SparkSession\\ .builder\\ .appName(&quot;ImputerExample&quot;)\\ .getOrCreate() df = spark.createDataFrame([ (1.0, float(&quot;nan&quot;)), (2.0, float(&quot;nan&quot;)), (float(&quot;nan&quot;), 3.0), (4.0, 4.0), (5.0, 5.0) ], [&quot;a&quot;, &quot;b&quot;]) imputer = Imputer(inputCols=[&quot;a&quot;, &quot;b&quot;], outputCols=[&quot;out_a&quot;, &quot;out_b&quot;]) model = imputer.fit(df) model.transform(df).show() spark.stop()","link":"/2019/07/31/spark-features-project-2/"}],"tags":[{"name":"统计学运用","slug":"统计学运用","link":"/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E8%BF%90%E7%94%A8/"},{"name":"技术备忘","slug":"技术备忘","link":"/tags/%E6%8A%80%E6%9C%AF%E5%A4%87%E5%BF%98/"},{"name":"算法备忘","slug":"算法备忘","link":"/tags/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"图计算","slug":"图计算","link":"/tags/%E5%9B%BE%E8%AE%A1%E7%AE%97/"},{"name":"Embedding","slug":"Embedding","link":"/tags/Embedding/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"categories":[],"pages":[]}